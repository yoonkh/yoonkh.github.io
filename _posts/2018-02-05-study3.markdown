---
layout: post
title:  "코딩을 지탱하는 기술"
date:   2018-02-05
author: Yoonkh
categories: Code
tags: Code
comments: True
---

# 180205 재미그래밍 

## 대용량 데이터베이스 솔루션 

### 요약 

- 학습 목표: DB의 심층 구조 파악, 학습
- 학습 결과: DB의 개념 이해

### 학습 내용

#### B-tree 인덱스 

- B-tree 인덱스는 관계형 데이터베이스에서 가장 일반적으로 사용되는 인덱스라 할 수 있음

#### B-tree 인덱스의 구조

- 인덱스는 루트 블록과 브랜치 블록, 리프 블록으로 구성

![](https://github.com/yoonkh/yoonkh.github.io/blob/master/assets/Index_0.JPG)

#### B-tree 인덱스의 조작 

- 인덱스를 생성할 때 일어나는 내부적인 현상과 새로운 데이터 입력 시 발생하는 분할, 삭제, 갱신으로 인한 변화 및 스캔을 할 때 일어나는 내용을 알아 봄

1. 인덱스 생성

![](https://github.com/yoonkh/yoonkh.github.io/blob/master/assets/Index.JPG)

2. 인덱스 분할

- 인덱스는 정렬되어야 한다는 점 때문에 이미 생성된 구조에 새로운 로우가 삽입되면 기존의 위치에 파고 들어가야 하는 문제가 발생

	1. PCTFREE에 도달한 인덱스 블록에 마지막 값이 입력되면 구조에 영향을 미치지 않고 새로운 블록을 만들고 거기에 등록
	
	2. 중간 값이 입력되면 PCTFREE가 초과하므로 분할이 발생
	
	3. 두 블록 모두 수정되어야 하므로 2/3만 채우도록 하면서 양쪽을 모두 새로 재편
	
	4. 이 이유는 또 다른 로우가 입력될 경우 분할이 계속 발생하는 것을 방지 하기 위함
	
	5. 중간에 로우가 입력된 경우 2/3만 채우게 되므로 만약 이렇게 분할이 발생하고 그 블록에 값이 들어오지 않는다면 저장공간이 크게 늘어날 소지도 있음. 이를 교정하는 방법은 인덱스를 재생성(Rebuild)하는 방법뿐임

3. 데이터의 삭제 및 갱신

- 데이터를 삭제했을 때 테이블의 로우는 제거되지만 인덱스의 로우는 단지 삭제되었음을 표시하므로 그 자리에 인덱스 로우가 추가되지 않을 경우 저장공간의 낭비뿐 아니라 스캔해야 할 블록이 증가함

4. 인덱스를 경유한 검색

	1. 루트를 찾음

	2. 주어진 값보다 큰 최소값을 찾음

	3. 리프 블록을 찾을 때까지 2번을 반복함

	4. 리프 블록에서 값을 찾은 후 ROWID를 이용해 테이블을 액세스 

#### 리버스키 인덱스 

- 리버스는 Desc이 아닌 컬럼값 자체의 역순을 의미함
예) 1112, 1113 -> 2111, 3111 

![](https://github.com/yoonkh/yoonkh.github.io/blob/master/assets/Index2.JPG)

- 활용 범위 및 제약 조건

1. 클러스터링 팩터가 나빠짐 -> Hot Block을 제거하기 위한 용도

2. '=' 조건만을 사용할 수 있음 -> 실제 정렬과 달라지기 때문에

