---
layout: post
title:  "Jump to Python - 파이썬 날개 달기"
date:   2017-11-29
author: Yoonkh
categories: Python
tags:	Python
comments: True
---



## 클래스 

### 클래스는 도대체 왜 필요한가?

가장 많이 사용하는 프로그래밍 언어 중 하나인 C 언어에는 클래스가 없다. 이 말은 굳이 클래스 없이도 프로그램을 충분히 만들 수 있다는 말과도 같다. 파이썬으로 잘 만들어진 프로그램들을 살펴보아도 클래스를 이용하지 않고 작성된 것들이 상당히 많다. 클래스는 지금까지 공부한 함수나 자료형처럼 프로그램 작성을 위해 꼭 필요한 요소는 아니다.

- 계산기를 사용해 봤을 것이다. 계산기에 3이라는 숫자를 입력하고 + 기호를 입력한 후 4를 입력하면 결과값으로 7을 보여준다. 다시 한 번 + 기호를 입력한 후 3을 입력하면 기존 결과값 7에 3을 더해 10을 보여준다. 즉, 계산기는 이전에 계산된 결과값을 항상 메모리 어딘가에 저장하고 있어야 한다.

	- 다음은 계산기의 "더하기" 기능을 구현한 파이선 코드이다

	```
	result = 0

	def adder(num):
	    global result
	    result += num
	    return result
	
	print(adder(3))
	print(adder(4))
	```
	
	- 이전에 계산된 결과값을 유지하기 위해서 	result라는 전역 변수(global)를 사용했다. 실행하면 예상한 대로 다음과 같은 결과값이 출력된다.

	```
	3
	7
	```

그런데 만약 한 프로그램에서 2개의 계산기가 필요한 상황이 발생하면 어떻게 해야 할까? 각각의 계산기는 각각의 결과값을 유지해야 하기 때문에 위와 같이 adder 함수 하나만으로는결과값을 따로 유지할 수 없다.

```
result1 = 0
result2 = 0

def adder1(num):
    global result1
    result1 += num
    return result1

def adder2(num):
    global result2
    result2 += num
    return result2

print(adder1(3))
print(adder1(4))
print(adder2(3))
print(adder2(7))
```

- 똑같은 일을 하는 adder1과 adder2라는 함수가 만들어졌고 각각의 함수에서 계산된 결과값을 유지하면서 저장하기 위한 전역 변수 result1, result2가 필요하게 되었다.

	- 결과값은 다음과 같이 의도한 대로 출력된다.

	```
	3
	7
	3
	10
	```
	
## 클래스와 객체

과자를 만드는 과자틀과 만들어진 과자들이다.

- 과자틀 -> 클래스(class)
- 과자틀에 의해서 만들어진 과자들 -> 객체(object)

클래스는 과자틀과 비슷하다

클래스(class)란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고(과자 틀), 객체(object)란 클래스에 의해서 만들어진 피조물(과자틀에 의해서 만들어진 과자)을 뜻한다.

- 클래스에 의해서 만들어진 객체에는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 과자틀에 의해서 만들어진 과자에 구멍을 뚫거나 조금 베어먹더라도 다른 과자들에는 아무 영향이 없는것과 마찬가지로 동일한 클래스에의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다.

```
>>> class Cookie:
>>>  	pass
```

- 위의 클래스는 아무런 기능도 갖고 있지 않은 껍질뿐인 클래스이다. 하지만 이렇게 껍질뿐인 클래스도 객체를 생성하는 기능은 가지고 있다. "과자 틀"로 "과자"를 만드는 것처럼 말이다.

## 사칙연산 클래스 만들기

### 클래스를 어떻게 만들지 먼저 구상하기

- 사칙연산을 가능하게 하는 FourCal이라는 클래스가 다음처럼 동작한다고 가정해 보자.

클래스는 무작정 만들기 보다는 클래스에 의해서 만들어진 객체를 중심으로 어떤 식으로 동작하게 할 것인지 미리 구상을 한 후에 생각했던 것들을 하나씩 해결하면서 완성해 나가는 것이 좋다.

### 클래스 구조 만들기

```
>>> class FourCal:
...     pass
... 
>>>
```

- 현재 상태에서 FourCal 클래스는 아무런 변수나 메서드도 포함하지 않지만 우리가 원하는 객체 a를 만들 수 있는 기능은 가지고 있다

```
>>> a = FourCal()
>>> type(a)
<class '__main__.FourCal'>
```

- 위와 같이 a = FourCal()로 a라는 객체를 먼저 만들고 그 다음에 type(a)로 a라는 객체가 어떤 타입인지 알아보았다. 역시 객체 a가 FourCal 클래스의 인스턴스임을 알 수 있다.

### 객체에 숫자 지정할 수 있게 만들기

하지만 생성된 객체 a는 아직 아무런 기능도 하지 못한다. 이제 더하기, 나누기, 곱하기, 빼기등의 기능을 하는 객체를 만들어야 한다

```
>>> a.setdata(4, 2)
```

- 연산을 수행할 대상(4, 2)을 객체에 지정할 수 있게 만들어 보자.

```
>>> class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...
>>>
```

- 이전에 만들었던 FourCal 클래스에서 pass라는 문장을 삭제하고 class 내부에 setdata라는 함수를 만들었다. 클래스 안에 구현된 함수는 다른말로 **메서드(Method)**라고 부른다

setdata 메서드를 다시 보면 아래와 같다.

```
def setdata(self, first, second):   # ① 메서드의 입력 인수
    self.first = first              # ② 메서드의 수행문
    self.second = second            # ② 메서드의 수행문
```

**① setdata 메서드의 입력 인수**

- setdata 메서드는 입력 인수로 self, first, second라는 3개의 입력값을 받는다. 그런데 일반적인 함수와는 달리 메서드의 첫 번째 입력 인수 self는 특별한 의미를 가지고 있다.

```
>>> a = FourCal()
>>> a.setdata(4, 2)
```

- 위에서 보는 것처럼 a라는 객체를 만든 다음에 a.setdata(4, 2)처럼 호출하면 FourCal 클래스의 setdata 메서드가 호출되고 setdata 메서드의 첫 번째 인수 self에는 자동으로 a라는 객체가 대입된다. 

**② setdata 메서드의 수행문**

setdata 메서드는 수행할 문장이 2개 있다!

```
self.first = first
self.second = second
```

- 위 수행문이 뜻하는 바는 무엇일까? 입력 인수로 받은 first는 4이고 second는 2라는 것은 앞에서 이미 알았다. 그렇다면 위의 문장은 다음과 같이 바뀔 것이다.

```
self.first = 4
self.second = 2
```

여기서 중요한 것은 바로 self이다. self는 a.setdata(4, 2)처럼 호출했을 때 자동으로 들어오는 객체 a라고 했다. 그렇다면 self.first의 의미는 무엇이겠는가? 당연히 a.first가 될 것이다. 또한 self.second는 당연히 a.second가 될 것이다.

#### 따라서 위의 두 문장을 풀어서 쓰면 다음과 같이 된다.

```
a.first = 4
a.second = 2
```

위와 같이 바뀐 문장이 실행되어 결국 a객체에는 first와 second라는 객체변수가 생성된다.

- 객체변수는 다음과 같이 만들어진다.

```
객체.객체변수 = 값
```

**객체변수는 객체에 정의된 변수를 의미하며 객체간 서로 공유되지 않는 특징을 갖는다!**

### 더하기 기능 만들기

2개의 숫자값을 설정해 주었으니 2개의 숫자를 더하는 기능을 추가해 보자!

- 더하기 기능을 갖춘 클래스를 만들어야 한다!

```
>>> class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def sum(self):
...         result = self.first + self.second
...         return result
...
>>>
```

- 새롭게 추가된 것은 sum이라는 메서드이다

```
def sum(self):
    result = self.first + self.second
    return result
```

- sum 메서드의 입력 인수는 self이고 리턴값은 result이다.

	- 리턴 값인 result를 계산하는 부분은 다음과 같다.

	```
	result = self.first + self.second
	```
	
	- ```a.sum()``` 과 같이 a 객체에 의해 sum 메서드가 수행되면 sum 메서드의 self에는 객체 a가 자동으로 입력되므로 위의 내용은 아래와 같이 해석된다.	

	```
	result = a.first + a.second
	```
	
## 곱하기, 빼기, 나누기 기능 만들기

```
>>> class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def sum(self):
...         result = self.first + self.second
...         return result
...     def mul(self):
...         result = self.first * self.second
...         return result
...     def sub(self):
...         result = self.first - self.second
...         return result
...     def div(self):
...         result = self.first / self.second
...         return result
...
>>>
```

- mul, sub, div 모두 sum 메서드에서 배운 것과 동일한 방법이다!

```
>>> a = FourCal()
>>> b = FourCal()
>>> a.setdata(4, 2)
>>> b.setdata(3, 7)
>>> a.sum()
6
>>> a.mul()
8
>>> a.sub()
2
>>> a.div()
2
>>> b.sum()
10
>>> b.mul()
21
>>> b.sub()
-4
>>> b.div()
0
```

## 생성자 (Constructor)
	
```
>>> a = FourCal()
>>> a.sum()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in sum
AttributeError: 'FourCal' object has no attribute 'first'
```

- FourCal 클래스의 인스턴스 a에 setdata메서드를 수행하지 않고 sum 메서드를 수행하면 "AttributeError: 'FourCal' object has no attribute 'first'" 라는 오류가 발생하게 된다. setdata 메서드를 수행해야 객체 a의 객체변수 first와 second에 값이 할당되기 때문이다

	- 이렇게 객체에 초기값을 설정해야 할 필요가 있을때는 setdata와 같은 메서드를 호출하여 초기값을 설정하기 보다는 생성자를 구현하는 것이 안전한 방법이다.

**생성자(Constructor)란 객체가 생성될 때 자동으로 호출되는 메서드를 의미한다.**

파이썬 메서드명으로 ```__init__``` 을 사용하면 이 메서드는 생성자가 된다.

- FourCal클래스에 생성자를 추가해 보자.

```
>>> class FourCal:
...     def __init__(self, first, second):
...         self.first = first
...         self.second = second
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def sum(self):
...         result = self.first + self.second
...         return result
...     def mul(self):
...         result = self.first * self.second
...         return result
...     def sub(self):
...         result = self.first - self.second
...         return result
...     def div(self):
...         result = self.first / self.second
...         return result
...
>>>
```

- ```__init__``` 메서드는 setdata메서드와 이름만 틀리고 모든게 동일하다. 단, 메서드 이름을 ```__init__```으로 했기 때문에 생성자로 인식되어 객체가 생성되는 시점에 자동으로 호출되는 차이가 있다.	

## 클래스의 상속

상속(Inheritance)이란 "물려받다"라는 뜻으로, "재산을 상속받다"라고 할 때의 상속과 같은 의미이다. 클래스에도 이런 개념을 적용할 수가 있다. 어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만드는 것이다.

**클래스를 상속하기 위해서는 다음처럼 클래스명 뒤 괄호 안에 상속할 클래스명을 넣어 주면 된다**

```
class 클래스명(상속할 클래스명)
```

#### 메서드 오버라이딩

부모 클래스(상속한 클래스)에 있는 메서드를 동일한 이름으로 다시 만드는 것을 메서드 오버라이딩(Overriding, 덮어쓰기)이라고 한다. 

- 메서드를 오버라이딩하면 부모 클래스의 메서드 대신 오버라이딩한 메서드가 호출된다.

## 모듈

모듈이란 함수나 변수 또는 클래스 들을 모아 놓은 파일이다. 모듈은 다른 파이썬 프로그램에서 불러와 사용할수 있게끔 만들어진 파이썬 파일이라고도 할 수 있다.

## 모듈 만들고 불러 보기

```
# mod1.py
def sum(a, b):
    return a + b
```

- 위와 같이 sum 함수만 있는 파일 mod1.py를 만들고 ```C:\Python``` 디렉터리에 저장하면, 그 파일이 바로 모듈이다.    

**import의 사용 방법은 다음과 같다.**

```
import 모듈이름
```

## 클래스나 변수 등을 포함한 모듈

지금까지 살펴본 모듈은 함수만 포함했지만 클래스나 변수 등을 포함할 수도 있다

```
# mod2.py 
PI = 3.141592

class Math: 
    def solv(self, r): 
        return PI * (r ** 2) 

def sum(a, b): 
    return a+b 

if __name__ == "__main__": 
    print(PI)
    a = Math() 
    print(a.solv(2)) 
    print(sum(PI , 4.4))
```

- 이 파일은 원의 넓이를 계산하는 Math 클래스와 두 값을 더하는 sum 함수 그리고 원주율 값에 해당되는 PI 변수처럼 클래스, 함수, 변수 등을 모두 포함하고 있다   

	- 대화형 인터프리터를 열고 다음과 같이 따라해보면,

	```
	C:\Python>python
	>>> import mod2
	>>> 
	```
	
	- ```__name__ == "__main__"```이 거짓이 되므로 아무런 값도 출력되지 않는다.

## 예외 처리

때때로 오류를 무시하고 싶을 때도 있고 별도로 처리하고 싶을 때도 있다. 이에 파이썬은 try, except를 이용해서 오류를 처리할 수 있게 해준다.

### 오류는 어떤 때 발생하는가?

- 디렉터리 안에 없는 파일을 열려고 시도했을 때 발생하는 오류이다.

```
>>> f = open("나없는파일", 'r')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: '나없는파일'
```

- 위의 예에서 볼 수 있듯이 없는 파일을 열려고 시도하면 "FileNotFoundError"라는 이름의 오류가 발생하게 된다.

```
>>> 4 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

- 4를 0으로 나누려니까 "ZeroDivisionError"라는 이름의 오류가 발생한다.

## 오류 예외 처리 기법

#### try, except문

- 다음은 오류 처리를 위한 try, except문의 기본 구조이다.

```
try:
    ...
except [발생 오류[as 오류 메시지 변수]]:
    ...
```

- try 블록 수행 중 오류가 발생하면 except 블록이 수행된다. 하지만 try블록에서 오류가 발생하지 않는다면 except 블록은 수행되지 않는다.

#### try .. else

try문은 else절을 지원한다. else절은 예외가 발생하지 않은 경우에 실행되며 반드시 except절 바로 다음에 위치해야 한다.

#### try .. finally

try문에는 finally절을 사용할 수 있다. finally절은 try문 수행 도중 예외 발생 여부에 상관없이 항상 수행된다. 보통 finally절은 사용한 리소스를 close해야 할 경우에 많이 사용된다.

#### 여러개의 오류처리하기

try문 내에서 여러개의 오류를 처리하기 위해서는 다음과 같은 구문을 이용한다.


```
try:
    ...
except 발생 오류1:
   ... 
except 발생 오류2:
   ...
```

## 오류 회피하기

프로그래밍을 하다 보면 특정 오류가 발생할 경우 그냥 통과시켜야 할 때가 있을 수 있다!

```
try:
    f = open("나없는파일", 'r')
except FileNotFoundError:
    pass
```

- try문 내에서 FileNotFoundError가 발생할 경우 pass를 사용하여 오류를 그냥 회피하도록 한 것이다!

## 오류 일부러 발생시키기

이상하게 들리겠지만 프로그래밍을 하다 보면 종종 오류를 일부러 발생시켜야 할 경우도 생긴다. 파이썬은 raise라는 명령어를 이용해 오류를 강제로 발생시킬 수 있다.

- 예를 들어 Bird라는 클래스를 상속받는 자식 클래스는 반드시 fly라는 함수를 구현하도록 만들고 싶은 경우(강제로 그렇게 하고 싶은 경우)가 있을 수 있다. 

```
class Bird:
    def fly(self):
        raise NotImplementedError
```

- 위 예제는 Bird 클래스를 상속받는 자식 클래스는 반드시 fly라는 함수를 구현해야 한다는 의지를 보여준다.

## 오류 만들기

프로그램 수행 도중 특수한 경우에만 예외처리를 하기 위해서 종종 오류를 만들어서 사용하게 된다.

## 내장 함수

무엇인가 새로운 프로그램을 만들기 전에는 이미 만들어진 것들, 그중에서도 특히 파이썬 배포본에 함께 들어 있는 파이썬 라이브러리들을 살펴보는 것이 매우 중요하다.

### abs

- abs(x)는 어떤 숫자를 입력으로 받았을 때, 그 숫자의 절대값을 돌려주는 함수이다.

```
>>> abs(3)
3
>>> abs(-3)
3
>>> abs(-1.2)
1.2
```

### all

all(x)은 반복 가능한(iterable) 자료형 x를 입력 인수로 받으며, 이 x가 모두 참이면 True, 거짓이 하나라도 있 으면 False를 리턴한다.

```
>>> all([1, 2, 3])
True
```

### any

any(x)는 x 중 하나라도 참이 있을 경우 True를 리턴하고, x가 모두 거짓일 경우에만 False를 리턴한다. all(x)의 반대 경우라고 할 수 있다.

### chr

chr(i)는 아스키(ASCII) 코드값을 입력으로 받아 그 코드에 해당하는 문자를 출력하는 함수이다.

### dir

dir은 객체가 자체적으로 가지고 있는 변수나 함수를 보여 준다. 

### divmod

divmod(a, b)는 2개의 숫자를 입력으로 받는다. 그리고 a를 b로 나눈 몫과 나머지를 튜플 형태로 리턴하는 함수이다.

### enumerate

enumerate는 "열거하다"라는 뜻이다. 이 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 리턴한다.

**for문처럼 반복되는 구간에서 객체가 현재 어느 위치에 있는지 알려주는 인덱스 값이 필요할때 enumerate 함수를 사용하면 매우 유용하다.**

### eval

eval(expression)은 실행 가능한 문자열(1+2, 'hi' + 'a' 같은 것)을 입력으로 받아 문자열을 실행한 결과값을 리턴하는 함수이다.

**보통 eval은 입력받은 문자열로 파이썬 함수나 클래스를 동적으로 실행하고 싶은 경우에 사용된다.**

### filter

filter란 무엇인가를 걸러낸다는 뜻으로, filter 함수도 동일한 의미를 가진다. filter 함수는 첫 번째 인수로 함수 이름을, 두 번째 인수로 그 함수에 차례로 들어갈 반복 가능한 자료형을 받는다. 그리고 두 번째 인수인 반복 가능한 자료형 요소들이 첫 번째 인수인 함수에 입력되었을 때 리턴값이 참인 것만 묶어서(걸러내서) 돌려준다.

### hex

hex(x)는 정수값을 입력받아 16진수(hexadecimal)로 변환하여 리턴하는 함수이다.

### id 

id(object)는 객체를 입력받아 객체의 고유 주소값(레퍼런스)을 리턴하는 함수이다.

### input

input([prompt])은 사용자 입력을 받는 함수이다. 입력 인수로 문자열을 주면 그 문자열은 프롬프트가 된다.

```
>>> a = input()
hi
>>> a
'hi'
>>> b = input("Enter: ")
Enter: hi
```

### int

int(x)는 문자열 형태의 숫자나 소수점이 있는 숫자 등을 정수 형태로 리턴하는 함수로, 정수를 입력으로 받으면 그대로 리턴한다.

```
>>> int('3')
3
>>> int(3.4)
3
```

### isinstance

isinstance(object, class)는 첫 번째 인수로 인스턴스, 두 번째 인수로 클래스 이름을 받는다. 입력으로 받은 인스턴스가 그 클래스의 인스턴스인지를 판단하여 참이면 True, 거짓이면 False를 리턴한다.

```
>>> class Person: pass
...
>>> a = Person()
>>> isinstance(a, Person)
True
```

### lambda

lambda는 함수를 생성할 때 사용하는 예약어로, def와 동일한 역할을 한다. 보통 함수를 한줄로 간결하게 만들 때 사용한다. 우리말로는 "람다"라고 읽고 def를 사용해야 할 정도로 복잡하지 않거나 def를 사용할 수 없는 곳에 주로 쓰인다.

```
lambda 인수1, 인수2, ... : 인수를 이용한 표현식
```

```
>>> sum = lambda a, b: a+b
>>> sum(3,4)
7
```

- lambda를 이용한 sum 함수는 인수로 a, b를 받아 서로 더한 값을 돌려준다. 

### len

len(s)은 입력값 s의 길이(요소의 전체 개수)를 리턴하는 함수이다.

```
>>> len("python")
6
>>> len([1,2,3])
3
>>> len((1, 'a'))
2
```

### list

list(s)는 반복 가능한 자료형 s를 입력받아 리스트로 만들어 리턴하는 함수이다.

```
>>> list("python")
['p', 'y', 't', 'h', 'o', 'n']
>>> list((1,2,3))
[1, 2, 3]
```

### map

map(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다. map은 입력받은 자료형의 각 요소가 함수 f에 의해 수행된 결과를 묶어서 리턴하는 함수이다.

### max

max(iterable)는 인수로 반복 가능한 자료형을 입력받아 그 최대값을 리턴하는 함수이다.

```
>>> max([1, 2, 3])
3
>>> max("python")
'y'
```

### min 

min(iterable)은 max 함수와 반대로, 인수로 반복 가능한 자료형을 입력받아 그 최소값을 리턴하는 함수이다.

```
>>> min([1, 2, 3])
1
>>> min("python")
'h'
```

### oct

oct(x)는 정수 형태의 숫자를 8진수 문자열로 바꾸어 리턴하는 함수이다.

```
>>> oct(34)
'0o42'
>>> oct(12345)
'0o30071'
```

### open

open(filename, [mode])은 "파일 이름"과 "읽기 방법"을 입력받아 파일 객체를 리턴하는 함수이다. 읽기 방법(mode)이 생략되면 기본값인 읽기 전용 모드(r)로 파일 객체를 만들어 리턴한다.

| **mode**  | **설명**  |
|---|---|
| w  | 쓰기 모드로 파일 열기  |
| r  | 읽기 모드로 파일 열기  |
| a  | 추가 모드로 파일 열기  |
| b  | 바이너리 모드로 파일 열기  |


### ord

ord(c)는 문자의 아스키 코드값을 리턴하는 함수이다.

```
>>> ord('a')
97
>>> ord('0')
48
```

### pow

pow(x, y)는 x의 y 제곱한 결과값을 리턴하는 함수이다.

```
>>> pow(2, 4)
16
>>> pow(3, 3)
27
```

### range

range([start,] stop [,step])는 for문과 함께 자주 사용되는 함수이다. 이 함수는 입력받은 숫자에 해당되는 범위의 값을 반복 가능한 객체로 만들어 리턴한다.

#### 인수가 하나일 경우

시작 숫자를 지정해 주지 않으면 range 함수는 0부터 시작한다.

```
>>> list(range(5))
[0, 1, 2, 3, 4]
```

#### 인수가 2개일 경우

입력으로 주어지는 2개의 인수는 시작 숫자와 끝 숫자를 나타낸다. 단, 끝 숫자는 해당 범위에 포함되지 않는다는 것에 주의해야 한다!!!!

```
>>> list(range(5, 10))
[5, 6, 7, 8, 9]
```

#### 인수가 3개일 경우

세 번째 인수는 숫자 사이의 거리를 말한다.

```
>>> list(range(1, 10, 2))
[1, 3, 5, 7, 9]
>>> list(range(0, -10, -1))
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
```

### sorted

sorted(iterable) 함수는 입력값을 정렬한 후 그 결과를 리스트로 리턴하는 함수이다.

```
>>> sorted([3, 1, 2])
[1, 2, 3]
>>> sorted(['a', 'c', 'b'])
['a', 'b', 'c']
>>> sorted("zero")
['e', 'o', 'r', 'z']
>>> sorted((3, 2, 1))
[1, 2, 3]
```

- 리스트 자료형에도 sort라는 함수가 있다. 하지만 리스트 자료형의 sort 함수는 리스트 객체 그 자체를 정렬만 할 뿐 정렬된 결과를 리턴하지는 않는다.

### str

str(object)은 문자열 형태로 객체를 변환하여 리턴하는 함수이다.

```
>>> str(3)
'3'
>>> str('hi')
'hi'
>>> str('hi'.upper())
'HI'
```

### tuple

tuple(iterable)은 반복 가능한 자료형을 입력받아 튜플 형태로 바꾸어 리턴하는 함수이다. 만약 튜플이 입력으로 들어오면 그대로 리턴한다.

```
>>> tuple("abc")
('a', 'b', 'c')
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> tuple((1, 2, 3))
(1, 2, 3)
```

### type

type(object)은 입력값의 자료형이 무엇인지 알려주는 함수이다.

```
>>> type("abc")
<class 'str'>
>>> type([ ])
<class 'list'>
>>> type(open("test", 'w'))
<class '_io.TextIOWrapper'>
```

### zip

```zip(iterable*)```은 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수이다.

```
>>> list(zip([1, 2, 3], [4, 5, 6]))
[(1, 4), (2, 5), (3, 6)]
>>> list(zip([1, 2, 3], [4, 5, 6], [7, 8, 9]))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
>>> list(zip("abc", "def"))
[('a', 'd'), ('b', 'e'), ('c', 'f')]
```

## 외장 함수

### sys

sys 모듈은 파이썬 인터프리터가 제공하는 변수들과 함수들을 직접 제어할 수 있게 해주는 모듈이다.

#### 명령 행에서 인수 전달하기 - sys.argv

```
C:/User/home>python test.py abc pey guido
```

- 도스 창에서 위의 예처럼 test.py 뒤에 또 다른 값들을 함께 넣어 주면 sys.argv라는 리스트에그 값들이 추가된다.

#### 강제로 스크립트 종료하기 - sys.exit

```
>>> sys.exit()
```

#### 자신이 만든 모듈 불러와 사용하기 - sys.path

### pickle

pickle은 객체의 형태를 그대로 유지하면서 파일에 저장하고 불러올 수 있게 하는 모듈이다

## OS 모듈

OS 모듈은 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈이다.

#### 내 시스템의 환경 변수값을 알고 싶을 때 - os.environ

시스템은 제각기 다른 환경 변수값을 가지고 있는데, os.environ은 현재 시스템의 환경 변수 값들을 보여 준다

#### 디렉터리 위치 변경하기 - os.chdir

#### 디렉터리 위치 리턴받기 - os.getcwd

#### 시스템 명령어 호출하기 - os.system

#### 실행한 시스템 명령어의 결과값 리턴받기 - os.popen

- os.popen은 시스템 명령어를 실행시킨 결과값을 읽기 모드 형태의 파일 객체로 리턴한다.

```
>>> f = os.popen("dir")
```

#### 파일 복사하기 - shutil.copy(src, dst)

### glob

가끔 파일을 읽고 쓰는 기능이 있는 프로그램을 만들다 보면 특정 디렉터리에 있는 파일 이름 모두를 알아야 할 때가 있다. 이럴 때 사용하는 모듈이 바로 glob이다.

#### 디렉터리에 있는 파일들을 리스트로 만들기 - glob(pathname)

glob 모듈은 디렉터리 내의 파일들을 읽어서 리턴한다. ```*```, ```?``` 등의 메타 문자를 써서 원하는 파일만 읽어 들일 수도 있다.

### tempfile

파일을 임시로 만들어서 사용할 때 유용한 모듈이 바로 tempfile이다. tempfile.mktemp()는 중복되지 않는 임시 파일의 이름을 무작위로 만들어서 리턴한다.

### time

#### time.time

time.time()은 UTC(Universal Time Coordinated 협정 세계 표준시)를 이용하여 현재 시간을 실수 형태로 리턴하는 함수이다. 1970년 1월 1일 0시 0분 0초를 기준으로 지난 시간을 초 단위로 리턴한다.

#### time.localtime

time.localtime은 time.time()에 의해서 반환된 실수값을 이용해서 연도, 월, 일, 시, 분, 초,.. 의 형태로 바꾸어 주는 함수이다.

#### time.asctime

time.localtime에 의해서 반환된 튜플 형태의 값을 인수로 받아서 날짜와 시간을 알아보기 쉬운 형태로 리턴하는 함수이다.

#### time.ctime

time.asctime(time.localtime(time.time()))은 time.ctime()을 이용해 간편하게 표시할 수 있다

#### time.strftime

strftime 함수는 시간에 관계된 것을 세밀하게 표현할 수 있는 여러 가지 포맷 코드를 제공한다.

#### time.sleep

time.sleep 함수는 주로 루프 안에서 많이 사용된다. 이 함수를 사용하면 일정한 시간 간격을 두고 루프를 실행할 수 있다. 

### calendar

calendar는 파이썬에서 달력을 볼 수 있게 해주는 모듈이다.

### random

random은 난수(규칙이 없는 임의의 수)를 발생시키는 모듈이다

### webbrowser

webbrowser는 자신의 시스템에서 사용하는 기본 웹 브라우저가 자동으로 실행되게 하는 모듈이다.
