---
layout: post
title:  "뇌를 자극하는 파이썬 3 - 코딩으로의 초대"
date:   2017-12-08
author: Yoonkh
categories: Python
tags:	Python
comments: True
---



# 뇌를 자극하는 파이썬 3

## 코딩으로의 초대

### 코딩의 즐거움 요소

- 무언가를 창조한다는 순수한 즐거움

- 다른 사람들에게 쓸모 있는 것을 만드는 기쁨

- 복잡한 퍼즐을 맞추듯 정교한 부품을 조립하여 완성하는 것에서 얻는 희열

- 항상 배우고 성장하는 즐거움

- 다루기 쉬운 매체를 이용해 작업하는 즐거움

**코딩의 재미는 글로 다 표현이 불가능하다!!!**

*축구를 제대로 해보기전까지는 축구가 얼마나 재미있는지 알 수 없는 것과 같다고 할 수 있다*

- 취미로서의 코딩의 장점: 코딩은 전기세 이외에는 돈이 들지 않는다!!!

### 문제 해결 능력을 키우는 코딩 

- 이미 교육계에서 이루어진 여러 연구가 컴퓨터 프로그래밍이 논리적 추론 능력의 향상에 도움을 준다는 사실을 뒷받침하고 있다!

- 코딩을 즐겁게 하다보면 논리적 추론능력 뿐만 아니라 논리적 사고, 계획하는 능력, 일반적인 문제 해결능력이 저절로 향상된다!

우리가 페이스북 CEO처럼 수십조 원에 달하는 기업을 경영하고 있지는 않더라도 직장이나 삶에서 만나는 문제들을 풀어나가는데 코딩이 도움을 줄 수 있다!

### 아이디어를 현실로!

- 재미있는 이야기 거리가 있어도 그림을 그릴 줄 알아야 그 이야기를 만화로 만들 수 있고, 글을 쓸 줄 알아야 소설을 만들 수 있다!

- 아무리 좋은 아이디어가 있더라도 코딩을 할 줄 모른다면 그것을 실체화 할 수 없다!

**코딩을 할 수 있는 과학도는 얼마든지 컴퓨터 시뮬레이션을 만들어 이론을 검증해 볼 수 있다!**

보통의 발명가라면 아이디어가 떠올랐을 때 갖가지 재료를 구입해서 먼지 날리는 가공을 해야 하겠지만, 코드는 돈도 들지 않고 먼지도 날리지 않는 멋진 재료이다. 시간만 투자한다면 여러분의 아이디어를 살아 움직이는 것으로 만들 수 있다.

### 누구나 할 수 있는 코딩

컴퓨터가 세상에 처음 나왔을 때 얼마동안은 과학자와 기술자의 전유물이었지만, 오늘날에는 초등학생이나 식당주인처럼 누구나 배울 수 있다.

- 의식하지 못하고 코딩을 해왔을 수 있다. 워드프로세서나 스프레드 시트에서 매크로를 이용해서 작업을 자동화 시켜봤다면 그것이 프로그래밍이다!

- 2011년부터 영국에서는 '코딩은 새로운 라틴어'라는 캠패인을 통해 청소년들의 프로그래밍 교육을 확대하고 있다.

- 뉴욕의 블룸버그 시장도 자신의 2012년 새해 목표가 '코딩 익히기'라고 발표하여 사람들에게 코딩에 대한 관심을 불러 일으켰다!

## 코딩을 배우기 전에 읽는 컴퓨터 구조론

### 폰노이만 구조

천재 과학자 폰노이만은 1945년에 데이터와 명령어를 보관하는 기억 장치(MEMORY) 그리고 데이터의 가공을 담당하는 중앙처리장치(CPU)로 구성되는 현대 컴퓨터의 구조를 최초로 정의했다.

- 현재 우리가 사용하고 있는 거의 모든 전자 기기들은 폰노이만 구조를 이용하고 있다.

### 중앙 처리 장치 (CPU)

중앙처리장치는 컴퓨터에서 가장 중요한 장치라고 할 수 있다. 컴퓨터가 수행하는 계산은 모두 이 CPU를 통해서 이루어지기 때문이다. 

- 자동차로 비유하면 엔진과 같다

*컴퓨터를 여러 연주자로 이루어진 오케스트라에 비한다면, 제어 장치는 이 오케스트라의 지휘자라고 할 수 있다. 제어장치와 산술 논리 장치는 다음과 같은 과정을 통햇 곡을 연주한다.

**1.** 먼저 제어장치가 기억 장치로부터 명령어를 가져온다(Fetch)

**2.** 제어장치는 가져온 명령어를 해독(Decode)한다.

**3.** 제어장치는 해독한 명령어에 따라 산술 논리 장치에 데이터를 옮기고 어떤 연산을 수행할지를 지시한다.

**4.** 산술 논리 장치는 제어 장치가 지시한 대로 계산을 수행(Execute)한다.

**5.** 그리고 수행한 결과를 기억 장치에 다시 저장(Store)한다.

*ex) 어떤 CPU의 클럭 주파수가 1GHz라고 한다면, 그 CPU는 1초에 10억회의 명령 주기를 수행하는 성능을 지닌것이다!!!*

### 기억 장치 (Memory)

기억장치는 데이터와 함께 명령어를 저장하는 역할을 한다. 메모리의 용량이 클 수록 더 많은 데이터와 명령어를 저장할 수 있고, 메모리가 빠르게 동작할수록 더 빠르게 CPU와 데이터와 명령어를 교환 할 수 있다.

### 입력/출력 장치

다양한 입출력 장치들은 '입출력 버스'를 통해 중앙 처리 장치, 기억 장치와 정보를 주고 받는다. 

- 버스는 우리가 자주 이용하는 대중교통 수단인 바로 그 버스와 철자가 동일하지만 컴퓨터 과학에서 버스라고 하면 '컴퓨터의 정보 전송 회로'를 말한다.

**중앙처리장치와 기억 장치, 그리고 입출력 장치는 버스로 연결되어 있다.**

컴퓨터에서는 중앙 처리 장치, 기억 장치, 입출력 장치가 동일한 입출력 버스를 사용함으로써 빠르게 동작하는 중앙 처리 장치가 느려터진 입출력 장치 때문에 제 성능을 낼 수 없는 문제가 발생한다!

이문제를 해결하기 위해서 버스를 두가지로 나누었다!

- 먼저 CPU와 기억장치는 시스템 버스로 묶고, 그 다음 다양한 입출력 장치들은 입출력 버스로 묶어 CPU의 입출력 모듈에 연결한다.

- 4차선 고속도로에서 바깥쪽 차선은 저속차량이 이용하고 안쪽 차선은 고속차량이 달리도록 하는 것과 같다.

### 운영체제와 애플리케이션

운영체제는 애플리케이션에 API(Application Programming Interface)를 제공하여 운영체제가 제어하고 있는 하드웨어를 이용할 수 있도록 한다.

- 만약 운영체제가 없었다면 맥북 에어의 하드웨어 제어코드와 MS 서피스 하드웨어 제어코드를 일일이 애플리케이션안에 작성하는 대참사가 발생했을 것이다.

### 소프트웨어는 무엇으로 만드는가?

**"허리를 바로 세우고 왼팔을 앞으로 내저으며 오른팔을 뒤로 내저어라. 동시에 몸의 중심을 앞으로 옮기며 왼발을 받침으로 삼고 오른발을 앞으로 내밀어라. 그리고 별도의 지시가 있기 전까지 이 행동을 계속하라."**

그냥 "앞으로 가"라고 하면 되는데 저런 식으로 사람에게 지시를 내리는 경우는 거의 없을 것이다. 

- 컴퓨터는 어떤 일이든 세세하게 지시해주지 않으면 아무것도 하지 못한다.

이점을 역으로 이용해서 개발된 프로그래밍 언어가 어셈블리이다!!

어셈블리어는 복잡한 기계어 명령을 사람이 이해할 수 있는 기호나 단어로 바꿔 만든 것이다.

*물론 컴퓨터는 "앞으로 가"라는 명령어를 전혀 이해하지 못한다. 컴퓨터는 0과 1만 알아듣기 때문이다!*

- 프로그래머가 어셈블리어로 프로그램 코드를 작성한 후에는 컴파일러라는 소프트웨어를 이용하여 실행 파일을 만들어 냈는데, 이 실행 파일이 바로 프로그램이었다.

**어셈플리어처럼 프로그램을 작성하기 위해 만들어진 인공 언어체계를 '프로그래밍 언어'라고 한다**

- 컴파일러는 소스코드를 컴파일하여 실행파일로 만들기 때문에 프로그램을 실행하기 위해서는 '실행파일'만 있으면 되며, 소스코드는 전혀 필요하지 않다.

- 인터프리터는 소스코드를 미리 실행파일로 만드는 작업이 필요하지 않다. 소스코드를 실시간으로 기계어로 해석해서 실행해주기 때문이다.

## 데이터 다루기: 수와 텍스트와 비트

### 변수 

변수는 데이터를 담는 메모리 공간이다!

여기에는 수를 담을 수도 있고, 글을 담을 수도 있다. 목록이나 이미지 데이터도 담을 수 있다.

```
>>> a = 2020
>>> a
2020
```

'a = 2020'은 "a라는 이름의 변수를 만들고 2020을 해당변수에 입력하라"라는 의미의 코드이다.

**변수 = 데이터를 담는 공간**

### 수 다루기

#### 정수

정수는 음의 정수, 0, 양의 정수를 모두 통틀어 일컫는 말이다!

- 파이썬에서는 메모리가 허용하는한, 무한대의 정수를 다룰 수 있다.

파이썬은 코드가 실행될 때 변수의 형식을 결정한다.

파이썬 인터프리터는 f = -3을 실행할 때가 되어서야 f가 정수라고 판단한다!

```
>>> f = -3
>>> type(f)
<<class 'int'>>
```

#### 여러 가지 진법으로 수 출력하기

파이썬에서 16진수와 2진수로 표현하는 방법!

- 숫자를 16진수로 출력하려면 hex() 함수를 사용해야 한다.

- 숫자를 2진수로 출력하려면 bin() 함수를 사용해야 한다.

#### 실수 

파이썬은 실수를 지원하기 위해 부동 소수형을 제공한다.

부동소수형은 컴퓨터로 소수의 소수점을 표현하는 방식 중 하나이다.

- 부동 소수형은 8바이트만을 이용해서 수를 표현한다. 즉, 한정된 범위의 수만 표현할 수 있다.

- 디지털 방식으로 소수를 표현해야 하므로 정밀도에 한계가 있다.

다음과 같이 변수에 소수점이 있느 수를 대입하면 부동 소수형 변수가 만들어진다!!

```
>>> a = 3.14
>>> a
3.14
```

type() 함수를 사용해서 자료형을 확인하기!

```
>>> type(a) # a는 3.14
<<class 'float'>>
```

- 'float'은 부동소수점을 나타낸다

#### 부동 소수형의 8바이트

부동 소수형은 8바이트만을 이용해서 실수를 표현한다. 비록 8바이트만 가지고 수를 표현하지만, 굉장히 넓은 범위의 수를 다룬다.

- 파이썬의 부동 소수형은 **IEEE754**라는 표준을 따른다.

ex) 7.25를 정규화하여 가수 비트에 담는다면?

7은 2진수로 111, 0.25는 0.01이니 합치면 111.01이 된다. 이를 정규화하면 1.1101이 된다. 시작되는 1은 제거하고 담는다.

- 이러한 일련의 과정들을 **'정규화'**라고 한다.

한편, 8바이트(64비트) 부동 소수형의 경우 지수는 -1024부터 +1023까지의 값을 가질 수 있는데, 2의 보수로 이 값을 표현하면 비교 연산이 복잡해지기 때문에, 성능은 저하된다. 따라서 지수에는 실제 값에 1023을 더해 저장하는 **바이어싱(biasing)**을 사용한다.

- 결국 지수부에 담기는 비트에는 0보다 큰 양수만 담긴다.

#### math 모듈을 이용한 계산

파이썬 코드를 담고 있는 .py 확장자를 가진 파일을 '모듈(module)'이라고 한다. 파이썬은 인터프리터와 함께 매우 다양한 모듈을 제공한다.

- 모듈을 사용하려면 import구문을 이용한다

```
>>> import math 
```

#### π와 e

원주율 π와 자연상수 e는 수학에서 사용되는 주요 상수이다

```
>>> math.pi # 원주율 π
3.141592 ... 
>>> math.e # 자연상수 e
2.718818 ...
```

#### 절대값, 버림과 반올림

| **함수**  | **설명**  | **비고**  |
|---|---|---|
| abs()  | 절대값 계산 함수  | 내장 함수  |
| round()  | 반올림 계산 함수  | 내장 함수  |
| trunc()  | 버림 계산 함수  | math 모듈  |

- 내장 함수(Built-in function)은 파이썬이 인터프리터에 함께 탑재해 놓은 함수로써 별도의 import 구문을 통하지 않고도 사용할 수 있는 함수이다.

*abs() 함수의 사용 예 :*

```
>>> abs(10)
10
>>> abs(-10)
10
```

*round() 함수의 사용 예 :*

```
>>> round(1.4)
1
>>> round(1.5)
2
```

**trunc() 함수는 1.4, 1.5, 1.9를 모두 1로 만든다. trunc() 함수는 앞의 두 함수와는 달리 내장 함수가 아니기 때문에 사용할 때 'math.'를 붙여야 한다.**

*trunc() 함수의 사용 예 :*

```
>>> import math
>>> math.trunc(1.4)
1
>>> math.trunc(1.5)
1
>>> math.trunc(1.9)
1
```

#### 팩토리얼

팩토리얼은 1부터 어떤 양의 정수 n까지의 정수를 모두 곱한 것을 말한다. 예를 들어 5팩토리얼을 수식을 나타내면 다음과 같다.

```
5! = 5x4x3x2x1
```

- math 모듈에서 제공하는 팩토리얼 함수의 이름은 factorial()이다.

| **함수**  | **설명**  |
|---|---|
| factorial()  | 팩토리얼 계산 함수  |

#### 도와 라디안

도(degree)는 원을 360도로 표현한 것이고, 라디안(radian)은 반지름의 1인 원에서 호의 길이가 1인 부채꼴의 각을 기본단위로 삼아 2π로 표현한 것이다. 즉 360도 = 2π 인 것이다!

#### 삼각 함수

math 모듈에서 제공하는 삼각함수 목록

| **함수**  | **설명**  |
|---|---|
| cos()  | 입력된 라디안에 대한 코사인 값을 계산  |
| sin()  | 입력된 라디안에 대한 사인 값을 계산  |
| tan()  | 입력된 라디안에 대한 탄젠트 값을 계산  |
| acos()  | cos()의 역함수  |
| asin()  | sin()의 역함수  |
| atan()  | tan()의 역함수  |

#### 제곱과 제곱근

파이썬으로 제곱을 계산한다면 다음과 같이 가능하다

```
>>> 3*3
9
>>> 3*3*3
27
```

### 텍스트 다루기 

컴퓨터는 수를 계산하기 위해 만들어진 기계이다.

이 수 기게를 이용해서 컴퓨터 과학자들이 글을 다루는 방법을 고안해 냈는데, 각 문자마다 번호를 붙이고 메모리에 저장하거나 계산을 할 때에는 수로 처리하고 모니터나 프린터에 출력할 때는 사람이 아는 문자로 출력하는 방식이다.

파이썬에서는 텍스트를 다루는 자료형으로 String을 제공한다. String은 영어로 끈, 줄 등의 뜻을 가지고 있으므로 문자를 끈으로 가지런히 묶어놓는 것으로 이해하면 된다.

### 문자열 메소드

순서열로부터 물려받은 기능외에도, 문자열은 다양한 기능의 함수를 자체적을 탑재하고 있다.

내장 함수들과는 달리 이런 함수는 문자열 자료형 안에 들어 있다. 이렇게 특정 자료형이 갖고 있는 함수를 메소드(Method)라고 한다.

### 수에서 텍스트로, 텍스트에서 수로

```
print("첫 번째 수를 입력하세요. : ")
a = input()
print("두 번째 수를 입력하세요. : ")
b = input()

result = int(a) * int(b)

print("{0} * {1} = {2}".format(a, b, result))
```

- 실행 결과

```
>input_multiply.py
첫 번째 수를 입력하세요 :
5
두 번째 수를 입력하세요 :
4
5 * 4 = 20
```

**파이썬은 숫자 형식의 생성자 안에 문자열을 해당 형식으로 변환하는 기능을 탑재했다.**

### 비트 다루기

컴퓨터는 원래 0과 1의 비트 데이터만을 다루는 기계이다. 하지만 파이썬에서 다루는 데이터의 기본 단위는 '바이트(Byte)'이다. 1바이트는 비트를 무려 8개나 담을 수 있는 크기다.

비트 수준에서 데이터를 가공해야 하는 경우도 종종 생기는데 비트 연산자는 바로 이를 위한 연산자이다!

#### 시프트 연산자

시프트 연산자(Shift Operator)는 비트를 왼쪽이나 오른쪽으로 이동시키는 기능을 한다.

### 비트 논리 연산자

논리 연산은 참 또는 거짓의 진리 값을 피연산자로 하는 연산이다. 비트 논리 연산(Bitwise Logical Operation)은 데이터의 각 비트에 대해 수행하는 논리 연산이다. 파이썬에서 제공하는 비트 논리 연산자는 네 가지가 있다.

| **연산자**  | **이름**  |
|---|---|
| ```&```  | 논리곱(AND)연산자  |
| ```|```  | 논리합(OR)연산자  |
| ```^```  | 배타적 논리합(XOR)연산자  |
| ```~```  | 보수(NOT)연산자  |

- 비트 논리 연산자는 bool 형식 외에도 정수 계열 형식의 피연산자에 대해서도 사용 할 수 있다.

## 데이터 다루기: 리스트와 튜플과 딕셔너리

### 리스트 

리스트(List)는 이름에서도 알 수 있듯이 데이터의 목록을 다루는 자료형이다.

단일 데이터가 명함이라면, 리스트는 명함을 모아두는 명함집이라고 할 수 있다.

명함집에 명함을 꽂아 넣을 수 있는 슬롯(Slot)이 있는 것처럼, 리스트들도 슬롯이 있다.

리스트의 각 슬롯에 꽂혀있는 개별 데이터를 일컫어 요소(Element)라고 한다.

### 리스트 메소드

| **메소드**  | **설명**  |
|---|---|
| append()  | 리스트의 끝에 새 요소를 추가한다.  |
| extend()  | 기존 리스트에 다른 리스트를 이어 붙입니다. + 연산자와 같은 기능을 한다고 할 수 있다.  |
| insert()  | 첨자로 명시한 리스트 내의 위치에 새 요소를 삽입한다.   |
| remote()  | 매개변수로 입력한 데이터를 리스트에서 찾아 발견한 첫 번째 요소를 제거한다.  |
| pop()  | 리스트의 마지막 요소를 뽑아내어 리스트에서 제거한다.  |
| index()  | 리스트 내에서 매개변수로 입력한 데이터와 일치하는 첫 번째 요소의 첨자를 알려준다.  |
| count()  | 매개변수로 입력한 데이터와 일치하는 요소가 몇 개 있는지 센다.  |
| sort()  | 리스트 내의 요소를 정렬한다.  |
| reverse()  | 리스트 내 요소의 순서를 반대로 뒤집는다.  |

#### 튜플 

리스트는 sort()메소드를 이용해 요소의 순서를 정렬하지만 튜플은 변경이 불가능하므로 아예 해당 메소드가 제공되지 않는다. 새로운 요소를 추가하거나 삽입할 수 있고, 기존 요소를 삭제할 수도 있지만 튜플은 이러한 작업을 허용하지 않는다.

**튜플 = 변경이 불가능한 자료형!**

- 튜플도 리스트와 문자열처럼 순서열 자료형이기 때문에 대괄호를 이용한 참조 연산과 슬라이싱, 튜플간 결합 등의 연산이 가능하다!

*ex) 슬라이싱 예:*

```
>>> a = (1, 2, 3, 4, 5, 6)
>>> a[:3]
(1, 2, 3)
>>> a[4:6]
(5, 6)
```

*ex) + 연산자 튜플 결합의 예:*

```
>>> a = (1, 2, 3)
>>> b = (4, 5, 6)
>>> c = a + b
>>> a 
(1, 2, 3)
>>> b
(4, 5, 6)
>>> c
(1, 2, 3, 4, 5, 6)
```

#### 패킹과 언패킹!

다음과 같이 여러가지 데이터를 튜플로 묶는 것을 튜플 패킹(Tuple Packing)이라고 한다!

```
>>> a = 1, 2, 3
>>> a
(1, 2, 3)
```

그리고 다음과 같이 튜플의 각 요소를 여러 개의 변수에 할당하는 것을 튜플 언패킹(Tuple Unpacking)이라고 한다!

```
>>> one, two, three = a
>>> one 
1
>>> two
2
>>> three
3
```

- 튜플의 언패킹을 활용하면 여러 개의 변수에 한번에 할당을 수행할 수 있다!

#### 튜플 메소드

튜플은 변형이 불가능한 자료형이라서 제공하는 메소드가 index()와 count() 두개뿐이다!!!

| **메소드**  | **설명**  |
|---|---|
| index()  | 매개변수로 입력한 데이터와 일치하는 튜플 내 요소의 첨자를 알려준다!  |
| count()  | 매개변수로 입력한 데이터와 일치하는 요소가 몇 개 있는지 센다!  |


#### 딕셔너리

딕셔너리(Dictionary)는 사용법 측면에서 보면 리스트와 비슷하다고 볼 수 있다!

- 리스트처럼 첨자를 이용해서 요소에 접근하고, 또 그 요소를 변경 할 수도 있다!

딕셔너리의 첨자는 키(Key)라고 하고, 이 키가 가리키는 슬롯에 저장되는 데이터를 값(Value)라고 한다!

딕셔너리는 키-값의 쌍으로 구성된다.

- 딕셔너리는 키를 이용해서 단번에 데이터가 저장된 위치의 주소를 계산해내는데 이런 작업을 해싱(Hashing)이라고 한다!


## 프로그램 흐름 제어하기!

### 흐름 제어를 시작하기 전에

#### bool 자료형

bool은 True와 False 두 가지 값을 나타내는 자료형이다!

```
>>> a = 3 > 2
>>> a
True
>>> a = 2 > 3
>>> a
False
>>> type(a)
<<class 'bool'>>
```

#### 논리 연산자

not, and, or는 참과 거짓을 다루는 논리 연산자이다!

#### 흐름 제어문과 조건문

흐름 제어문은 흐름을 분기하거나 반복하기 전에 조건문의 결과가 참인지를 평가한다!

- bool 형식을 비롯해서 숫자, 문자열, 딕셔너리 등 다양한 객체가 사용된다

```
- False
- None
- 숫자 0 예) 0, 0.0등
- 비어있는 순서열: 예)",(),[]등
- 비어있는 딕셔너리: 예) {}
```

#### 코드블록과 들여쓰기

코드블록(Code Block)은 여러 코드가 이루는 일정한 구역을 말하는데, 프로그래밍 언어마다 이것을 표현하는 방법은 각기 다르다!

#### 비교 연산자

| **연산자**  | **설명**  |
|---|---|
| ==  | 양쪽에 위치한 피연산자가 서로 같으면 True, 그렇지 않으면 False이다!  |
| !=  | 양쪽에 위치한 피연산자가 서로 다르면 True, 그렇지 않으면 False이다!  |
| >  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 크면 True, 그렇지 않으면 False이다!  |
| >=  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 크거나 같으면 True, 그렇지 않으면 False이다!  |
| <  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 작으면 True, 그렇지 않으면 False이다!  |
| <=  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 작거나 같으면 True, 그렇지 않으면 False이다!  |

### 분기문

프로그램의 흐름을 가르는 문장을 일컬어 나눌 분, 갈림길 기, 분기문이라고 한다!

#### if문 

if는 어떤 상황을 가정할 때 사용하는 말이다!

- '만약 ~라면'의 뜻을 갖고 있다. '만약 입력받은 수 a가 0이라면'처럼 

if문은 참아니면 거짓으로 평가될 수 있어야한다.

```
>>> if 조건: # if 뒤에 흐름을 가를 조건이 위치하고, 그 뒤에 콜론(:)이 온다
>>> 	명령1	# :뒤에는 들여쓰기로 이루어진 코드블록이 온다. 이 코드블록은 if문의 조건이 True일 경우 실행된다!
>>> 	명령2
>>> else: # if문의 조건을 충족하지 않을 때, 즉 조건 평가의 결과가 False일 때의 흐름은 else로 향한다!. else뒤에도 코드블록이 오므로 콜론(:)이 위치해야 한다.
>>> 	명령1	
>>> 	명령2
```

*ex) if else의 예제: 

```
import sys

print('수를 입력하세요 : ')
a = int(input())

if a == 0 :
    print('0은 나눗셈에 이용할 수 없습니다.')
    sys.exit(0)

print('3 /', a, '=', 3/a)
```

- 파이썬 프로그램을 종료하는 exit() 함수를 사용하기 위해 sys패키지를 임포트한다

- a가 0인 경우에 경고 메세지를 출력한 뒤 프로그램을 종요시킨다. 

*ex) elif는 else if를 줄여 만든 파이썬 키워드 이다.*

```
print('요일(월~일)을 입력하세요 : ')
dow = input()

if dow == '월' : # 첫번째 조건은 항상 if로 시작
    print('Monday')
elif dow == '화' : # 두번째 조건부터는 elif를 이용!
    print('Tuesday')
elif dow == '수' :
    print('Wednesday')
elif dow == '목' :
    print('Thursday')
elif dow == '금' :
    print('Friday')
elif dow == '토' :
    print('Saturday')
elif dow == '일' :
    print('Sunday')
else : # 마지막의 else는 생략가능!
    print('잘못 입력된 요일입니다.')
```

### 반복문

*루프문(Loop Statement)이라고도 한다.*

#### while문

while문은 코드의 흐름을 반복시킬 수 있는 파이썬의 코드이다.

*ex) while*

```
>>> while 조건:
>>> 	코드블록 
```

- while키워드가 먼저 위치하고 그 다음에 조건이 오게 된다.

조건뒤에는 코드블록을 위치시켜서 전에 콜론(:)이 있어야 한다.

while이 영어로 '~하는동안'이라는 뜻이므로 while코드를 읽을 때에는 '조건이 참인 동안'이라고 해석하면 된다!

```
print('몇 번 반복할까요? : ')
limit = int(input())

count = 0
while count < limit :
    count = count + 1
    print('{0}회 반복.'.format(count))    
    
print('반복이 종료되었습니다.')
```

#### for 문

for문은 조건을 평가하는 것이 아니라 순서열을 순회하다가 순서열의 끝에 도달했는지를 본다

*ex) for*

```
>>> for 반복변수 in 순서열:
>>> 	코드블록
```

- for문에서 사용하는 순서열은 리스트, 튜플, 심지어 문자열 등 어떤 것을 사용해도 괜찮다!

for문은 순서열의 각 원소를 처음부터 차례로 순회하면서 반복변수에 담아낸다.

```
for s in '뇌를 자극하는 파이썬' :
    print(s)
```

*ex) 중첩 for문*

```
for i in range(1, 6) :
        for j in range(i) : # 바깥의 for문에서 입력한 반복변수 i가 멈춤값이다!
            print( "*", end = "", ) # end=""을 매개변수로 입력하면 줄바꿈을 출력하지 않는다!
        
        print() # 아무것도 입력하지 않으면 줄바꿈만 출력
```

#### continue와 break로 반복문 제어하기

파이썬에서 continue문은 반복문이 실행하는 코드블록의 나머지 부분을 실행하지 않고 다음 반복으로 건너가도록 흐름을 조정한다.

```
for i in range(10) :
    if i % 2 == 1 :
        continue # i가 홀수일 때 코드블록의 나머지 부분을 실행하지 않고 다음 반복으로 바로 건너간다.
        
    print(i) # continue가 실행되는 경우에는 이 코드는 실행되지 않는다.        
```

## 함수로 코드 간추리기

### 이 단원을 시작하기에 앞서 알아둬야하는 용어!!

#### 정의

정의(Definition)는 어떤 이름을 가진코드가 구체적으로 어떻게 동작하는지를 '구체적으로 기술'하는것을 말한다.

#### 호출과 반환

모든 함수는 이름을 갖고 있다.

이 이름을 불러주면 파이썬은 그 이름 아래 정의되어 있는 코드를 실행한다.

- 함수가 자신의 코드를 실행하면 결과가 나오는데, 그 결과를 자신의 이름을 부른 코드에게 돌려준다.

- 이때 함수를 부르는 행위를 호출(Call)이라고 하고, 함수를 부르는 코드를 호출자(Caller)라고 한다.

- 함수가 호출자에게 결과를 돌려주는 것을 반환(Return)이라고 한다.

### 함수 정의하기

*ex) 함수를 정의하는 문법*

```
>>> def 함수이름( 매개변수 목록 ):
>>> 	# 코드블록
>>> 	return 결과
```

#### 매개변수를 입력받는 여러가지 방법

매개변수는 호출자와 함수 사이의 관계를 맺어주는 변수를 뜻한다.

매개변수에 어떤 값이 들어있느냐에 따라서 함수의 동작이 달라진다

```
def my_abs( arg ): # arg: 매개변수
	if ( arg < 0 ):
		result = arg * -1
	else:
		result = arg
		
	return result
```

#### 기본값 매개변수와 키워드 매개변수

*ex) 기본값 매개변수*

```
>>> def print_string(text, count=1): # 매개변수를 정의 할 때 값을 할당해 놓으면 기본값 매개변수가 된다!
	 	for i in range(count):
	 		print(text)	
	 		
>>> print_string('안녕하세요') # 호출할 때 두 번째 매개변수를 생략하면 기본값 1이 사용된다!
안녕하세요
>>> print_string('안녕하세요', 2)
안녕하세요
안녕하세요
```

*ex) 키워드 매개변수*

```
>>> def print_personel(name, position='staff', nationality='Korea'):
	 	print('name = {0}'.format(name))
	 	print('position = {0}'.format(position))
	 	print('nationality = {0}'.format(nationality))
	 	
>>> print_personnel(name='윤경한') # position과 nationality는 기본값이 사용된다
name = 윤경한
position = staff
nationality = Korea 	

>>> print_personnel(name='윤경한', nationality='ROK') # position만이 기본값을 사용!
name = 윤경한
position = staff
nationality = ROK

>>> print_personnel(name='윤경한', position='인턴') # nationality만이 기본값을 사용!
name = 윤경한
position = 인턴
nationality = Korea
```

#### 가변 매개변수

상황에 따라 매개변수의 수가 달라지는 함수는 매개변수(Arbitrary Argument List)를 이용하면 된다!

```
>>> def 함수이름(*매개변수): # 매개변수 앞에 *를 붙이면 해당 매개변수는 가변으로 지정된다!
	 	코드블록
```

**```*```를 이용하여 정의된 가변 매개변수는 튜플이다!**

#### 호출자에게 반환하기!

함수가 호출자에게 값을 반환할 때에는 return문이 이용된다. return문은 대체로 다음 3가지 방법으로 사용된다!

1. return문에 결과 데이터를 담아 실행하기 => 함수가 즉시 종료되고 호출자에게 결과가 전달

2. return문에 아무 결과도 넣지 않고 실행하기 => 함수가 즉시 종료!

3. return문 생략하기 => 함수의 모든 코드가 실행되면 종료!

*ex) return문에 결과 데이터를 담아 실행하기*

```
>>> def multiply(a, b):
	 	return a+b # return문은 함수의 실행을 종료시키고 자신에게 넘겨진 데이터를 호출자에게 전달한다!
	 	
>>> result = multiply(2, 3)
>>> resutl
6
``` 	

- 한 함수 안에 return문을 여러 개 두는 것이 문법적인 문제를 일으키는 것은 아니지만, 가급적이면 return문은 함수 코드블록의 마지막에 하나만 실행하도록 하는 것이 좋다!

*ex) return문에 아무 결과도 넣지 않고 실행하기*

```
>>> def ogamdo(num):
	 	for i in range(1, num+1):
	 		print('제 {0}의 이해'.format(i))
	 		if i == 5:
	 			return # 반환할 데이터 없이 실행하는 return문은 '반환'의 의미보다는 '함수종료'의 의미로 사용된다!
```

```
>>> ogamdo(3)
제 1의 이해
제 2의 이해
제 3의 이해
>>> ogamdo(5)
제 1의 이해
제 2의 이해
제 3의 이해
제 4의 이해
제 5의 이해
>>> ogamdo(8) # 8을 입력하면 for반복문은 8번 반복을 수행하려고 준비하겠지만 실행되는 return문 때문에 다섯 번 수행하면 함수가 종료되고 만다!
제 1의 이해
제 2의 이해
```

#### 함수 밖의 변수, 함수 안의 변수

```
>>> def scope_test():
 	 	a = 1 # 함수를 정의하는 시점에서는 a가 메모리에 생성되지 않았다. 함수를 호출하면 그제서야 함수의 코드가 실행되면서 a가 메모리에 생성된다!
 	 	print('a:{0}'.format(a))
 	 	
>>> a = 0 # 함수 밖에서 a를 정의하고 0으로 초기화한다!
>>> scope_test() # scope_test()가 호출되면 함수 내부에서 a를 정의하고 1로 초기화한다!
a:1
>>> print('a:{0}'.format(a)) # 하지만 함수 밖에서 정의한 a를 출력해보면 여전히 0을 갖고 있음을 확인할 수 있다!
a:0
```

```
>>> def scope_test():
 	 	global a # global 키워드는 지정한 변수의 유효 범위가 전역임을 알리고, 지역 변수의 생성을 막는다. 이 a는 scope_test() 함수 안에서 전역 변수로 사용된다!
 	 	a = 1 
 	 	print('a:{0}'.format(a))
 	 	
>>> a = 0
>>> scope_test() # scope_test()는 0으로 초기화된 a에 접근해 1로 값을 변경한다!
a:1
>>> print('a:{0}'.format(a)) # a를 출력해보면 scope_test() 함수 안에서 변경한 값 1이 들어있음을 확인 할 수 있다!
a:1 	
```

### 자기 스스로를 호출하는 함수: 재귀 함수

재귀 함수(Recursive Function)는 자기 스스로를 호출하는 함수를 말한다! 함수가 자기 자신을 부르는 것을 재귀 호출(Recursive Call)이라고 한다!

- 함수 자신이 호출자이자 피호출자가 되는것이다

```
>>> def some_func(count):
 	 	if count > 0:
 	 		some_func(count-1)
 		print(count)
```

- 재귀 함수는 편리하지만 호출 비용이 크다!

컴퓨터가 더 많은 일을 하게 만들어서 성능이 떨어지는 소프트웨어를 만들게 된다. 좋은 성능이 요구되는 코드에서는 재귀 함수를 반복문으로 대체해서 사용하는 것이 좋다.

### 함수를 변수에 담아 사용하기

파이썬에서는 함수를 변수에 담아 사용할 수 있다!

```
>>> def print_something(a):
  	 	print(a)
  	 	
>>> p = print_something # ()없이 함수의 이름만을 변수에 저장한다!
>>> p(123) # 변수의 이름 뒤에 ()를 붙여 함수처럼 호출한다!
123
>>> p('abc')
abc
```

### 함수안의 함수: 중첩 함수

함수 안에 정의된 함수를 중첩함수(Nested Fuction)라고 한다. 이 중첩 함수는 자신이 소속된 함수의 매개변수에 접근 할 수 있다.

```
>>> import math
>>> def stddev(*args):
  	 	def mean():	# 중첩 함수 ...
  	 		return sum(args)/len(args) # ... 중첩 함수
  	 		
  	 	def variance(m): # 중첩 함수 ...
  	 		total = 0 
  	 		for arg in args:
  	 			total += (arg - m ) ** 2
 			return total/len(args)-1) # ... 중첩 함수 			
	v = variance(mean())
	return math.sqrt(v)
	
>>> stddev(2.3, 1.7, 1.4, 0.7, 1.9)
0.6	
```

- mean()과 variance()는 중첩 함수의 특징을 활용하여, stddev()의 매개변수인 args에 접근해서 평균과 분산을 각각 계산한다!

## 모듈과 패키지

모듈(Module)은 대체적으로 '독자적인 기능을 갖는 구성 요소'를 의미한다!

- 파이썬에서는 각각의 소스파일을 일걸어 '모듈'이라고 한다.

### 두 개의 소스 파일로 만드는 하나의 프로그램 예제

*ex) calculator.py*

```
def plus(a, b):
    return a+b

def minus(a, b):
    return a-b

def multiply(a, b):
    return a*b;

def divide(a, b):
    return a/b
```

*ex) calc_tester.py*

```
import calculator # 불러올 모듈의 이름 calculator.py에서 '.py'는 생략한다.

print(calculator.plus(10, 5))
print(calculator.minus(10, 5)) # 모듈이름.함수()의 꼴로 clculator모듈의 함수를 호출한다.
print(calculator.multiply(10, 5))
print(calculator.divide(10, 5))
```

*ex) 실행 결과*

```
> calc_tester.py
15
5
50
2.0
```

함수들은 모두 calculator.py 모듈에 정의되어 있다. calc_tester.py 모듈에서 import문을 이용해 calculator.py 모듈을 불러들였기 때문에 이들 함수를 사용할 수 있었다. 

- 모듈을 분리함으로써 코드를 재사용할 수 있는 장점이 있다.

#### import에 대해

import를 사용하는 방법의 2가지

1.

```
import 모듈 # 모듈의 실제 파일 명은 "모듈.py"
```

2.

```
from 모듈 import 변수 또는 함수
```

#### 모듈을 찾아서

import문을 만나면 파이썬은 다음과 같은 순서로 모듈 파일을 찾아 나선다!

1. 파이썬 인터프리터 내장 모듈

2. sys.path에 정의되어 있는 디렉토리

sys.path에 정의되어 있는 디렉토리는 크게 3가지로 나눌 수 있다.

1. 파이썬 모듈이 실행되고 있는 현재 디렉토리

2. PYTHONPATH 환경변수에 정의되어 있는 디렉토리

3. 파이썬과 함께 설치된 기본 라이브러리

#### 메인 모듈과 하위 모듈

*"도대체 메인(main) 함수는 어디에 있는 거지?"*

- 파이썬에서는 이른바'최상위 수준(Top Level)'에서 실행되는 스크립트가 있을 뿐, 메인 함수가 따로 없다. 최상위 수준 실행은 별 다른게 아니라 명령 프롬프트 창이나 탐색기를 이용하여 파이썬 모듈을 실행하는 것이다.

**파이썬에서는 "어떻게 만드느냐"가 아닌 "어떻게 실행하느냐"에 따라 메인 모듈이 결정된다.**

### 패키지

파이썬에서는 모듈을 모아놓는 디렉토리를 패키지(Package)라고 한다. 영어로 패키지는 '꾸러미'라는 뜻을 가지고 있으니 파이썬에서는 '모듈 꾸러미' 정도로 생각하면 된다.

```
from my_package import calculator # 'from 패키지 import 모듈'의 골로 모듈을 불러온다! 

print(calculator.plus(10, 5))
print(calculator.minus(10, 5))
print(calculator.multiply(10, 5))
print(calculator.divide(10, 5))
```

#### ```__init__.py```의 이해

패키지란, '```__init__.py```파일을 갖고 있는 디렉토리'임을 뜻한다.

- ```__init__.py```파일은 대개 비워두는 것이 보통이다. 이 파일을 손대는 경우는 ```__all__```이라는 변수를 조정할때 정도이다. 

- ```__all__```은 패키지로부터 반입할 모듈의 목록을 정의하기 위해서 사용한다.

#### ```site-packages```에 대해

site-packags는 파이썬의 기본 라이브러리 패키지 외에 추가적인 패키지를 설치하는 디렉토리이다.

만든 패키지나 모듈을 site-packages 디렉토리에 위치시키면 어느 경로에서든 접근해 반입할 수 있다.

## 클래스

### 객체 지향 프로그래밍

#### 객체와 클래스

객체 지향 프로그래밍에서의 객체는 다음과 같이 정의된다.

**객체(Object) = 속성(Attribute) + 기능(Method)**

속성은 사물의 특징을 말한다. 

자동차로 예를 들면, 몸체의 색, 바퀴의 크기, 엔진의 배기량 등이 자동차의 속성이라 할 수 있다. 기능은 어떤 것의 특징적인 동작을 말한다.

다시 자동차로 예를 들면, 전진, 후진, 좌회전, 우회전등이 자동차의 기능이라고 할 수 있다!

- 속성을 '변수', 기능을 '함수'로 바꿔 '객체 = 변수 + 함수'라고 할 수 있다.

```
class Car: # Car 클래스의 정의 시작을 알린다
	def __init__(self):
		self.color = 0xFF0000 # Car 클래스 안에 차의 색, 바퀴 크기, 배기량을 나타내는 변수를 정의한다.
		self.wheel_size = 16
		self.displacement = 2000
		
	def forward(self): # 전진
		pass
		
	def backward(self): # 후진
		pass
		
	def turn_left(self): # 좌회전
		pass
		
	def turn_right(self): # 우회전 # Car 클래스 안에 전진, 후진, 좌회전, 우회전 함수를 정의
		pass
```

- 클래스는 자료형이고, 객체는 변수이다!

- 객체 대신에 인스턴스(Instance)라는 용어를 사용하기도 한다. 인스턴스는 실체, 사례라는 뜻으로 클래스가 설계도라면, 객체는 그 설계를 바탕으로 실체화 한 것이라는 뜻에서 유래한다.

#### 객체 지향 프로그래밍을 해야하는 이유!

한번 만들어서 세상에 내놓으면 고칠 일이 별로 없는 하드웨어와는 달리 소프트웨어는 세상에 내놓는 순간부터 챙겨줘야 할 것이 매우 많아진다. 이때 소프트웨어의 결합도가 높으면 코드를 고칠 때마다 부작용이 발생할 가능성이 높아진다. 결합도가 낮은 소프트웨어는 어느 한 부분을 수정하더라도 부작용에 대한 걱정을 줄일 수 있다. 

같은 목적과 기능을 위해 객체로 묶인 코드 요소(변수, 함수)들은 객체 내부에서만 강한 응집력을 발휘하고 객체 외부에 주는 영향은 줄이게 된다.

- 코드가 객체 위주로 이루어질 수 있도록 지향하는 프로그래머의 노력은 코드의 결합도를 낮추는 결과는 낳게 된다. 객체 지향 프로그래밍의 장점은 여기에 있다.

#### 클래스의 정의

클래스는 class 키워드를 이용하여 정의한다.

```
class 클래스이름:
	코드블록
```

- 파이썬에서는 콜론으로 끝나는 문장의 다음 줄에는 코드 블록이 위치할 것을 요구하는데, 클래스의 코드블록은 변수와 메소드(Method)로 이루어진다. 여기서 메소드는 클래스에 속해있는 함수를 말한다.

클래스 안에 정의되어 있는 변수와 메소드는 클래스의 멤버라고도 한다. 메소드는. 이미 용어 자체로 함수와 달리 클래스에 소속되어 있음을 알 수 있지만 변수의 경우에는 일반 변수와 클래스의 멤버 변수를 구분하기 어려우므로 '데이터 속성(Data Attribute)'이라는 용어가 사용된다.

```
class Car:
    def __init__(self):
        self.color = 0xFF0000    # 바디의 색
        self.wheel_size = 16     # 바퀴의 크기
        self.displacement = 2000 # 엔진 배기량

    def forward(self): # 전진
        pass

    def backward(self): # 후진
        pass

    def turn_left(self): # 좌회전
        pass

    def turn_right(self): # 우회전
        pass

if __name__ == '__main__':        
    my_car = Car() # 앞에서 정의한 Car클래스의 객체 my_car를 생성한다.

    print('0x{:02X}'.format(my_car.color)) # my_car의 정보를 출력
    print(my_car.wheel_size)
    print(my_car.displacement)

    my_car.forward() # my_car의 메소드를 호출
    my_car.backward()
    my_car.turn_left()
    my_car.turn_right()
```

*ex) 실행 결과*

```
> Car.py
0xFF0000
16
2000
```

#### ```__init__()``` 메소드를 이용한 초기화

클래스의 생성자가 호출되면 내부적으로 또 다른 두 개의 메소드가 호출된다. 하나는 ```__new__()```이고 또 다른 하나는 우리가 알고 있는 ```__init__()```이다. 이들은 마법(Magic)메소드 또는 특별(Special)메소드라고 불리운다.

**데이터 속성을 ```__init__()```메소드가 아닌 클래스에 직접 정의한다면 어떤 일이 일어날까?**

```
class ClassVar: # text_list는 ClassVar클래스의 정의 시점에 함께 메모리에 할당된다.
	text_list = []
	
obj = ClassVar() # obj객체가 생성되기 전부터 text_list는 메모리에 적재되어 있다.
```

*ex) 왜 ```__init__()```메소드를 사용해야하는가?*
 
```
class ClassVar:
    text_list = []

    def add(self, text):
        self.text_list.append(text)
    
    def print_list(self):
        print(self.text_list)

if __name__ == '__main__':        
    a = ClassVar()
    a.add('a')
    a.print_list() # ['a'] 출력을 기대
    
    b = ClassVar()
    b.add('b')
    b.print_list() # ['b'] 출력을 기대
```

*ex) 실행 결과*

```
> ClassVar.py
['a'] # 객체 a를 통해 'a'를 입력하고 a의 text_list 내용을 출력.
['a','b']	# 객체 b를 통해 'b'를 입력하고 b의 text_list 내용을 출력했다. 하지만 객체 'b'에서는 입력하지 않은 'a'가 들어 있다. 이것은 클래스 속성으로 정의된 text_list변수를 ClassVar의 모든 인스턴스가 공유하게 되어 생긴 문제이다!
```

- 인스턴스가 생성될 때에만 ```__init__()```메소드가 실행되므로 이 메소드 안에 변수 정의/초기화 코드를 넣어 놓으면 모든 인스턴스가 변수를 공유하게 되는 불상사는 피할 수 있다.

```
class InstanceVar:
    def __init__(self):
        self.text_list = []

    def add(self, text):
        self.text_list.append(text)
    
    def print_list(self):
        print(self.text_list)

if __name__ == '__main__':        
    a = InstanceVar()
    a.add('a')
    a.print_list() # ['a'] 출력을 기대
    
    b = InstanceVar()
    b.add('b')
    b.print_list() # ['b'] 출력을 기대
```

*ex) 실행 결과*

```
> InstanceVar.py
['a']
['b'] # __init__()메소드 안에서 정의한 text_list는 각 객체마다 고유한 인스턴스로 사용하므로 ClassVar.py에서와 같은 부작용이 사라졌다!!!
```

- ```__init__()``` 메소드의 이름은 '초기화하다'는 뜻의 initailize를 줄여서 붙여진 것이다.

#### self에 대해

self는 '자아'또는 '자신'이라는 뜻이다. 파이썬의 메소드에 사용되는 self는 메소드가 소속되어 있는 객체이다. 

```
class ContactInfo:
	def __init__(self, name, email):
		self.name = name
		self.email = email
		
	kyeonghan = ContactInfo('윤경한', 'zizou0812@gmail.com')
```

- ContactInfo 외부에서는 kyeonghan 이라는 이름으로 객체를 다룰 수 있다. 내부에서는 kyeonghan처럼 객체를 지칭할 수 있는 이름이 없다. 그래서 self를 도입한 것이다!

#### 정적 메소드와 클래스 메소드

**인스턴스 메소드는 인스턴스(객체)에 속한 메소드를 말한다**

인스턴스 메소드가 "인스턴스에 속한다"라는 표현은 "인스턴스를 통해 호출가능하다"라는 뜻이다. 그렇다면 클래스에 속한(클래스를 통해 호출 가능한) 메소드도 있을까? 있다. 정적 메소드(Static Method)와 클래스 메소드(Class Method)가 바로 그런 메소드 이다.

*ex) 정적메소드의 예*

```
class Calculator:
	
	@staticmethod
	def plus(a, b): # 당연히 정적 메소드도 매개변수를 받는다. self는 제외!
		return a+b
```

*ex) 사칙연산 함수를 활용하는 정적메소드 예제*

```
class Calculator:

    @staticmethod # 클래스 안에 정의되었지만 self를 매개변수로 받지 않는다.
    def plus(a, b):
        return a+b

    @staticmethod
    def minus(a, b):
        return a-b

    @staticmethod
    def multiply(a, b):
        return a*b

    @staticmethod        
    def divide(a, b):
        return a/b
        
if __name__ == '__main__':        
    print("{0} + {1} = {2}".format(7, 4, Calculator.plus(7, 4))) # 정적 메소드는 인스턴스 대신 클래스 이름을 통해 메소드에 접근한다. "클래스이름.메소드()"의 형태!
    print("{0} - {1} = {2}".format(7, 4, Calculator.minus(7, 4)))
    print("{0} * {1} = {2}".format(7, 4, Calculator.multiply(7, 4)))
    print("{0} / {1} = {2}".format(7, 4, Calculator.divide(7, 4)))
```

*ex) 실행 결과*

```
> Calculator.py
7 + 4 = 11
7 + 4 = 3
7 + 4 = 28
7 + 4 = 1.75
```

- 정적 메소드는 self 매개변수를 전달받을 방법이 없으므로(self 매개변수는 인스턴스 메소드에게만 파이썬이 전달해준다) 객체/인스턴스의 변수에 접근 할 수 없다.

- 따라서, 정적 메소드는 객체의 데이터 속성과는 관계가 없는 코드로 구현되는 것이 일반적이다.

*ex) 클래스 메소드의 예*

```
class 클래스이름:
	# ...  
	
	@classmethod # 클래스 메소드를 정의하기 위해서는 1. @classmethod 데코레이터를 앞에 붙여준다. 
	def 메소드이름(cls): # 2. 메소드의 매개변수를 하나 이상 정의한다.
		pass
```

*ex) cls 매개변수를 통해 클래스 속성에 접근하는 방법 예제*

```
class InstanceCounter:
    count = 0
    def __init__(self): # 인스턴스가 만들어질 때마다 __init__()메소드가 실행된다. 인스턴스의 수를 세기에는 이곳이 적절하다!
        InstanceCounter.count += 1
    
    @classmethod
    def print_instance_count(cls): # print_instance_count() 메소드는 InstanceCounter의 클래스 속성인 count를 출력한다.
        print(cls.count)

if __name__ == '__main__':        
    a = InstanceCounter()
    InstanceCounter.print_instance_count()
    
    b = InstanceCounter()
    InstanceCounter.print_instance_count()
    
    c = InstanceCounter()
    c.print_instance_count()
```

*ex) 실행 결과*

```
> InstanceCounter.py
1
2
3
```

#### 클래스 내부에게만 열려있는 프라이빗 멤버

클래스의 안에서만 접근이 가능한 멤버를 일컬어 '프라이빗(Private)'멤버라고 한다. 반대로 안과 밖 모두에서 접근이 가능한 멤버는 '퍼블릭(Public)'멤버라고 한다. 

파이썬은 다른 프로그래밍 언어들과는 달리 작명법(Naming)으로 둘을 구분한다!

프라이빗 멤버의 명명 규칙은 다음과 같다!

1. 두 개의 밑줄 __이 접두사여야 한다. 예) ```_number```

2. 접미사는 밑줄이 한 개까지만 허용된다. 예) ```_number_```
	
	- 접미사의 밑줄이 두 개 이상이면 퍼블릭 멤버로 간주한다. 예) ```__number__```

#### 상속

클래스끼리 데이터를 물려주는 것을 일컬어 '상속(Inheritance)'이라고 한다.

객체 지향 프로그래밍에서는 물려 받는 클래스(파생 클래스(Derived Class) 또는 자식 클래스라고 한다)가 유산을 물려줄 클래스(기반 클래스(Base Class)또는 부모 클래스라고 한다)를 지정한다. 

*ex) 상속 개념*

```	
class 기반 클래스:
	# 멤버 정의
	
class 파생 클래스(기반 클래스)
	# 아무 멤버를 정의하지 않아도 기반 클래스의 모든 것을 물려받아 갖게 된다.
	# 단, 프라이빗 멤버(_로 시작하는 이름을 갖는 멤버)는 제외
```

#### super()

super()는 부모 클래스의 객체 역할을 하는 프록시(Proxy)를 반환하는 내장 함수이다!

- 사실상, super()함수의 반환값을 상위 클래스의 객체로 간주하고 코딩을 해도 된다.

super()를 사용함으로써, 기반 클래스가 다른 클래스로 교체되거나 수정되어도 파생 클래스가 받는 영향을 최소화 할 수 있다.

#### 다중 상속

파이썬에서는 파생 클래스를 정의할때 기반 클래스의 이름을 콤마(,)로 구분해서 쭉 적어주면 다중 상속이 이루어진다. 

*ex) 다중 상속의 예*

```
class A:
	pass
	
class B:
	pass
	
class C:
	pass
	
class D(A, B, C): # 클래스 D는 A, B, C로부터 상속받는다.
	pass
```

#### 오버라이딩

오버 라이딩(Overriding)은 영어로 짓밟다. (결정 등을) 무효로 하다. ~에 우선하다 등의 뜻을 갖고 있다. OOP에서 오버라이딩의 뜻은 "기반(부모) 클래스로부터 상속받은 메소드를 다시 정의하다"이다. 

*ex) 오버라이딩의 예*

```
>>> class A:
     	def method(self):
     		print("A")
     		
>>> class B(A):
    	def method(self):
    		print("B")
    		
>>> class C(A):
    	def method(self):
    		print("C")
    		
>>> A().method()
A
>>> B().method()
B
>>> C().method()
C
```

- 위의 코드에서 클래스 B와 C는 A를 상속하고 있기 때문에 가만히 있어도 method()를 물려받을 수 있었다. 하지만 그렇게 하지 않았다. 자신만의 method()를 새로 정의했다. 이것이 **오버라이딩**이다!

### 데코레이터: 함수를 꾸미는 객체

#### 데코레이터는 ```__call__()``` 메소드를 구현하는 클래스

```__call__()``` 메소드는 객체를 함수 호출 방식으로 사용하게 만드는 마법 메소드이다!

*ex) ```__call__()``` 예*

```
class MyDecorator:
	def __init__(self, f): # __init__() 메소드의 매개변수를 통해 함수를 받아들이고 데이터 속성에 저장해둔다.
		print("Initializing MyDecorator...")
		self.func = f
		
	def __call__(self):
		print("Begin :{0}".format( self.func.__name__))
		
		self.func() # __call__() 메소드가 호출되면서 생성자에서 저장해둔 함수(데이터 속성)를 호출한다!
		
		print("End :{0}".format(self.func.__name__))
```

#### 데코레이터를 생성하는 방법 1: 생성자

앞서 정의한 MyDecorator 클래스의 경우는 다음과 같이 데코레이터의 인스턴스를 만들어 사용한다.

```
def print_hello():
	print("Hello")
	
print_hello = MyDecorator(print_hello)
```

*ex) 데코레이터의 예*

```
class MyDecorator:
    def __init__(self, f):
        print("Initializing MyDecorator...")
        self.func = f # MyDecorator의 func 데이터 속성이 print_hello를 받아둔다.

    def __call__(self):
        print ("Begin :{0}".format( self.func.__name__))
        self.func()
        print ("End :{0}".format(self.func.__name__))

def print_hello():
    print("Hello.")

print_hello = MyDecorator(print_hello) # MyDecorator의 인스턴스가 만들어지며 __init__()메소드가 호출된다. print_hello 식별자는 앞에서 정의한 함수가 아닌 MyDecorator의 객체이다.
    
print_hello() # __call__()메소드 덕에 MyDecorator 객체를 호출하듯 사용 할 수 있다.
```

*ex) 실행 결과*

```
> decorator.py
Initializing MyDecorator ...
Begin :print_hello
Hello.
End :print_hello
```

#### 데코레이터를 사용하는 방법 2: @ 기호

데코레이터(장식)이라는 이름답게 사용하려면 @데코레이터의 꼴로 사용하는 것이 바람직하다. 앞에서는 생성자를 호출해서 데코레이터의 인스턴스를 만들었지만, @ 기호로 시작하는 데코레이터 전용 문법을 이용하면 함수에 꽃장식을 꽂아놓듯 간단하게 데코레이터의 인스턴스를 만들 수 있다.

*ex) @ 데코레이터 예*

```
class MyDecorator:
    def __init__(self, f):
        print("Initializing MyDecorator...")
        self.func = f

    def __call__(self):
        print ("Begin :{0}".format( self.func.__name__))
        self.func()
        print ("End :{0}".format(self.func.__name__))

@MyDecorator        
def print_hello():
    print("Hello.")

print_hello()
```

*ex) 실행 결과*

```
> decorator2.py
Initializing MyDecorator ...
Begin :print_hello
Hello.
End :print_hello
```

### for문으로 순회를 할 수 있는 객체 만들기

#### 이터레이터와 순회 가능한 객체

파이썬에서 for문을 실행할 때 가장먼저 하는 일은 순회하려는 객체의 ```__iter__()```메소드를 호출하는 것이다. ```__iter__()```메소드는 이터레이터(Iterator)라고 하는 특별한 객체를 for문에게 반환한다.

이터레이터는 ```__next__()```메소드를 구현하는 객체를 말하는데, for문은 매 반복을 수행할 때마다 바로 이 ```__next__()```메소드를 호출하여 다음 요소를 얻어낸다.

*ex) 이터레이터 예*

```
class MyDecorator:
    def __init__(self, f):
        print("Initializing MyDecorator...")
        self.func = f

    def __call__(self):
        print ("Begin :{0}".format( self.func.__name__))
        self.func()
        print ("End :{0}".format(self.func.__name__))

@MyDecorator        
def print_hello():
    print("Hello.")

print_hello()
```

*ex) 실행 결과*

```
0
1
2
3
4
```

#### 제네레이터

제네레이터(Generator)는 이터레이터처럼 동작하는 함수이다. 하지만 이터레이터보다 훨씬 더 간편하게 구현가능하다.

클래스를 정의하지 않아도 되고 ```__init__()```메소드나 ```__next__()```메소드를 구현 할 필요도 없다. 그저 함수 안에서 yield문을 이용하여 값을 반환하면 된다.

- yeild문은 상당히 독특하다. return문처럼 함수를 실행하다가 값을 반환하지만, return문과는 달리 함수를 종료시키지는 않고 중단시켜 놓기만 한다. 

*ex) 제네레이터 예*

```
def YourRange(start, end):
    current = start
    while current < end:
        yield current
        current += 1
    return

for i in YourRange(0, 5):
    print(i)
```

*ex) 실행 결과*

```
0
1
2
3
4
```

#### 상속의 조건: 추상 기반 클래스

"미운 오리 새끼"에서 아기 오리가 엄마 오리에게 미움을 받았던 이유는 단 하나.

외모이다. 미운 아기 오리는 사실 오리가 아니라 백조였다. 엄마 오리는 아무리 봐도 오리라고는 할 수 없는 아기 백조를 내치고 다른 아기 오리들만을 챙겼다.

프로그래머도 종종 엄마 오리와같은 입장이 될 때가 있다. 부모 클래스를 정의할 때 자식 클래스가 갖춰야 하는 모습을 규약으로 정의해 두고 이 규약을 따르지 않는 자식은 자식으로 인정하지 않는것이다. 추상 기반 클래스(Abstract Base Class)는 자식 클래스가 갖춰야 할 특징(메소드)을 강제하는 기능을 한다. 만약 추상 기반 클래스가 요구하는 메소드를 자식 클래스가 구현하지 않는다면, 자식 클래스의 인스턴스를 생성하고자 할 때 파이썬은 TypeError 예외를 일으킨다!    
 
```
from abc import ABCMeta
from abc import abstractmethod

class AbstractDuck(metaclass=ABCMeta):
	@abstractmethod
	def Quack(self):
		pass
```

- 파이썬에서는 모든 것이 객체이다. 심지어 클래스도 객체이다. 그러니 이 객체의 자료형인 클래스가 존재해야 한다. 메타 클래스는 '클래스에 대한 정보를 갖고 있는 클래스'를 말한다. 클래스를 정의할 때 metaclass에 별도의 메타 클래스를 지정하지 않으면 type 클래스가 기본적으로 사용된다.

## 오류를 어떻게 다뤄야 할까?

### 예외

파이썬에서 예외(Exception)는 문법적으로는 문제가 없는 코드를 실행하는 중에 발생하는 오류를 말한다.

#### try ~ except로 예외 처리하기

파이썬의 예외 처리는 try ~ except구문을 이용한다.

- try 절 안에는 문제가 없을 경우, 정상적인 경우에 실행할 코드블록을 배치한다.

- except 절에는 문제가 생겼을 때 뒤처리를 하는 코드 블록을 배치한다.

```
try: 
	# 문제가 없을 경우 실행할 코드
except:
	# 문제가 생겼을 때 실행할 코드
```

#### 여러 개의 except절 사용하기

프로그램이 하는 일이 많아지고 코드의 양이 늘어나면 처리해야 할 예외도 늘어난다. 늘어난 예외의 종류에 따른 예외처리를 구현하려면 하나 이상의 except절을 사용해야 한다. 

```
try:
	# 문제가 없을 경우 실행할 코드
except 예외형식1:
	# 문제가 생겼을 때 실행할 코드
except 에외형식2:
	# 문제가 생겼을 때 실행할 코드
```

#### try절을 무사히 실행하면 만날 수 있는 else

try와 함께 사용하는 else는 if문에서 사용하는 else와는 다르다. 이 else절은 try절에 있는 코드블록 실행중에 아무런 예외가 일어나지 않으면 실행된다. 

- 말하자면, try에 대한 else가 아닌 'except절에 대한 else'인 것이다.

```
try:
	# 실행할 코드블록
except: 
	# 예외 처리 코드블록
else:
	# except절을 만나지 않았을 경우 실행하는 코드블록
```

*ex) else 예*

```
my_list = [1, 2, 3]

try:
    print("첨자를 입력하세요:")
    index = int(input())
    print("my_list[{0}]: {1}".format(index, my_list[index]))
except Exception as err:
    print("예외가 발생했습니다 ({0})".format(err))
else:
    print("리스트의 요소 출력에 성공했습니다.")
```

*ex) 실행 결과*

```
> try_except_else.py
첨자를 입력하세요:
1
my_list[1]: 2
리스트의 요소 출력에 성공했습니다.

> try_except_else.py
첨자를 입력하세요:
10
예외가 발생했습니다 (list index out of range)
```

#### 어떤 일이 있어도 반드시 실행되는 finally

finally는 else와 비슷하면서도 매우 다르다. else는 except절이 실행되면 실행되지 않고, except절이 실행되지 않으면 실행됐었다. finally는 예외가 발생했든 아무 일이 없든 간에 '무조건'실행된다.

#### Exception 클래스

파이썬은 오류 상황에 대한 정보를 담는 예외 형식을 다양하게 제공한다. 그 예외 형식들의 맨 위에는 BaseException 클래스가 있다. 파이썬의 모든 예외 형식은 BaseException 클래스로부터 상속받는다.

- BaseException이 예외 클래스 족보의 시조이긴 하지만, 실질적인 시조로 간주되는 것은 그 밑에 있는 Exception클래스이다. 파이썬 코드를 작성하면서 사용되는 예외 형식은 거의 모두 Exception 클래스로부터 상속을 받는다.

#### 우리도 예외 좀 일으켜보자

우리가 작성한 코드도 파이썬의 함수나 연산자처럼 예외를 일으킬 수 있다. 예외 객체를 매개변수로 넘겨 raise문을 실행하면 된다. 

*ex) raise 예*

```
text = input()
if text.isdigit() == False:
	raise Exception("입력받은 문자열이 숫자로 구성되어 있지 않습니다."):
```

raise문을 통해 발생시킨 예외는 except문으로 받아 처리하지 않으면 자신을 받아주는 곳이 나올 때 까지 상위 코드로 나아간다. 

- 함수에서 일어난 예외를 함수 안에서 처리하지 않으면 그 예외는 함수의 호출자에게로 던져진다. 그 호출자도 처리를 안하고 그 호출자의 호출자도 처리를 안하다 보면 앞에서 본 것처럼 파이썬 인터프리터가 받나낸다.

*ex) 함수 안에서 예외를 일으키고 이것을 호출자에서 받아 처리하는 예*

```
def some_function():
    print("1~10 사이의 수를 입력하세요:")
    num = int(input())
    if num < 1 or num > 10:
        raise Exception("유효하지 않은 숫자입니다.: {0}".format(num))
    else:
        print("입력한 수는 {0}입니다.".format(num))

try:
    some_function()
except Exception as err: # 함수 안에서 일어난 예외가 except문으로 처리되지 않으면 함수 밖으로 다시 던져진다.
    print("예외가 발생했습니다. {0}".format(err))
```

*ex) 실행 결과*

```
> raise_in_function.py
1~10 사이의 수를 입력하세요:
5
입력한 수는 5입니다.

> raise_in_function.py
1~10 사이의 수를 입력하세요:
12
예외가 발생했습니다. 유효하지 않은 숫자입니다.: 12
```

#### 내가 만든 예외 형식

필요한 예외 형식(사용자 정의 예외 형식)을 직접 만들어 사용하려면 Exception 클래스를 상속하는 클래스를 정의하면 된다.

```
class MyException(Exception):
	pass
```

*ex) 직접 정의한 예외 형식 예*

```
class InvalidIntException(Exception):
    def __init__(self, arg):
        super().__init__('정수가 아닙니다.: {0}'.format(arg))
 
def convert_to_integer(text):
    if text.isdigit(): # 부호(+, -) 처리 못함.
        return int(text)
    else:
        raise InvalidIntException(text)

if __name__ == '__main__':
    try:
        print('숫자를 입력하세요:')
        text = input()
        number = convert_to_integer(text)        
    except InvalidIntException as err:
        print('예외가 발생했습니다 ({0})'.format(err))
    else:
        print('정수 형식으로 변환되었습니다 : {0}({1}'.format(number, type(number)))
```

*ex) 실행 결과*

```
> InvalidIntException.py
숫자를 입력하세요:
123
정수 형식으로 변환되었습니다 : 123(<class 'int'>

> InvalidIntException.py
숫자를 입력하세요:
abc
예외가 발생했습니다. (정수가 아닙니다.: abc)
```

## 파일에 데이터 읽고 쓰기

### 열라, 읽으라(쓰라), 닫으라

애플리케이션이 디스크 같은 하드웨어를 직접 제어해 파일에 접근하는 경우는 거의 없다. 운영체제가 파일관리 업무를 담당하고 있기 때문에, 애플리케이션이 운영체제에게 API 함수를 통해 파일 처리를 의뢰하면 운영체제가 요청한 업무를 수행해주고, 그 결과를 애플리케이션에게 돌려준다. 

파일 열기 - 읽기/쓰기 - 닫기에 필요한 파이썬 함수는 다음과 같다.

```
1. 파일 열기 # file = open()

2. 파일 읽기/쓰기 # file.read()/file.write()

3. 파일 닫기 # file.close()
```

*ex) 파일에 데이터를 기록하는 프로그램 예*

```
file = open('test.txt', 'w')
file.write('hello')
file.close()
```

*ex) 실행 결과*

```
> write.py
```

*ex) 파일의 내용을 읽는 프로그램 예*

```
file = open('test.txt', 'r')
str = file.read()
print(str)
file.close()
```

*ex) 실행 결과*

```
> read.py
hello
```

#### 자원 누수 방지를 돕는 with ~ as

open() 함수와 함께 with ~ as 문을 사용하면 명시적으로 close() 함수를 호출하지 않아도 파일이 항상 닫힌다. with ~ as 문을 사용하는 방법은 다음과 같다. 

```
with open(파일이름) as 파일 객체: # "파일객체 = open(파일이름)"과 같다.
	# 코드 블록
	# 이곳에서 읽거나
	# 쓰기를 한 후
	# 그냥 코드를 빠져나가면 된다 # with문 덕분에 close()을 하지 않아도 된다.
```

#### with문의 비밀: 컨텍스트 매니저

아무 함수나 with절에 올 수 있는 것은 아니다. 컨텍스트 매니저(Context Manager)를 제공하는 함수여야 with문과 함께 사용할 수 있다. 

컨텍스트 매니저는 ```__enter__()```메소드와 ```__exit__()```메소드를 구현하고 있는 객체이다. with문은 컨텍스트 매니저를 획득한 후 코드 블록의 실행을 시작할 때 컨텍스트 매니저의 ```__enter__()```메소드를 호출하고, 코드블록이 끝날 때 ```__exit__()```를 호출한다. 

- ```__exit__()```메소드에 프로그래머들이 흔하게 잊곤 한느 자원 해제 코드를 구현해 놓으면 자원을 해제하는 명시적인 코드가 없어도 자원 획득/해제를 안전하게 처리할 수 있게 된다. (with문을 사용한다는 전제하)

```
with open('test.txt', 'r') as file: # 코드블록 시작하기 전에 컨텍스트 매니저 __exit__()호출
	s = file.read()
	print(s) # 컨텍스트 매니저 __exit__()호출
```

*ex) 컨텍스트 매니저 구현 예*

```
class open2(object):
    def __init__(self, path):
        print ('initialized')
        self.file = open(path)

    def __enter__(self):
        print ('entered')
        return self.file

    def __exit__(self, ext, exv, trb):
        print ("exited")
        self.file.close()
        return True

with open2("test.txt") as file:
    s = file.read()
    print(s)
```

*ex) 실행 결과*

```
> open2.py
initialized
entered
hello
exited
```

컨텍스트 매니저를 훨씬 간편하게 구현 할 수 있는 방법이 있다.

- 바로 @contextmanager 데코레이터를 이용하는 것이다.

@contextmanager 데코레이터는 ```__call__()```메소드는 물론이고, 컨텍스트 매니저 규약을 준수하는 데 필요한 ```__enter__()``` 메소드와 ```__exit__()``` 메소드를 모두 갖추고 있다. 

```
from contextlib import contextmanager # contextlib 모듈로부터 contextmanager를 반입

@contextmanager # @contextmanager 데코레이터로 함수 수식
def 함수이름():
	# 자원 획득
	try:
		yield 자원 # yield문을 통해 자원 반환: with문의 코드블록이 시작될 때 실행.
	finally:
		# 자원 해제 # with문의 코드블록이 종료될 때 실행된다.
```

- @contextmanager로 수식되는 함수의 구조에서 눈여겨봐야 할 곳은 크게 3가지이다.

1. try ~ finally 블록을 갖고 있다.

2. try 블록에서는 yield문을 통해 자원을 반환한다. 이때 yield문은 자신의 매개변수로 넘겨진 자원을 반환한 뒤 임시적으로 현재 함수의 실행을 정지시킨다. yield에 의해 정지된 함수는 with문의 코드블록 실행이 끝날 때 다시 실행된다. 

3. finally 블록에서 획득한 자원을 해제한다.

요약하면, @contextmanager로 수식하는 함수는 try 블록이 ```__enter__()``` 메소드의 역할을, finally 블록이 ```__exit__()``` 메소드의 역할을 수행한다고 할 수 있다.

#### open()함수 다시보기

컴퓨터가 다루는 모든 파일은 바이너리 파일이다. 바이너리 파일 중에서 텍스트 데이터만 기록하고 있는 파일을 텍스트 파일이라고 한다. open() 함수는 코드에서 입력되는 매개변수에 따라 텍스트 파일을 처리할 것인가 또는 바이너리 파일을 처리할 것인가를 결정한다.

- open() 함수는 모두 8개의 매개변수를 받아들인다. 이들 매개변수는 하나의 필수 매개변수과 일곱 개의 선택적 매개변수로 이루어져 있다. open() 함수의 반환값은 물론 파일 객체이다.

```
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closed=True, opener=None)
```

### 텍스트 파일 읽고/쓰기

#### 문자열을 담은 리스트를 파일에 쓰는 writelines() 메소드

writelines()는 문자열을 요소로 가지는 순서열 객체를 매개변수로 입력받아 해당 순서열 객체의 내용을 모두 파일에 기록한다.

```
lines = ["we'll find a way we always have - Interstellar\n", 
         "I'll find you and I'll kill you - Taken\n",
         "I'll be back - Terminator 2\n"]
         
with open('movie_quotes.txt', 'w') as file:
    file.writelines(lines)
```

*ex) 실행 결과*

```
> writelist.py

> type movie_quotes.txt
we'll find a way we always have - Interstellar
I'll find you and I'll kill you - Taken
I'll be back - Terminator 2
```

#### 2줄 단위로 텍스트를 읽는 readline()과 redlines() 메소드

*ex) readline() method 예*

```
with open('movie_quotes.txt', 'r') as file:    
    line = file.readline()
    
    while line != '': # readline() 메소드는 파일의 끝에 도달하면 ''를 반환한다. 그런데 실제로 빈 줄을 읽어 들였을 경우에는? 빈 줄을 읽어 들인 경우에는 개행 문자를 반환한다.
        print(line, end='')
        line = file.readline()
```

*ex) 실행 결과*

```
> readline.py
we'll find a way we always have - Interstellar
I'll find you and I'll kill you - Taken 
I'll be back - Terminator2
```

*ex) readlines() method 예*

```
with open('movie_quotes.txt', 'r') as file:    
    lines = file.readlines()
    
    line = ''
    for line in lines:
        print(line, end='')
```

*ex) 실행 결과*

```
> readlines.py
we'll find a way we always have - Interstellar
I'll find you and I'll kill you - Taken
I'll be back - Terminator 2
```

#### 문자 집합과 인코딩

컴퓨터의 발명, 발전이 미국의 학계와 기업을 중심으로 이루어지다 보니 문자 집합도 미국을 기준으로 제정되었고, 미국에서 제정된 ASCII는 1960년대에 제정된 문자 집합으로, 이후에 개발된 문자 집합들의 토대를 이루고 있다.

미국의 엔지니어들은 ASCII으로 행복하게 살아가고 있었지만, 다른나라의 사람들은 그렇지 못했다. 자국언어에서 사용해야 하는 문자들을 ASCII로는 표현 할 수가 없었다. 

그래서 미국 표준을 보완한 새로운 국제 표준이 등장했는데 그것이 ISO/IEC 8859-1이다.

이 표준 제정 이후 중앙 유럽어, 남유럽어, 북유럽어, 아랍어 등을 지원하는 ISO/IEC 8859-N 표준이 새로 제정 되었다.

- DBCS라는 2바이트(16비트)를 활용해서 문자 집합을 구성하는 방법으로 한글 문자 집합 표준도 만들어졌다.

	- KS X 1001, EUC-KR, CP949 등이 있다.

**문자 집합을 저장하고 표현하는 방법을 통일해서 문서와 소프트웨어를 작성하고 열람한다면 얼마나 좋을까?**

이런 배경에서 소프트웨어 회사들이 힘을 모아 유니코드 협회를 만들고 유니코드(Unicode)를 제정했다.

하지만 기존의 시스템을 추가하자 코드 포인트가 2바이트를 넘어서게 되었고, 새로운 문자를 위한 코드 포인트가 부족해지게 되었다.

- 이런 요구사항들을 충족시키려다보니 유니코드를 인코딩(부호화)하는 방법을 정의하는 표준이 필요해졌다.

	- UTF-7, UTF-8, UTF-16, UTF-32등이 바로 그것이다.

*UTF는 우리 말로 하면 변환 인코딩 형식(Unicode Transformation Format)이라고 하는데, 이 중에서 가장 많이 사용하는 것은 UTF-8이다!*

#### 바이너리 파일 다루기

파이썬에서 struct 모듈의 도움이 없이는 바이너리 파일을 제대로 다루기가 어렵다. struct 모듈은 일반 데이터 형식과 bytes 형식 사이의 변환을 수행하는 함수들을 담고 있다. 

*ex) struct 예*

```
>>> import struct 
>>> packed = struct.pack('i', 123) # pack() 함수는 첫 번째에 매개변수 1에 따라 4바이트 크기의 bytes 객체 packed를 준비하고 두 번째 매개변수를 bytes에 복사해 넣는다.
>>> for b in packed:  
    	print(b) # bytes 객체 packed의 각바이트에 있는 내용을 출력.
    	
123
0
0
0
>>> unpacked = struct.unpack('i', packed) 
>>> unpacked 
(123,)
>>> type(unpacked) # unpack() 함수는 튜플 형식을 반환한다.
<<class 'tuple'>>
```	

- struct.pack(), struct.unpack() 함수의 예는 형식 문자열을 'i'로만 지정했는데 이것은 '바이트 순서:시스템 기본값, 데이터 구조:4바이트 크기의 정수형식 1개'로 데이터를 반환하겠다는 뜻이다.

## 네트워크 프로그래밍

### 네트워크 프로그래밍에 앞서 알아둬야 할 기초

#### 인터넷의 유래

네트워크(Network)는 그물(Net)에서 파생된 단어로, 어떤 물건이나 사람 등의 상호 연결되어 있는 체계를 말한다. 보통 우리가 이야기하는 네트워크는 컴퓨터들이 상호 연결되어 있는 '컴퓨터 통신 네트워크'이다. 

냉전시대 미국은 소련과의 우주경쟁에서 뒤쳐졌다는 위기감에 DARPA라는 기관을 설립했다. DARPA의 각 연구기관에서는 컴퓨터를 이용해서 연구를 수행했고, 네트워크와 네트워크를 연결하는 새로운 구상을 하게 되었다. 이 방법을 이용하면 연구기관들을 잇는 회선을 일일히 구축하지 않고도 최소한의 비용으로 연구소들의 컴퓨터를 연결 할 수 있었다. 

*필요한 자료들을 '빛의 속도'로 획득할 수 있게 되었다*

**엄청난 혁신이었다**

- 이른바 DARPANET이라고 불리던 이 네트워크는 더 많은 대학과 연구기관으로, 또한 세계의 연구기관과 민간으로 연결되기 시작하더니 1980년대 말에 이르러서는 인터넷이라고하는 국제 통신망을 형성하게 되었다.

#### TCP/IP 스택

컴퓨터끼리 네트워크에서 데이터를 주고 받으려면 그 네트워크에서 통용되는 '프로토콜(Protocol)'을 따라야한다. 프로토콜은 규약, 규칙이라는 뜻의 낱말로써, 여기에서는 컴퓨터들이 네트워크를 통해 데이터를 주고받기 위한 '통신규약'을 말한다.

- TCP/IP는 다음과 같이 크게 네 개의 계층으로 구성되어 있으며, 한 계층 위에 다른 계층이 포개진 형태 때문에 이것을 TCP/IP 스택(stack)이라고 부르기도 한다.

| Application Layer  |
|---|
| Transport Layer  |
| Internet Layer  |
| Link Layer  |

- **단순해 보이는 이 네 단계의 프로토콜 모음이 오늘날 인터넷을 떠받치고 있다**

#### 링크 계층

TCP/IP는 네트워크의 물리적인 구성으로부터 독립적인 프로토콜이다. 컴퓨터가 네트워크에 전화전에 모뎀으로 연결되어 있든, LAN에 이더넷 케이블로  연결되어 있든, 혹은 와이파이에 연결되어 있든 전혀 신경 쓰지 않는다.

- 이것은 링크 계층에서 네트워크의 물리적인 연결 매체를 통해 패킷을 주고 받는 작업을 담당해주기 때문이다.

#### 인터넷 계층

인터넷 계층은 패킷을 수신해야 할 상대의 주소를 지정하고, 나가는 패킷에 대해서는 적절한 크기로 분할하며 들어오는 패킷에 대해서는 재조립을 수행한다! 이 계층에서 사용되는 규약이 바로 인터넷 프로토콜(Internet Protocol), 즉, IP이다. TCP/IP에서 IP가 바로 이것이다.

#### 전송 계층

전송 계층(Transport Layer)에는 이름 그대로 패킷의 '운송'을 담당하는 프로토콜들이 정의되어 있다. 그 중에서도 전송 제어 프로토콜(TCP, Transmission Control Protocol)는 송신측과 수신측 간의 연결성을 제공하며, 신뢰할 수 있는 패킷 전송 서비스를 제공한다. 여러 개의 패킷을 송신하는 경우 패킷 사이의 순서를 보장하며, 패킷이 유실되기라도 하면 재전송을 해주기까지 한다. TCP/IP 프로토콜에서 TCP가 바로 이 프로토콜을 가리키는 것이며, TCP는 IP가 제공하지 않는 연결성, 신뢰성을 제공한다. 웹 문서를 전달하는 기능을 하는 HTTP를 비롯한 수많은 응용 프로토콜들이 바로 이 TCP와 IP 프로토콜 위에서 동작한다.

#### 애플리케이션 계층

이 계층은 각 응용 프로그램 나름의 프로토콜들이 정의되는 곳이다. 웹 문서를 주고 받기 위한 HTTP, 파일 교환을 위한 FTP, 네트워크 관리를 위한 SNMP 등이 애플리케이션 계층에서 정의된 프로토콜의 대표적인 예이다. 애플리케이션의 계층의 프로토콜들은 전송 계층의 프로토콜 중 TCP에 기반할 수도 있고, UDP에 기반할 수도 있다. 

- HTTP와 FTP는 상대적으로 큰 데이터를 처리해야 하기 때문에 연결성과 신뢰성을 제공하는 TCP에 기반하고 있고, SNMP는 단순한 정보만을 다루는 데다 패킷을 일부 유실한다 해도 임무에 지장을 주지 않기 때문에 비용이 저렴한 UDP에 기반한다.

### TCP/IP의 주소 체계: IP 주소

우편 배달부가 우편물을 배달하기 위해서는 '주소'가 필요하다. 인터넷에서도 패킷을 배달하려면 이것을 어디에서 보냈는지, 또 어디로 보낼지에 대한 정보 즉 주소가 필요하다. 그리고 인터넷에서 사용하는 이 주소를 일컬어 'IP 주소(Address)'라고 부른다.

- 현재는 주소 고갈이 임박한 IPv4 체계에서 IPv6체계로 전환이 전 세계적으로 진행되고 있다.

### 포트

큰 빌딩은 대개 출입구가 여러 개 있다. O마트의 예를 보면 주차장 출입구만 해도 일반 고객 승용차와 수화물 차량 출입구가 나눠져 있고, 살마들이 드나드는 출입구도 여러 곳이 있다. 이 출입구를 통해 차도, 사람도, 물건도 드나든다.

컴퓨터도 네트워크 패킷이 드나들려면 '주소'뿐만아니라 출입문이 필요하다. 

이 출입문을 일컬어 포트(Port)라고 한다.

### TCP/IP의 동작 과정

TCP/IP는 서버/클라이언트 방식으로 동작한다. 통신을 수행하는 양단 중 한쪽에서는 한쪽에게 서비스를 제공해야 한다는 것이다. 서버/클라이언트 방식으로 만들어진 TCP/IP 서비스의 예를 들면, FTP서버와 FTP클라이언트, SMTP 메일 서버와 메일 클라이언트 등등 이들 모두가 TCP/IP 기반으로 만들어졌다.

### socket과 TCPServer를 이용한 TCP/IP 프로그래밍

파이썬의 라이브러리들이 공통으로 사용하는 라이브러리가 있다. 바로 socket 모듈이다.

socket 모듈은 TCP/IP, UDP/IP를 지원하는 버클리 소켓 인터페이스를 여러 가지 함수와 socket클래스를 통해 제공한다.

socket 클래스를 이용하면 거의 모든 인터넷 프로토콜을 구현할 수 있다는 장점이 있는 반면, 익히고 사용하기가 간단하지 않다는 단점도 있다.

| **클래스**  	| **메소드**  	| **설명**  	|
|---	|---	|---	|
| TCPServer  	| serve_forever()  	| 클라이언트의 접속 요청을 수신 대기한다. 접속 요청이 있을 경우 수락하고 BaseRequestHandler의 handler() 메소드를 호출한다.  	|
| BaseRequestHandler  	| handler()  	| 클라이언트 접속 요청을 처리한다.  	|
| socket  	| connect()  	| 서버에 접속 요청을 한다.  	|
|  	| send()  	| 데이터를 상대방에게 전송한다.  	|
|  	| recv()  	| 데이터를 수신한다.  	|

*ex) TCPServer와 BaseRequestHandler와 socket 클래스의 사용법 예*

```
class MyTCPHandler(socketserver.BaseRequestHandler):
	def handle(self):
		print(self.client_address[0]) # 클라이언트의 IP주소 출력
		buffer = self.request.recv(1024).strip() # 데이터 수신
		self.request.send (buffer) # 데이터 송신
```

- BaseRequestHandler로부터 상속을 받은 MyTCPHandler는 handle() 메소드를 재정의한다. handle() 메소드는 클라이언트의 연결 요청을 서버가 수락했을 때 호출된다. 다시 말하면 handle() 메소드가 호출되었다는 것은 통신을 수행할 준비가 됐다는 것이다!

*ex) 클라이언트가 보내오는 메세지를 서버가 그대로 '메아리'쳐 돌려보내는 프로그램 예*

```
import socketserver
import sys

class MyTCPHandler(socketserver.BaseRequestHandler):
    def handle(self):
        print('클라이언트 접속 : {0}'.format(self.client_address[0]))
        sock = self.request
        
        rbuff  = sock.recv(1024) # 데이터를 수신하고 그 결과를 rbuff에 담는다. rbuff는 bytes 형식이다.
        received = str(rbuff, encoding="utf-8")
        print('수신 : {0}'.format(received))
        
        # 수신한 데이터를 그대로 돌려보냄.
        sock.send(rbuff) # 수신한 데이터를 그대로 클라이언트에게 다시 송신한다.
        print('송신 : {0}'.format(received))
        sock.close()

if __name__ == '__main__':

    if len(sys.argv) < 2:
        print('{0} <Bind IP>'.format(sys.argv[0]))
        sys.exit()
        
    bindIP = sys.argv[1]
    bindPort = 5425 # 

    server = socketserver.TCPServer((bindIP, bindPort), MyTCPHandler)
    
    print('메아리 서버 시작...')
    server.serve_forever() # 클라이언트로부터 접속 요청을 받아들일 준비를 한다.
```

*ex) 메아리 클라이언트 예*

```
import socket
import sys

if __name__ == '__main__':
    
    if len(sys.argv) < 4:
        print("{0} <Bind IP> <Server IP> <Message>".format(sys.argv[0]))
        sys.exit()
        
    bindIP = sys.argv[1]
    serverIP = sys.argv[2]
    message = sys.argv[3]

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # SOCK_STREAM = TCP socket 
    sock.bind((bindIP, 0))

    try:
        sock.connect((serverIP, 5425)) # 연결 요청을 수행한다.
        
        # 메아리 송신
        sbuff = bytes(message, encoding="utf-8")
        sock.send(sbuff) # 메세지를 송신한다.
        print("송신 : {0}".format(message))

        # 메아리 수신
        rbuff = sock.recv(1024) # 메세지를 수신한다.
        received = str(rbuff, encoding="utf-8")
        print("수신 : {0}".format(received))
    finally:
        sock.close()
```

#### 흐르는 패킷

TCP 프로토콜은 연결 지향, 흐름 지향 프로토콜이다. 전기처럼 양쪽이 연결되어 있어야 하고 보내는 쪽에서 받는 쪽으로 패킷을 흘려 보낸다. 

하지만 TCP 프로토콜은 전기와 달리 흐름 속에서 각 개별 패킷의 경계를 구분해야 한다. 시작이 어디고 끝이 어디인지를 파악해야 한다.

### 프로토콜 설계와 네트워크 애플리케이션 프로그래밍 예제

#### 파일 업로드 프로토콜

파일 업로드 프로토콜(FUP)은 헤더와 바디의 두 부분으로 나뉜다. 바디에는 실제로 전달하고자 하는 데이터를 담고, 헤더에는 본문 길이를 비롯해 메세지의 속성 몇 가지를 담는다. 바디의 길이는 담는 데이터에 따라 달라지지만 헤더의 길이는 16바이트로 항상 일정하다. 따라서 수신한 패킷을 분석할 때는 가장 먼저 16바이트를 먼저 확인해서 (바디의 길이를 포함한) 메세지의 속성을 확인하고, 그 다음에 바디의 길이 만큼을 또 읽어 하나의 메세지 끝을 끊어내야 한다.

#### 파일 업로드 서버와 클라이언트 구현

예제 프로그램의 구현은 세 가지 부분으로 나눠서 진행한다.

- 서버/클라이언트 공용 모듈 구현

- 서버 구현

- 클라이언트 구현

**서버/클라이언트가 같이 사용할 모듈 만들기**

```
REQ_FILE_SEND  = 0x01 # 메세지 타입 상수 정의
REP_FILE_SEND  = 0x02
FILE_SEND_DATA = 0x03
FILE_SEND_RES  = 0x04

NOT_FRAGMENTED = 0x00 # 파일 분할 여부 상수 정의
FRAGMENTED = 0x01

NOT_LASTMSG = 0x00 # 분할된 메세지의 마지막 여부 상수 정의
LASTMSG = 0x01

ACCEPTED = 0x00 # 파일 전송 수락 여부 상수 정의
DENIED = 0x01

FAIL = 0x00 # 파일 전송 성공 여부 상수 정의
SUCCESS = 0x01

class ISerializable:
    def GetBytes(self): # 메세지, 헤더, 바디는 모두 이 클래스를 상속한다. 즉, 이들은 자신의 데이터를 바이트 배열로 변환하고 그 바이트 배열의 크기를 반환해야 한다.
        pass

    def GetSize():
        pass

class Message(ISerializable):
    def __init__(self):
        self.Header = ISerializable()
        self.Body = ISerializable()
        
    def GetBytes(self):
        buffer = bytes(self.GetSize())

        header = self.Header.GetBytes()
        body = self.Body.GetBytes()

        return header + body

    def GetSize(self):
        return self.Header.GetSize() + self.Body.GetSize()
```

- 메세지의 헤더

```
from message import ISerializable
import struct

class Header(ISerializable):
    def __init__(self, buffer):
        self.struct_fmt = '=3I2BH' # 3 unsigned int, 2 byte, 1 unsigned short
        self.struct_len = struct.calcsize(self.struct_fmt)

        if buffer != None:            
            unpacked = struct.unpack(self.struct_fmt, buffer)

            self.MSGID = unpacked[0]
            self.MSGTYPE = unpacked[1]
            self.BODYLEN = unpacked[2]
            self.FRAGMENTED = unpacked[3]
            self.LASTMSG = unpacked[4]
            self.SEQ = unpacked[5]

    def GetBytes(self):
        return struct.pack(
            self.struct_fmt, 
            *( 
                self.MSGID,
                self.MSGTYPE,
                self.BODYLEN,
                self.FRAGMENTED,
                self.LASTMSG,
                self.SEQ
            ))

    def GetSize(self):
        return self.struct_len
```

- 메세지 본문(body)를 표현하는 클래스

```
from message import ISerializable
import message
import struct

class BodyRequest(ISerializable): # 파일 전송 요청 메세지(0x01)에 사용할 본문 클래스이다. FILESIZE와 FILENAME 데이터 속성을 갖는다.
    def __init__(self, buffer):
        if buffer != None:
            slen = len(buffer)
            
            # 1 unsigned long long, N character
            self.struct_fmt = str.format('=Q{0}s', slen-8) 
            self.struct_len = struct.calcsize(self.struct_fmt)
            if slen > 4: # unsigned long long의 크기
                slen = slen - 4
            else:
                slen = 0

            unpacked = struct.unpack(self.struct_fmt, buffer)

            self.FILESIZE = unpacked[0]
            self.FILENAME = unpacked[1].decode(
                encoding='utf-8').replace('\x00', '')
        else:
            self.struct_fmt = str.format('=Q{0}s', 0)
            self.struct_len = struct.calcsize(self.struct_fmt)
            self.FILESIZE = 0
            self.FILENAME = ''


    def GetBytes(self):
        buffer = self.FILENAME.encode(encoding='utf-8')
        
        # 1 unsigned long long, N character
        self.struct_fmt = str.format('=Q{0}s', len(buffer)) 
        
        return struct.pack(
            self.struct_fmt, 
            *( 
                self.FILESIZE,
                buffer
            ))

    def GetSize(self):
        buffer = self.FILENAME.encode(encoding='utf-8')
        
        # 1 unsigned long long, N character
        self.struct_fmt = str.format('=Q{0}s', len(buffer)) 
        self.struct_len = struct.calcsize(self.struct_fmt)
        return self.struct_len

class BodyResponse(ISerializable): # 파일 전송 요청에 대한 응답 메세지(0x02)에 사용할 본문 클래스이다. 요청 메세지의 MSGID와 수락 여부를 나타내는 RESPONSE 데이터 속성을 갖는다.
    def __init__(self, buffer):
    
        # 1 unsigned int, Byte
        self.struct_fmt = '=IB' 
        self.struct_len = struct.calcsize(self.struct_fmt)

        if buffer != None:
            unpacked = struct.unpack(self.struct_fmt, buffer)

            self.MSGID = unpacked[0]
            self.RESPONSE = unpacked[1]
        else:
            self.MSGID = 0
            self.RESPONSE = message.DENIED

    def GetBytes(self):
        return struct.pack(
            self.struct_fmt, 
            *( 
                self.MSGID,
                self.RESPONSE
            ))

    def GetSize(self):
        return self.struct_len
        
class BodyData(ISerializable): # 실제 파일을 전송하는 메세지(0x03)에 사용할 본문 클래스이다. 앞서 프로토콜 정의에서 언급되었던 것처럼 DATA 필드만 갖고 있다.
    def __init__(self, buffer):
        if buffer != None:
            self.DATA = buffer

    def GetBytes(self):
        return self.DATA

    def GetSize(self):
        return len(self.DATA)

class BodyResult(ISerializable): # 파일 전송 결과 메세지, 메세지(0x04)에 사용할 본문 클래스이다. 요청 메세지의 MSGID와 성공 여부를 나타내는 RESULT 데이터 속성을 갖는다.
    def __init__(self, buffer):
        
        # 1 unsigned int, Byte
        self.struct_fmt = '=IB' 
        self.struct_len = struct.calcsize(self.struct_fmt)
        if buffer != None:
            unpacked = struct.unpack(self.struct_fmt, buffer)
            self.MSGID = unpacked[0]
            self.RESULT = unpacked[1]
        else:
            self.MSGID = 0
            self.RESULT = message.FAIL

    def GetBytes(self):
        return struct.pack(
            self.struct_fmt,
            *( 
                self.MSGID,
                self.RESULT
            ))

    def GetSize(self):
        return self.struct_len
```

- MessageUtil 클래스의 구현

```
import socket

import message
from message import Message
from message_header import Header
from message_body import BodyRequest
from message_body import BodyResponse
from message_body import BodyData
from message_body import BodyResult


class MessageUtil:
    @staticmethod
    def send(sock, msg): # send() 메소드는 msg 매개변수가 담고 있는 모든 바이트를 내보낼 때까지 반복해서 socket.send() 메소드를 호출한다.
        sent = 0
        buffer = msg.GetBytes()
        while sent < msg.GetSize():            
            sent += sock.send(buffer)

    @staticmethod
    def receive(sock):
        totalRecv = 0
        sizeToRead = 16 # 헤더의 크기
        hBuffer = bytes() # 헤더 버퍼

        # 헤더 읽기
        while sizeToRead > 0: # 첫 반복문에서는 스트림으로부터 메세지 헤더의 경계를 끊어낸다.            
            buffer = sock.recv(sizeToRead)
            if len(buffer) == 0:
                return None

            hBuffer += buffer
            totalRecv += len(buffer)
            sizeToRead -= len(buffer)

        header = Header(hBuffer)

        totalRecv = 0
        bBuffer = bytes()
        sizeToRead = header.BODYLEN

        while sizeToRead > 0: # 첫 반복문에서 얻은 헤더에서 본문의 길이를 뽑아내어 그 길이만큼 다시 스트림으로부터 본문을 읽는다.
            buffer = sock.recv(sizeToRead)
            if len(buffer) == 0:
                return None

            bBuffer += buffer
            totalRecv += len(buffer)
            sizeToRead -= len(buffer)

        body = None

        if header.MSGTYPE == message.REQ_FILE_SEND:
            body = BodyRequest(bBuffer)
        elif header.MSGTYPE == message.REP_FILE_SEND:
            body = BodyResponse(bBuffer)
        elif header.MSGTYPE == message.FILE_SEND_DATA:
            body = BodyData(bBuffer)
        elif header.MSGTYPE == message.FILE_SEND_RES:
            body = BodyResult(bBuffer)
        else:
            raise Exception(                     
                    "Unknown MSGTYPE : {0}".
                    format(header.MSGTYPE))

        msg = Message()
        msg.Header = header
        msg.Body = body
            
        return msg
```

- 파일 업로드 서버의 구현

```
import os
import sys
import socket
import socketserver
import struct

import message
from message import Message

from message_header import Header
from message_body import BodyData
from message_body import BodyRequest
from message_body import BodyResponse
from message_body import BodyResult

from message_util import MessageUtil

CHUNK_SIZE = 4096
upload_dir = ''

class FileReceiveHandler(socketserver.BaseRequestHandler):
    def handle(self):
        print("클라이언트 접속 : {0}".format(self.client_address[0]))

        client = self.request # client socket

        reqMsg = MessageUtil.receive(client) # 클라이언트가 보내온 파일 전송 요청 메세지를 수신한다.

        if reqMsg.Header.MSGTYPE != message.REQ_FILE_SEND:
            client.close()
            return

        reqBody = BodyRequest(None)

        print(
            "파일 업로드 요청이 왔습니다. 수락하시겠습니까? yes/no")
        answer = sys.stdin.readline()

        rspMsg = Message()
        rspMsg.Body = BodyResponse(None)
        rspMsg.Body.MSGID = reqMsg.Header.MSGID
        rspMsg.Body.RESPONSE = message.ACCEPTED

        rspMsg.Header = Header(None)

        msgId = 0
        rspMsg.Header.MSGID = msgId
        msgId = msgId + 1
        rspMsg.Header.MSGTYPE = message.REP_FILE_SEND
        rspMsg.Header.BODYLEN = rspMsg.Body.GetSize()
        rspMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED
        rspMsg.Header.LASTMSG = message.LASTMSG
        rspMsg.Header.SEQ = 0

        if answer.strip() != "yes": # 사용자가 'yes'가 아닌 답을 입력하면 클라이언트에게 '거부'응답을 보낸다.
            rspMsg.Body = BodyResponse(None)
            rspMsg.Body.MSGID = reqMsg.Header.MSGID
            rspMsg.Body.RESPONSE = message.DENIED
        
            MessageUtil.send(client, rspMsg)
            client.close()
            return
        else:
            MessageUtil.send(client, rspMsg) # 물론'yes'를 입력하면 클라이언트에게 '승낙'응답을 보낸다.

            print("파일 전송을 시작합니다...")

            fileSize = reqMsg.Body.FILESIZE
            fileName = reqMsg.Body.FILENAME
            recvFileSize = 0 
            with open(upload_dir + "\\" + fileName, 'wb') as file: # 업로드 받을 파일을 생성한다.
                dataMsgId = -1
                prevSeq = 0
                
                while True:
                    reqMsg = MessageUtil.receive(client)
                    if reqMsg == None:
                        break

                    print("#", end='')
                    
                    if reqMsg.Header.MSGTYPE != message.FILE_SEND_DATA:
                        break

                    if dataMsgId == -1:
                        dataMsgId = reqMsg.Header.MSGID
                    elif dataMsgId != reqMsg.Header.MSGID:
                        break                    

                    if prevSeq != reqMsg.Header.SEQ: # 메세지 순서가 어긋나면 전송을 중단한다.
                        print("{0}, {1}".format(prevSeq, reqMsg.Header.SEQ))
                        break
                    
                    prevSeq += 1

                    recvFileSize += reqMsg.Body.GetSize() # 전송받은 파일의 일부를 담고 있는 bytes 객체를 서버에서 생성한 파일에 기록한다.
                    file.write(reqMsg.Body.GetBytes())

                    if reqMsg.Header.LASTMSG == message.LASTMSG: # 마지막 메세지만 반복문을 빠져나온다.
                        break
               
                file.close()

                print()
                print("수신 파일 크기 : {0} bytes".format(recvFileSize))

                rstMsg = Message()
                rstMsg.Body = BodyResult(None)
                rstMsg.Body.MSGID = reqMsg.Header.MSGID
                rstMsg.Body.RESULT = message.SUCCESS
                
                rstMsg.Header = Header(None)
                rstMsg.Header.MSGID = msgId
                msgId += 1
                rstMsg.Header.MSGTYPE = message.FILE_SEND_RES
                rstMsg.Header.BODYLEN = rstMsg.Body.GetSize()
                rstMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED
                rstMsg.Header.LASTMSG = message.LASTMSG
                rstMsg.Header.SEQ = 0

                if fileSize == recvFileSize: # 파일 전송 요청에 담겨온 파일 크기와 실제로 받은 파일의 크기를 비교하여 같으면 성공 메세지를 보낸다.
                    MessageUtil.send(client, rstMsg)
                else:
                    rstMsg.Body = BodyResult(None)
                    rstMsg.Body.MSGID = reqMsg.Header.MSGID
                    rstMsg.Body.RESULT = message.FAIL
                    MessageUtil.send(client, rstMsg) # 파일 크기에 이상이 있다면 실패 메세지를 보낸다.

            print("파일 전송을 마쳤습니다.")                
            client.close()

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("사용법 : {0} <Directory>".format(sys.argv[0]))
        sys.exit(0)

    upload_dir = sys.argv[1]
    if os.path.isdir(upload_dir) == False:
        os.mkdir(upload_dir)
         
    bindPort = 5425
    server = None
    try:
        server = socketserver.TCPServer(
            ('', bindPort), FileReceiveHandler)
            
        print("파일 업로드 서버 시작...")
        server.serve_forever()
    except Exception as err:
        print(err)

    print("서버를 종료합니다.")
```
    
- 클라이언트의 구현

```
import os
import sys
import socket
import struct

import message
from message import Message

from message_header import Header
from message_body import BodyData
from message_body import BodyRequest
from message_body import BodyResponse
from message_body import BodyResult

from message_util import MessageUtil

CHUNK_SIZE = 4096

if   __name__ == '__main__':
    if len(sys.argv) < 3:
        print("사용법 : {0} <Server IP> <File Path>".
              format(sys.argv[0]))
        sys.exit(0)

    serverIp   = sys.argv[1]
    serverPort = 5425
    filepath   = sys.argv[2]
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # TCP 소켓을 생성한다.
        
    try:
        print("서버:{0}/{1}".format(serverIp, serverPort))        
    
        sock.connect((serverIp, serverPort)) # 접속 요청을 수락한다.

        msgId = 0

        reqMsg = Message()        
        filesize = os.path.getsize(filepath)
        reqMsg.Body = BodyRequest(None)
        reqMsg.Body.FILESIZE = filesize
        reqMsg.Body.FILENAME = filepath[filepath.rindex('\\')+1:]
    
        msgId += 1
        reqMsg.Header = Header(None)
        reqMsg.Header.MSGID = msgId
        reqMsg.Header.MSGTYPE = message.REQ_FILE_SEND
        reqMsg.Header.BODYLEN = reqMsg.Body.GetSize()
        reqMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED
        reqMsg.Header.LASTMSG = message.LASTMSG
        reqMsg.Header.SEQ = 0
          
        MessageUtil.send(sock, reqMsg) # 클라이언트는 서버에 접속하자마자 파일 전송 요청 메세지를 보낸다.
        rspMsg = MessageUtil.receive(sock) # 그리고 서버의 응답을 받는다.

        if rspMsg.Header.MSGTYPE != message.REP_FILE_SEND:
            print("정상적인 서버 응답이 아닙니다.{0}".
                format(rspMsg.Header.MSGTYPE))
            exit(0)

        if rspMsg.Body.RESPONSE == message.DENIED:
            print("서버에서 파일 전송을 거부했습니다.")
            exit(0)

        with open(filepath, 'rb') as file: # 서버에서 전송 요청을 수락했다면, 파일을 열어 서버로 보낼 준비를 한다.
            totalRead = 0
            msgSeq = 0 #ushort
            fragmented = 0 #byte
            if filesize < CHUNK_SIZE:
                fragmented = message.NOT_FRAGMENTED
            else:
                fragmented = message.FRAGMENTED
    
            while totalRead < filesize:
                rbytes = file.read(CHUNK_SIZE)
                totalRead += len(rbytes)

                fileMsg = Message()            
                fileMsg.Body = BodyData(rbytes) # 모든 파일의 내용이 전송될 때까지 파일을 0x03 메세지에 담아 서버로 보낸다.

                header = Header(None)
                header.MSGID = msgId
                header.MSGTYPE = message.FILE_SEND_DATA
                header.BODYLEN = fileMsg.Body.GetSize()
                header.FRAGMENTED = fragmented
                if totalRead < filesize:
                    header.LASTMSG = message.NOT_LASTMSG
                else:
                    header.LASTMSG = message.LASTMSG

                header.SEQ = msgSeq
                msgSeq += 1
            
                fileMsg.Header = header
                print("#", end = '')

                MessageUtil.send(sock, fileMsg)

            print()

            rstMsg = MessageUtil.receive(sock) # 서버에서 파일을 제대로 받았는지에 대한 응답을 받는다.
                    
            result = rstMsg.Body
            print("파일 전송 성공 : {0}".
                format(result.RESULT == message.SUCCESS))

    except Exception as err:
        print("예외가 발생했습니다.")
        print(err)

    sock.close()    
    print("클라이언트를 종료합니다.")
```

## SQLite

### 데이터베이스에 대해

데이터베이스(Database)는 자료를 저장하고 저장된 자료를 다시 운용하기 위한 목적으로 구축된 시스템이다.

데이터베이스는 간단한 가계부에서부터 기업에서 사용하는 경영정보 시스템에 이르기까지 다양한 분야와 폭넓은 범위에 걸쳐 사용될 정도로 중요한 분야이다. 

### 데이터베이스의 역사

#### 태초에 '데이터'가 있었더라

사람들이 데이터베이스를 생각해 내기전, 아니 컴퓨터라는 기계를 생각해 내기 훨씬 이전부터 데이터는 존재했었다. 아주 옛날 진흙판에 동그라미를 찍어 수를 표시하던 것에서부터 종이를 이용하여 기록할 때까지, 그 매체는 다르지만 사람들은 데이터를 잃어버리지 않기 위해 끊임없이 기록을 해왔다.

#### 계층형/네트워크형 데이터베이스

늘어나는 데이터와 산업 전반에 걸쳐 거대해지는 시스템에 대응 하는 데이터 처리 방법을 연구하던 사람들은 '데이터 모델(Data Model)'이라는 도구를 사용하기 시작했고, 이것은 현실세계의 데이터를 다시 논리적으로 정의하고 표현하는 방법으로, 사람들은 이 기법을 통해 더욱 논리적인 데이터 베이스 시스템을 가질 수 있게 되었다. 이러한 모델링 기법을 이용한 초창기의 데이터베이스가 계층형, 네트워크형 데이터베이스이다!

#### 관계형 데이터베이스

현재 가장 일반적으로 사용되는 데이터베이스 시스템이다. 관계형 데이터베이스는 데이터의 구조를 테이블(Table), 즉 표의 형태로 구성한다. SQLite가 바로 이 관계형 데이터베이스에 해당한다.

### DBMS

DBMS(Database Management System)는 데이터베이스의 역할(데이터를 저장하고 이를 운용하게 하는 것)그 자체를 수행하는 소프트웨어를 말한다. Oracle, SQLServer 그리고 MySQL, 그리고 SQLite가 바로 이 DBMS이다.

#### 관계형 데이터베이스의 기본구조

관계형 데이터베이스는 데이터베이스가 여러 개의 테이블을 소유하는 형식으로 구성된다. 각 테이블은 실제 데이터를 담고 있는데, 데이터가 담기는 구조는 '표'형태로 이루어져 있다. 해당 표의 속성이 담긴 열은 '필드(field)'라고 하고, 실제 데이터를 이루는 각 행은 '레코드'라고 한다.

#### SQL 익히기

SQL은 데이터베이스와 테이블의 생성과 수정, 삭제 기능부터 데이터의 검색, 추가, 삭제, 수정 등의 데이터 처리 기능을 모두 수행할 수 있다.

#### 테이블의 생성: CREATE TABLE

레코드를 추가하고 조회하는 등의 작업을 하려면 테이블이 있어야 한다. 

CREATE TABLE문은 각 필드의 자료형과 크기 등으로 구성된 테이블의 구조(이것을 스키마(Schema)라고 한다)를 매개변수로 하여 테이블을 생성하며, 다음과 같은 형식으로 사용한다.

```
CREATE TABLE <테이블> ( 필드1 필드형식1, 필드2 필드형식2, ... )
```

#### 레코드 추가: INSERT 문

INSERT 문은 레코드를 테이블에 추가할 때 사용한다. 

```
INSERT INTO <테이블> ([필드1, 필드2, ...]) VALUE([데이터1, 데이터2, ...])
```

#### 레코드 조회: SELECT 문

SELECT 문의 기본적인 구조는 아래의 형식과 같다. 우리말로 해석하면 "<테이블>에서 <필드>를 선택하라."라는 뜻이 된다.

```
SELECT <필드> FROM <테이블>
```

#### WHERE: 특정 조건의 레코드에 대해 작업

WHERE 절은 SELECT 문에 조건을 한정하는 기능을 한다. WHERE 절은 아래와 같이 SELECT 문 뒤에 붙여서 사용한다. 

```
<SELECT 문 ...> WHERE <조건>
```

#### ORDER BY: 조회 결과의 정렬

ORDER BY 절은 조회 결과가 여러 레코드로 구성되어 있을 경우, 이를 특정한 기준으로 정렬해 준다. WHERE절과 마찬가지로 SELECT문 뒤에 붙여서 사용한다. 

```
sqlite> SELECT * FROM PHONEBOOK ORDER NAME ASC:
윤경한|010-1111-1111|zizou0812@gmail.com
윤경한1|010-1111-1111|zizou0812@gmail.com
윤경한2|010-1111-1111|zizou0812@gmail.com
```

#### 레코드 수정: UPDATE 문

UPDATE문은 테이블에 이미 존재하는 레코드의 특정 필드를 수정할 때 사용한다. 

```
UPDATE <테이블> Set [필드1]=[데이터1], [필드2]=[데이터2], ... WHERE [조건]
```

#### 레코드 삭제: DELETE 문

DELETE 문은 레코드를 삭제할 때 사용한다. DELETE문은 모든 SQL 구문 중에서 가장 간단하다고 할 수 있다. 

```
DELETE FROM <테이블> WHERE [조건]
```

#### SQLite의 파이썬 API

파이썬3에는 SQLite 라이브러리가 기본 탑재되어 있다. 다음과 같이 import문으로 sqlite3모듈을 반입하면 SQLite API를 사용할 준비가 끝난것이다. 

```
import sqlite3
```

#### 커넥션 열고 닫기

커넥션은 sqlite.connect() 함수를 이용해 생성한다. connect() 함수에는 데이터베이스 파일의 경로를 매개변수로 입력한다

```
import sqlite3

conn = sqlite3.connect('test.db') # 커넥션 열기 # test.db 파일이 있다면 그 파일을 열고, 그렇지 않다면 새로 만든다.

conn.close() # 커넥션 닫기 
```

#### 커서로 작업하기

커서는 커넥션 객체의 cursor() 메소드를 이용해서 얻을 수 있다. 

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor() # 커서 열기

cursor.close() # 커서 닫기
conn.close()
```

#### 테이블 생성 

다음은 test.db 파일안에 PHONEBOOK 테이블을 생성한다.

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE PHONEBOOK 
(NAME CHAR(32), PHONE CHAR(32), EMAIL CHAR(64) PRIMARY KEY)
""")

cursor.close()
conn.close()
```

#### 레코드 추가 

execute() 메소드는 매개변수 치환 기능을 지원한다. SQL문을 만들기 위해 일일히 문자열을 결합하는 대신 매개변수 치환 기능을 사용하면 읽기도 좋고 사용하기도 좋은 코드가 작성된다.

SQL 문자열에 매개변수를 치환할 부분에 ?를 넣어놓고 ?에 들어갈 매개변수를 튜플 안에 넣어 execute() 메소드의 매개변수로 넘기면 된다.

```
cursor.execute("""
INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL)
VALUE(?, ?, ?) # 이곳에 '윤경한' '010-111-1111', 'zizou0812@gmail.com'가 입력된다
""", ('윤경한', '010-111-1111', 'zizou0812@gmail.com'))
```

- 레코드의 추가, 수정, 삭제 등을 실행하고 난 뒤에는 반드시 Connection 객체의 commit() 함수를 불러줘야 한다. 그렇지 않으면 실제 데이터베이스 파일에는 아무 변경이 이루어지지 않는다. 이것은 SQLite가 데이터의 일관성(Consistency)을 위한 트랜젝션(Transaction)을 지원하기 때문이다. 

*ex) 레코드 예제*

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor()

cursor.execute("""
INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL) 
VALUES(?, ?, ?)
""", ('윤경한', '010-111-1111', 'zizou0812@gmail.com'))

id = cursor.lastrowid
print(id)

cursor.execute("""
INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL) 
VALUES(?, ?, ?)
""", ('윤경한1', '010-111-1111', 'zizou0812@gmail.com'))

id = cursor.lastrowid
print(id)

conn.commit()

cursor.close()
conn.close()
```

*ex) 실행 결과*

```
> insert_record.py
1
2
```

#### 레코드 조회

SELECT문을 실행한 후 결과를 얻어올 때는 커서 객체의 fetchone() 또는 fetchall() 메소드를 이용한다. fetchone() 메소드는 이름처럼 SELECT 실행 결과에서 레코드를 하나씩만 가져온다.

```
row = cursor.fetchone()
print(row)
```

반면에, fetchall() 메소드는 한 번에 모든 결과 레코드를 가져온다.

```
rows = cursor.fetchall()
for row in rows:
	print("NAME: {0}, PHONE: {1}, EMAIL: {2} ",
		format(row[0], row[1], row[2]))
```

*ex) SELECT문을 실행하고 결과를 출력하는 예*

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor()

cursor.execute("SELECT NAME, PHONE, EMAIL FROM PHONEBOOK")

rows = cursor.fetchall()
for row in rows:
   print ("NAME: {0}, PHONE: {1}, EMAIL: {2} ".
        format(row[0], row[1], row[2]))

cursor.close()
conn.close()
```

*ex) 실행 결과*

```
> select_record.py
NAME: 윤경한, PHONE: 010-111-1111, EMAIL: zizou0812@gmail.com
NAME: 윤경한1, PHONE: 010-111-1111, EMAIL: zizou0812@gmail.com
```

## 파이썬으로 이미지 요리하기

### 이미지 매직

이미지 매직(Image Magick)은 포토샵 같은 이미지 편집 소프트웨어 이다. GUI를 갖고 있는 포토샵과는 달리 이미지 매직은 명령 프롬프트에서 실행하는 것이 특징이다. 이미지 매직은 형식 변환, 이미지 회전, 도형 그리기, 텍스트 출력, 이미지간 합성, 이미지 자르기, 크기 변환 등등 이미지 편집에 필요한 다양한 기능을 제공한다. 

### Wand: 이미지 매직 파이썬 API 라이브러리

Wand는 깔끔한 인터페이스를 제공하는 이미지 매직용 파이썬 라이브러리이다.

#### Wand 설치 

```
> pip install Wand
```

#### Wand를 이용한 이미지 편집

Wand를 이용한 이미지 편집 프로그래밍도 관련 모듈을 코드에 반입하는 것으로 시작된다. 주로 사용할 모듈은 wand.image이다. 이 모듈 안에서도 특히 Image 클래스를 주로 사용한다.


| **기능**  | **메소드 이름**  |
|---|---|
| 파일 형식 바꾸기  | image.convert()  |
| 크기 바꾸기  | image.resize()  |
| 이미지 자르기  | 슬라이스 연산자.  |
| 이미지 회전  | image.retate()  |
| 이미지 뒤집기  | image.flip() # 상하 뒤집기, image.flop() # 좌우 뒤집기  |
| 이미지 명도, 채도, 색상 변경하기  | image.modulate()  |
| 이미지 합성  | image.composite()  |
| 워터 마크  | image.watermark()  |

- 이미지 도형이나 텍스트를 그려 넣을 때는 image.drawing 모듈의 Drawing 클래스도 함께 사용한다.

| **기능**  | **메소드 이름**  |
|---|---|
| 이미지에 텍스트와 도형 넣기  | Drawing.line(), Drawing.rectangle(), Drawing.text(), Drawing.draw()  |

#### 이미지 파일 형식 바꾸기

이미지 파일 형식을 바꿀 때에는 wand.Image 클래스의 convert() 메소드를 사용한다.

convert() 메소드는 새 이미지 형식의 이름을 매개변수로 입력받는다. 

#### 이미지 크기 바꾸기

이미지의 크기를 바꿀 때에는 resize() 메소드를 이용한다. resize() 메소드는 다음과 같이 재조정할 이미지의 너비와 높이를 매개변수로 입력받는다.

```
with Image(filename=original_path) as image:
	image.resize(100, 50) # 어떤 이미지건 너비 100, 높이 50으로 크기 변경
```

#### 이미지 자르기

이미지 자르기를 위한 슬라이스 연산자([])는 다음과 같이 사용하며, (x1, y1)과 (x2, y2) 좌표로 이루어지는 사각형 영역을 잘라낸다. 

```
cropped = image[x1:y1, x2:y2]
```

#### 이미지 회전 

이미지 회전은 Image 클래스의 rotate() 메소드를 이용한다. rotate()의 매개변수는 두 가지이다. 하나는 회전 각도이고 하나는 이미지를 회전시켰을 때 남는 공간에 채워넣을 색상이다.

```
rotated.rotate(degree, background=Color(bgcolor))
```

#### 이미지 뒤집기

이미지를 상하로 뒤집을 때는 flip() 메소드를, 좌우로 뒤집을 때는 flop() 메소드를 사용한다. 

```
with Image(filename=original_path) as image:
	image.flip() # 상하 뒤집기
	image.flop() # 좌우 뒤집기
```

#### 이미지에 텍스트와 도형 넣기

텍스트와 도형을 그려 넣을 때는 wand.drawing.Drawing 클래스의 도움이 필요하다. Drawing 클래스를 사용하는 방법은 먼저 wand.drawing 모듈부터 Drawing 클래스를 반입한다. Image 클래스도 반입해야 한다.

```
from wand.drawing import Drawing
from wand.image import Image
```

- 그 다음에는 Image와 Drawing의 인스턴스를 생성한다.

```
with Image(filename=original_path) as image:
	with Drawing() as draw:
```

#### 이미지의 명도, 채도, 색상 변경하기

모든 색은 명도, 채도, 색상 이렇게 세 가지 속성을 가진다.

*ex) test*


```
import sys
from wand.image import Image

if len(sys.argv) < 5:
    print('{0} <ORIGINAL PATH> <BRIGHTNESS> <SATURATION> <HUE>'
          .format(sys.argv[0]))
    sys.exit()

original_path = sys.argv[1]
brightness = float(sys.argv[2])
saturation = float(sys.argv[3])
hue = (float(sys.argv[4]) * 100 / 180 ) + 100 

with Image(filename=original_path) as image:
    with image.clone() as clone:
        clone.modulate(brightness, saturation, hue) 
        clone.save(filename= 'modulated_' + original_path)
```

#### 이미지 합성

이미지의 합성은 Image 객체의 composite() 메소드로 수행 가능하다. 

```
image1.composite(image2, 100, 100) # image1 위의 (100, 100) 위치에 image2를 합성
```

- 한쪽 이미지를 약간 투명하게 만들어서 더 자연스럽게 합성하고 싶다면, 이미지를 투명하게 만들 때에는 Image 객체의 transparentize() 메소드를 이용한다. transparentize() 메소드는 투명도를 0에서 1사이의 값으로 입력받는다.

- 다음과 같이 transparentize() 메소드에 0.7을 매개변수로 입력하여 호출하면 해당 이미지의 투명도를 70%로 변환한다.

```
image2.transparentize(0.7)
```

*ex) 두개의 이미지를 사용자로부터 입력받고 그 중 하나를 70% 투명도로 다른 이미지 위에 합성하는 예*

```
import sys
from wand.image import Image

if len(sys.argv) < 3:
    print('{0} <Image 1> <Image 2>'.format(sys.argv[0]))
    sys.exit()

image1_path = sys.argv[1]
image2_path = sys.argv[2]

with Image(filename=image1_path) as image1:
    with Image(filename=image2_path) as image2:
        with image1.clone() as clone:
            image2.transparentize(0.7)
            clone.composite(image2, 100, 100)
            clone.save(filename= image1_path + "_" + image2_path)
```

#### 워터마크

Image 클래스에는 composite() 메소드와 transparentize() 메소드의 기능을 한꺼번에 수행하는 메소드가 있는데, 바로 watermark()이다!

- watermark() 메소드의 첫 번째 매개변수는 합성할 Image 객체, 두 번째 매개변수는 투명도, 세 번째와 네 번째 매개변수는 각각 합성할 이미지의 x,y 좌표를 나타낸다.

*ex) watermark() 메소드 예*

```
import sys
from wand.image import Image

if len(sys.argv) < 3:
    print('{0} <Image 1> <Image 2>'.format(sys.argv[0]))
    sys.exit()

image1_path = sys.argv[1]
image2_path = sys.argv[2]

with Image(filename=image1_path) as image1:
    with Image(filename=image2_path) as image2:
        with image1.clone() as clone:
            clone.watermark(image2, 0.7, 100, 100)
            clone.save(filename= image1_path + "_" + image2_path)
```

## Pygame으로 게임 만들기!!!

### pygame 소개

pygame은 게임과 같은 멀티미디어 소프트웨어 개발을 위해 만들어진 파이썬 라이브러리이다. SDL(Simple DirectMedia Layer) 라이브러리를 기반으로 만들어진 pygame은 윈도우, 리눅스, 맥 등 다양한 운영체제를 지원하며, 조이스틱 입력, 그래픽 처리, 사운드 재생 등 다양한 기능을 탑재하고 있다.

#### pygame 라이브러리 설치

#### 게임 루프

게임 루프는 게임과 사용자 간의 지속적인 상호 작용을 하는 무한 루프이다. 게임이 자신의 상태를 화면에 표시하면 사용자는 표시된 상태에 따라 조이스틱이나 키보드 등을 이용해서 명령을 입력한다.

게임은 이렇게 입력된 명령을 처리하고 자신의 상태를 변경한 후, 다시 사용자에게 자신의 상태를 화면에 표시한다. 게임 루프는 시작부터 끝까지 이 과정을 지속적으로 반복한다.

반복 수행해야 하는 일을 정리하면 다음과 같다.

1. 사용자 입력 처리 : 사용자가 조이스틱, 키보드를 통해 입력한 명령을 처리한다.

2. 게임 상태 업데이트 : 주인공의 에너지, 총알 수, 위치, 적과의 충돌 여부 등을 갱신한다.

3. 게임 상태 그리기 : 2.에서 갱신된 내용을 화면에 그려 넣는다.

#### pygame을 사용하는 방법

pygame을 이용하는 게임 코드는 크게 다섯 부분으로 나뉜다.

1. pygame 관련 모듈 반입
2. pygame 초기화
3. 스크린 크기 설정
4. 게임 루프
5. pygame 관련 모듈 사용 자원 해제

- pygame 모듈을 반입하는 것으로 시작 

```
import pygame
```

- 모듈을 반입한 후에는 pygame에 관련된 다른 기능을 사용하기 전에 pygame.init() 메소드부터 호출해야 한다. 이 메소드가 하는 일은 반입된 모든 pygame 관련 모듈을 초기화 하는 것이다.

```
pygame.init()
```

- 그 다음에는 pygame.display.set_mode() 메소드를 호출하여 게임 스크린의 크기를 지정한다. 

```
screen = pygame.display.set_mode(400, 300))
```

- 게임 루프를 작성하기 전에 게임 루프의 주기를 결정할 pygame.time.Clock 객체를 생성한다.

```
clock = pygame.time.Clock()
```

- 게임 루프를 작성

```
while True:
	# 1) 사용자 입력을 처리
	# 2) 게임 상태 업데이트
	# 3) 게임 상태 그리기
	clock.tick(30)
```

- 사용자의 명령이나 게임 상태 업데이트에 의해서 게임 루프를 빠져 나오게 되면 어플리케이션이 종료되기 전에 다음과 같이 pygame.quit() 메소드를 호출한다. 

```
pygame.quit()
```

#### 처음 만들어보는 pygame 애플리케이션

*ex) 스크린의 색상이 완전히 빨간색이 되면 다시 하얀색이 되어 빨간색으로 변하기를 반복하는 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((400, 300)) 
pygame.display.set_caption("Hello, pygame!")

clock = pygame.time.Clock()
run = True
gb = [255, 255]

# Game Loop
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    # 2) 게임 논리 실행
    if gb[0] == 0:
        gb[0] = 255
        gb[1] = 255
    else:
        gb[0] -= 1
        gb[1] -= 1
   
    # 3) 게임 장면 그리기
    screen.fill(pygame.color.Color(255, gb[0], gb[1]))
    pygame.display.flip()
    
    clock.tick(60)

pygame.quit()
```

#### pygame에서의 사용자 입력 처리

pygame에서 사용자 입력 이벤트를 담당하는 모듈은 pygame.event이다. pygame.event.get() 함수는 게임의 이벤트 큐에 있는 모든 이벤트를 순서열로 만들어 반환한다.

```
events = pygame.event.get()
```

*ex) KEYDOWN, KEYUP + QUIT 이벤트 테스트의 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((300, 100)) 
pygame.display.set_caption("Keyboard Test")

clock = pygame.time.Clock()
run = True
key_status = ""
key = None

# 게임 루프
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        elif event.type == pygame.KEYDOWN:
            key_status = "Key Down"
            key = event.key
        elif event.type == pygame.KEYUP:
            key_status = "Key Up"
            key = event.key
            
    # 2) 게임 상태 업데이트
    
   
    # 3) 게임 상태 그리기
    screen.fill(pygame.color.Color(255, 255, 255))
    
    if key != None:
        pygame.display.set_caption(
            pygame.key.name(key) + " " + key_status)
    
    pygame.display.flip()    
    clock.tick(60)

pygame.quit()
```

스페이스 키가 눌러져 있는지를 알고 싶을 때는 다음과 같이 pygame.key.get_pressed() 함수가 반환한 튜플에 해당 키를 나타내는 상수(pygame.K_SPACE)을 첨자로 넘기면 된다.

```
keys = pygame.key.get_pressed()
if keys[pygame.K_SPACE]:
	print("스페이스 키 눌렀음")
```

*ex) 커서 키가 눌러져 있는지를 감시하고 현재 눌러져 있는 키의 이름을 출력하는 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((300, 100)) 
pygame.display.set_caption("Keyboard Test2")

clock = pygame.time.Clock()
run = True
key_status = ""
key = None

# 게임 루프
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
    # 누르고 있는 키 확인하기.
    keys = pygame.key.get_pressed() 
    if keys[pygame.K_LEFT]:
        print("LEFT")
    elif keys[pygame.K_RIGHT]:
        print("RIGHT")
    elif keys[pygame.K_UP]:
        print("UP")
    elif keys[pygame.K_DOWN]:
        print("DOWN")
        
    # 2) 게임 상태 업데이트    
   
    # 3) 게임 상태 그리기
    screen.fill(pygame.color.Color(255, 255, 255))
    
    if key != None:
        pygame.display.set_caption(
            pygame.key.name(key) + " " + key_status)
    
    pygame.display.flip()    
    clock.tick(60)

pygame.quit()
```

#### pygame으로 그리기

#### 텍스트 그리기

pygame으로 텍스트를 그릴 때는 pygame.font.SysFont 클래스를 이용한다. 

```
# 1) Sysfont 생성자에 폰트명과 크기를 입력

sf = pygame.font.SysFont("Monospace", 20)

# 2) SysFont.render 메소드가 하는 일은 텍스트를 그려넣은 Surface 객체를 반환하는 것.
#	이 메소드의 1번째 매개변수는 출력할 텍스트,
# 	2번째 매개변수는 안티알리아싱(Anti-aliasing) 여부,
# 	3번째 매개변수는 텍스트의 색상

text = sf.render("Hello, World", True, (0,0,255))

# 3) Surface.blit() 메소드는 다른 Surface 객체를 자신에게 그려넣는 일을 한다. 
# 	이 메소드의 1번째 매개변수는 그려넣을 Surface 객체, 
# 	2번째 매개변수에 해당 Surface 객체를 그려넣을 좌표

screen.blit(text, (10,10)) 
```	

#### 도형 그리기

pygame.draw 모듈에는 다양한 도형 그리기 함수가 있다. 

*ex) 도형 그리기의 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((300, 100)) 
pygame.display.set_caption("Drawing Shapes")

clock = pygame.time.Clock()
run = True
key = None
start_pos = [0, 0]

# 게임 루프
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        elif event.type == pygame.KEYDOWN:
            key = event.key
            
    # 2) 게임 상태 업데이트    
    if start_pos[0] > screen.get_width():
        start_pos[0] = 0
    else:
        start_pos[0] += 1
    
    # 3) 게임 상태 그리기
    screen.fill(pygame.color.Color(255, 255, 255))
    
    if key == pygame.K_1:
        pygame.draw.line(screen, 
            pygame.color.Color(0, 0, 0), 
            start_pos, 
            (screen.get_width(), screen.get_height()), 1)
    elif key == pygame.K_2:
        pygame.draw.ellipse(screen,
            pygame.color.Color(255, 0, 0), 
            pygame.Rect(start_pos, (50, 50)))
    elif key == pygame.K_3:
        pygame.draw.polygon(screen,
            pygame.color.Color(0, 255, 0), 
            [start_pos, 
             (0, screen.get_height()), 
             (screen.get_width(), screen.get_height())])
    elif key == pygame.K_4:
        pygame.draw.rect(screen,
            pygame.color.Color(0, 0, 255), 
            pygame.Rect(start_pos, (50, 50)))
    
    pygame.display.flip()    
    clock.tick(60)

pygame.quit()
```

#### 이미지 그리기

pygame.image.load() 함수는 이미지 파일을 읽어 들여 Surface 객체를 만들어 반환한다. 

```
# load() 함수는 이미지 파일로부터 Surface 객체를 반환
img = pygame.image.load("image.png")

# img 객체가 그려질 위치와 크기를 나타내는 pygame.Rect 객체를 반환.
rect = img.get_rect()

while True:
	screen.blit(img, rect) # Surface.blit() 메소드를 이용해 img 객체를 그린다.
```

#### pygame으로 오디오 재생하기

pygame.mixer.Sound 클래스는 오디오를 재생하는 기능을 가지고 있으며, OGG 또는 압축하지 않은 WAV 형식의 오디오 파일을 지원한다. 

```
# Sound 생성자에 오디오 파일 경로를 입력
fire_sound = pygame.mixer.Sound('fire.ogg')

# play() 메소드는 오디오 파일을 재생한다.
fire_sound.play()

# stop() 메소드는 오디오 파일의 재생을 중지시킨다.
fire_sound.stop()
```

### 스프라이트의 이해

스프라이트(Sprite)는 다른 이미지와 합성하기 위해 사용하는 이미지나 애니메이션을 말한다. "게임 화면 내에서 움직이는 물체"라고 생각해도 된다. 

- 스프라이트를 사용하면 더 작은 용량으로 더 작은 메모리로 객체의 상태 변화나 객체들 간의 충동 처리 등이 용이하게 구현 가능하다.

#### pygame.sprite.Sprite와 pygame.sprite.Group

다음은 Sprite 클래스가 제공하는 메소드의 목록이다.

| **메소드**  | **기능**  |
|---|---|
| update()  | 객체의 상태를 업데이트 한다.  |
| add()  | 스프라이트를 그룹에 추가한다.  |
| remove()  | 스프라이트를 그룹에서 제거한다.  |
| kill()  | 스프라이트가 속해 있는 모든 그룹에서부터 스프라이트를 제거한다.  |
| alive()  | 스프라이트가 한 그룹에라도 속해있는지의 여부를 반환한다.  |
| groups()  | 스프라이트가 속해 있는 모든 그룹을 반환한다.  |

- Sprite의 파생 클래스는 다음의 사항을 만족해야 한다.

1. 스프라이트 객체를 그룹에 추가하기 전에 Sprite.__init__() 메소드를 호출해야 한다.
2. pygame.Surface 형식의 image 데이터 속성을 할당해둬야 한다.
3. pygame.Rect 형식의 rect 데이터 속성을 할당해둬야 한다.
4. update() 메소드를 오버라이드 해야 한다.


다음의 예제에서는 Sprite 클래스의 상속 조건 4가지를 만족시키는 Runner 클래스를 정의한다. 

*ex) Sprite_Runner의 예*

```
import pygame
from pygame.color import Color
from pygame.sprite import Sprite
from pygame.surface import Surface

class Runner(Sprite):
    def __init__(self):
        Sprite.__init__(self)

        self.sprite_image = 'runnersprite.png'
        self.sprite_width = 70
        self.sprite_height = 100 
        self.sprite_sheet = pygame.image.load(
                                self.sprite_image).convert()
        self.sprite_columns = 14
        self.current_frame = 0
        self.image = Surface((self.sprite_width, self.sprite_height))

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
        self.rect = self.image.get_rect()
       
    def update(self):
        if self.current_frame == self.sprite_columns - 1:
            self.current_frame = 0
        else:
            self.current_frame += 1

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
```

*ex) 애니메이션 효과 연출의 예*

```
import pygame
from pygame.color import Color
from runner import Runner

FPS = 28

if __name__ == "__main__": 
    pygame.init()
 
    size = (400, 300)
    screen = pygame.display.set_mode(size) 
    pygame.display.set_caption("Runner Animation")
 
    run = True
    clock = pygame.time.Clock()

    background_img = pygame.image.load("background.png")
    
    runner1 = Runner()
    runner1.rect.x = 0
    runner1.rect.y = 170

    # 게임 루프
    while run:
        # 1) 사용자 입력 처리
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

        # 2) 게임 상태 업데이트      
        runner1.update()

        # 3) 게임 상태 그리기
        screen.blit(background_img, screen.get_rect())
        screen.blit(runner1.image, runner1.rect)
        pygame.display.flip()
 
        clock.tick(FPS)
        
    pygame.quit()
```

- Sprite 클래스는 pygame.sprite.Group 클래스와 함께 사용하도록 고안되었다. Group은 Sprite 객체의 컨테이너 기능을 하는 클래스이다. 

다음은 Group 클래스의 메소드 목록이다.

| **메소드**  | **기능**  |
|---|---|
| sprites()  | 이 그룹에 소속되어 있는 모든 스프라이트의 목록을 반환한다.  |
| copy()  | 그룹을 복사한다.  |
| add()  | 스프라이트를 그룹에 추가한다.  |
| remove()  | 스프라이트를 그룹에서 제거한다.  |
| has()  | 그룹이 특정 스프라이트를 갖고 있는지 확인한다.  |
| update()  | 그룹에 소속되어 있는 모든 스프라이트 객체의 update() 메소드를 호출한다.  |
| draw()  | 그룹에 소속되어 있는 각 스프라이트 객체의 image 데이터 속성과 rect 데이터 속성을 매개변수로 Surface.blit() 메소드를 호출한다.  |
| clear()  | 그룹이 갖고 있는 스프라이트 위로 배경을 그린다.  |
| empty()  | 모든 스프라이트를 그룹에서 제거한다.  |    


#### 스프라이트간의 충돌 처리

pygame.sprite.groupcollide() 함수는 스프라이트 그룹간의 충돌 여부를 평가하고, 충돌이 일어난 스프라이트 객체를 자동으로 그룹에서 제거해준다. 게다가 어떤 스프라이트에 충돌이 발생했는지를 dict 객체에 담아 출력해주기까지 한다.

```
while True: # 게임 루프
	collided = pygame.sprite.groupcollide(group1, group2, False, True)
	for item collide.items():
		print(item)
```

### 투석기 게임

#### 게임 컨셉 및 구조

이 문제는 16세기에 갈릴레오가 해결을 해주었다. 던져진 물체는 포물선 운동을 한다는 사실을 갈릴레오가 밝혀내고 이것을 이론으로 정리해놨기 때문이다.

- 포물선 운동 공식을 적용해야 한다.

#### 게임에 사용할 상수 정의

*ex) 상수 정의의 예*

```
g = 0.7
BASE_Y = 250

CATAPULT_READY = 0
CATAPULT_FIRE = 1

STONE_READY = 0
STONE_FLY = 1

MIN_POWER = 1
MAX_POWER = 20

MIN_DIRECTION = 20
MAX_DIRECTION = 85

GAME_INIT = 0
GAME_PLAY = 1
GAME_CLEAR = 2
GAME_OVER = 3
```

### 스프라이트 클래스 정의: 배경, 투석기, 돌, 외계인, 폭발

#### 게임에 사용할 스프라이트의 부모 클래스

Animation 클래스는 두 가지 메소드를 구현한다. 하나는 init_animation() 메소드로, 스프라이트 시트 파일을 읽어 들이고 FPS에 따른 프레임 변경 시간 등을 초기화한다. 

또 다른 하나는 calc_next_frame() 메소드이다. 이 메소드는 시간이 얼마나 지났는지를 보고 애니메이션 프레임을 전환할지를 결정한다.

*ex) Animation 클래스 구현의 예*

```
import pygame
from pygame import Surface
from pygame.color import Color
from pygame.sprite import Sprite

class Animation(Sprite):
    def init_animation(self):
        Sprite.__init__(self)

        self.sprite_sheet = pygame.image.load(self.sprite_image).convert()
        self.current_frame = 0
        self.image = Surface((self.sprite_width, self.sprite_height))

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
        self.rect = self.image.get_rect()        
        self.elapsed = pygame.time.get_ticks()
        self.threshold =  1000/self.fps
 
    def calc_next_frame(self):
       tick = pygame.time.get_ticks()
       if tick - self.elapsed > self.threshold:
           self.elapsed = tick
           if self.current_frame == self.sprite_columns:
               self.current_frame = 0
           else:
               self.current_frame += 1
```

#### Stone 스프라이트 클래스

Stone 스프라이트 클래스는 투석기가 던지는 돌을 표현한다. Stone 스프라이트 애니메이션의 각프레임 크기는 8픽셀이며 총 프레임의 수는 4개이다.

Stone 객체는 발사되기 전에는 STONE_READY 상태를 갖고 있다가, 사용자가 투석기에게 발사 명령을 내리면 setup() 메소드를 통해 초기 발사 파워(power), 발사각(direction), 발사 위치(initial_pos)를 객체에 저장한 후 상태를 STONE_FLY로 변경 한다. 

STONE_FLY 상태가 된 Stone 객체는 게임 루프가 호출하는 move() 메소드를 통해 외계인을 향해 날아간다. 이 때 Stone의 위치가 게임 화면을 벗어나면 상태를 다시 STONE_READY로 돌려 발사 준비 상태로 돌아간다. 

*ex) Stone 클래스의 구현의 예*

```
import math
import pygame
from pygame.color import Color
from animation import Animation
from const import *

class Stone(Animation):
    # STATE : STONE_READY -> STONE_FLY
    #           ^---------------|
    # READY일 때만 이동 가능
    # FIRE일 때는 아무것도 못함.
    def __init__(self):
        self.sprite_image = 'stone.png'
        self.sprite_width = 8
        self.sprite_height = 8
        self.sprite_columns = 4
        self.fps = 20
        self.state = STONE_READY
        self.init_animation()
               
    def update(self): 
        # 돌은 투석기가 발사한 이후부터 목표 또는 
        # 지면에 충돌할 때까지 날기만 하므로
        # 상태에 따른 스프라이트 정지 등은 필요 없음.
        self.calc_next_frame()
                
        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))

    def setup(self, initial_pos, power, direction):
        self.initial_pos = initial_pos
        self.rect.x = initial_pos[0]
        self.rect.y = initial_pos[1]
        self.power = power
        self.direction = direction
        self.state = STONE_FLY

    def move(self, time, space, decrement_stones):
        pos = self.calculate_position(time, g, self.direction)

        pos = self.map_position(
            self.initial_pos[0], self.initial_pos[1], 
            pos[0], pos[1])
        self.rect.x = pos[0]
        self.rect.y = pos[1]

        if pos[0] > space[0] or pos[1] > space[1]:
            self.state = STONE_READY
            decrement_stones()

    # 포탄 위치 계산
    def calculate_position(self, t, g, direction):
        r = math.radians(direction)
        x = self.power*math.cos(r)*t
        y = self.power*math.sin(r)*t - 0.5*g*math.pow(t, 2)

        return (int(x), int(y))

    # 포탄의 위치를 화면 좌표에 맞게 변환
    def map_position(self, x, y, new_x, new_y):
        return (x + new_x, y + (new_y*-1))
```

#### Catapult 스프라이트 클래스 정의

Catapult 클래스는 투석기를 앞/뒤로 이동시키는 forward()/backward() 메소드와 돌을 발사하는 fire() 메소드를 갖고 있다. fire() 메소드는 게임 루프로부터 발사 파워와 발사각을 입력 받아 데이터 속성에 저장하고 Catapult 객체의 상태를 CATAPULT_READY로 변경한다. 그 다음 update() 메소드가 호출될 때 이 상태를 확인하고 발사 애니메이션을 실행한다. 

발사 애니메이션의 끝에 도달하면 Catapult 객체의 상태는 다시 CATAPULT_READY로 돌아가고, stone 객체의 setup() 메소드를 호출함으로써 돌이 날아가도록 만든다. setup() 메소드를 호출받은 stone 객체의 상태는 STONE_FLY로 바뀌어 외계인을 향해 비행을 시작한다.    

*ex) Catapult 클래스 구현의 예*

```
import pygame
from pygame.color import Color
from animation import Animation
from stone import Stone
from const import *

class Catapult(Animation):
    # STATE : CATAPULT_READY -> CATAPULT_FIRE
    #           ^------|
    # READY일 때만 이동 가능
    # FIRE일 때는 아무것도 못함.
    def __init__(self, stone):
        self.sprite_image = 'catapult.png'
        self.sprite_width = 32
        self.sprite_height = 32
        self.sprite_columns = 5
        self.fps = 30
        self.stone = stone
        self.state = CATAPULT_READY
        self.init_animation()

    def update(self): 
        if self.state == CATAPULT_FIRE:
            self.calc_next_frame()

            if self.current_frame == self.sprite_columns:
                self.current_frame = 0
                # 돌멩이 날리기 시작
                self.state = CATAPULT_READY
                self.stone.setup(
                    (self.rect.x, self.rect.y), 
                    self.power, self.direction)
        else:
            self.current_frame = 0
                
        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))

    def forward(self):
        if self.rect.x < 100:
            self.rect.x += 1

    def backward(self):
        if self.rect.x > 0:
            self.rect.x -= 1

    def fire(self, power, direction):
        self.state = CATAPULT_FIRE
        self.power = power
        self.direction = direction
```

#### Alien 스프라이트 클래스 정의

Alien 클래스는 우리의 적인 외계인 스프라이트를 표현한다!

Alien 클래스는 숨 쉬는 것 말고는 특별한 기능을 갖고 있지 않다. 

*ex) Alien 클래스 구현의 예*

```
from pygame.color import Color
from animation import Animation

class Alien(Animation):
    def __init__(self):
        self.sprite_image = 'alien.png'
        self.sprite_width = 32
        self.sprite_height = 32
        self.sprite_columns = 3
        self.fps = 10
        self.init_animation()
               
    def update(self): 
        self.calc_next_frame()

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
```

#### Explosion 스프라이트 클래스 정의

Explosion 클래스는 폭발 애니메이션을 구현한다. 돌과 외계인이 충돌 했을 때 사용된다.

*ex) Explosion 클래스 구현의 예*

```
from pygame.color import Color
from animation import Animation

class Explosion(Animation):
    def __init__(self):
        self.sprite_image = 'explosionsprite.png'
        self.sprite_width = 100
        self.sprite_height = 100 
        self.sprite_columns = 25
        self.fps = 16
        self.init_animation()
       
    def update(self): 
        self.calc_next_frame()
        if self.current_frame == self.sprite_columns:
            self.current_frame = 0
            self.kill()
        
        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
```

#### 메인 모듈(게임 루프)


*ex) 메인 모듈 구현의 예*

```
import math
import pygame
from pygame import draw
from pygame.color import Color
from pygame.sprite import Sprite

from catapult import Catapult
from stone import Stone
from alien import Alien
from explosion import Explosion
from const import *

FPS = 60
stone_count = 3

def decrement_stones():
    global stone_count
    stone_count -= 1

class Background(Sprite):
    def __init__(self):        
        self.sprite_image = 'background.png'
        self.image = pygame.image.load(
                self.sprite_image).convert()
        self.rect = self.image.get_rect()
        self.rect.x = 0
        self.dx = 1

        Sprite.__init__(self)
        
    def update(self):
        self.rect.x -= self.dx
        if self.rect.x == -800:
            self.rect.x = 0

if __name__ == "__main__": 
    pygame.init()
 
    size = (400, 300)
    screen = pygame.display.set_mode(size)
 
    pygame.display.set_caption("Catapult VS Alien")
 
    run = True
    clock = pygame.time.Clock()
    t = 0
    fire_sound = pygame.mixer.Sound('fire.ogg')
    crash_sound = pygame.mixer.Sound('crash.ogg')

    power = 15
    direction = 45
    
    game_state = GAME_INIT
    background = Background()
    background_group = pygame.sprite.Group()
    background_group.add(background)
    
    stone = Stone() 
    stone.rect.y = -100   # 위치 변경
    stone_group = pygame.sprite.Group()
    stone_group.add(stone)

    catapult = Catapult(stone)    
    catapult.rect.x = 50 # 위치 변경                       
    catapult.rect.y = BASE_Y
    catapult_group = pygame.sprite.Group()
    catapult_group.add(catapult)

    alien = Alien()
    alien.rect.x = 350
    alien.rect.y = BASE_Y
    alien_group = pygame.sprite.Group()
    alien_group.add(alien)    

    explosion = Explosion()
    explosion_group = pygame.sprite.Group()
    explosion_group.add(explosion)

    # 게임 루프
    while run:
        # 1) 사용자 입력 처리
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
            elif event.type == pygame.KEYUP:
                if event.key == pygame.K_SPACE:
                    # 초기화면에서 스페이스를 입력하면 시작
                    if game_state == GAME_INIT: 
                        game_state = GAME_PLAY
                    elif game_state == GAME_PLAY: 
                        # GAME_PLAY 상태일 때 스페이스를 입력하면 발사
                        if stone.state == STONE_READY:
                            t = 0
                            catapult.fire(power, direction)
                            fire_sound.play()

        if game_state == GAME_PLAY:
            # 누르고 있는 키 확인하기.
            keys = pygame.key.get_pressed()  
            if keys[pygame.K_LEFT]:
                catapult.backward()
            elif keys[pygame.K_RIGHT]:
                catapult.forward()
            elif keys[pygame.K_UP]:
                if direction < MAX_DIRECTION:
                    direction += 1
            elif keys[pygame.K_DOWN]:
                if direction > MIN_DIRECTION:
                    direction -= 1    
            elif keys[pygame.K_SPACE]:
                if power > MAX_POWER:
                    power = MIN_POWER
                else:
                    power += 0.2

        # 2) 게임 상태 업데이트
        if stone.state == STONE_FLY:
            t += 0.5
            stone.move(t, 
                       (screen.get_width(), screen.get_height()), 
                       decrement_stones)
        
        if alien.alive():
            collided = pygame.sprite.groupcollide(
                        stone_group, alien_group, False, True)
            if collided:
                explosion.rect.x = \
                    (alien.rect.x + alien.rect.width/2) - \
                     explosion.rect.width/2
                explosion.rect.y = \
                    (alien.rect.y + alien.rect.height/2) - \
                    explosion.rect.height/2
                crash_sound.play()

        elif not explosion.alive(): 
            # 외계인도 죽고 폭발 애니메이션도 끝났을 때.
            game_state = GAME_CLEAR
       
        # 외계인이 살아 있는데 돌멩이 수가 0이면 게임 오버.
        if alien.alive() and stone_count == 0:
            game_state = GAME_OVER

        if game_state == GAME_PLAY: # 게임 객체 업데이트
            catapult_group.update()
            stone_group.update()
            alien_group.update()
        
        # 3) 게임 상태 그리기
        background_group.update()
        background_group.draw(screen)
                
        if game_state == GAME_INIT: 
            # 초기화면
            sf = pygame.font.SysFont("Arial", 20, bold=True)
            title_str = "Catapult VS Alien"
            title = sf.render(title_str, True, (255,0,0))
            title_size = sf.size(title_str)
            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)
            
            sub_title_str = "Press [Space] Key To Start"
            sub_title = sf.render(sub_title_str, True, (255,0,0))
            sub_title_size = sf.size(sub_title_str)
            sub_title_pos = (screen.get_width()/2 - sub_title_size[0]/2, 200)

            screen.blit(title, title_pos)
            screen.blit(sub_title, sub_title_pos)

        elif game_state == GAME_PLAY: 
            # 플레이 화면
            catapult_group.draw(screen)
            stone_group.draw(screen) 
            alien_group.draw(screen)

            # 파워와 각도를 선으로 표현.
            line_len = power*5 
            r = math.radians(direction)        
            pos1 = (catapult.rect.x+32, catapult.rect.y)
            pos2 = (pos1[0] + math.cos(r)*line_len, 
                    pos1[1] - math.sin(r)*line_len)
            draw.line(screen,Color(255, 0, 0), pos1, pos2)                 

            # 파워와 각도를 텍스트로 표현.
            sf = pygame.font.SysFont("Arial", 15)
            text = sf.render("{0} °, {1} m/s".
                             format(direction, int(power)), True, (0,0,0))
            screen.blit(text, pos2)

            # 돌의 개수를 표시
            sf = pygame.font.SysFont("Monospace", 20)
            text = sf.render("Stones : {0}".
                             format(stone_count), True, (0,0,255))
            screen.blit(text, (10, 10))

            if not alien.alive():
                explosion_group.update()
                explosion_group.draw(screen)

        elif game_state == GAME_CLEAR: 
            # 게임 클리어
            sf = pygame.font.SysFont("Arial", 20, bold=True)
            title_str = "Congratulations! Mission Complete"
            title = sf.render(title_str, True, (0,0,255))
            title_size = sf.size(title_str)
            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)
            screen.blit(title, title_pos)

        elif game_state == GAME_OVER: 
            # 게임 오버
            sf = pygame.font.SysFont("Arial", 20, bold=True)
            title_str = "Game Over"
            title = sf.render(title_str, True, (255,0,0))
            title_size = sf.size(title_str)
            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)
            screen.blit(title, title_pos)

        pygame.display.flip() 
        clock.tick(FPS)
 
    pygame.quit()
```

    
    
    
   	

	











		











    
    

    
    

    

    

    
	
	

    
	
	
	

	

	
	
	

	
	
	
	
	
    


	








 	

	





    

    

    
















































































































































