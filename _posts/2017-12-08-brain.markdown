---
layout: post
title:  "뇌를 자극하는 파이썬 3 - 파일에 데이터 읽고 쓰기 11 ~ 17"
date:   2017-12-08
author: Yoonkh
categories: Python
tags:	Python
comments: True
---



## 파일에 데이터 읽고 쓰기

### 열라, 읽으라(쓰라), 닫으라

애플리케이션이 디스크 같은 하드웨어를 직접 제어해 파일에 접근하는 경우는 거의 없다. 운영체제가 파일관리 업무를 담당하고 있기 때문에, 애플리케이션이 운영체제에게 API 함수를 통해 파일 처리를 의뢰하면 운영체제가 요청한 업무를 수행해주고, 그 결과를 애플리케이션에게 돌려준다. 

파일 열기 - 읽기/쓰기 - 닫기에 필요한 파이썬 함수는 다음과 같다.

```
1. 파일 열기 # file = open()

2. 파일 읽기/쓰기 # file.read()/file.write()

3. 파일 닫기 # file.close()
```

*ex) 파일에 데이터를 기록하는 프로그램 예*

```
file = open('test.txt', 'w')
file.write('hello')
file.close()
```

*ex) 실행 결과*

```
> write.py
```

*ex) 파일의 내용을 읽는 프로그램 예*

```
file = open('test.txt', 'r')
str = file.read()
print(str)
file.close()
```

*ex) 실행 결과*

```
> read.py
hello
```

#### 자원 누수 방지를 돕는 with ~ as

open() 함수와 함께 with ~ as 문을 사용하면 명시적으로 close() 함수를 호출하지 않아도 파일이 항상 닫힌다. with ~ as 문을 사용하는 방법은 다음과 같다. 

```
with open(파일이름) as 파일 객체: # "파일객체 = open(파일이름)"과 같다.
	# 코드 블록
	# 이곳에서 읽거나
	# 쓰기를 한 후
	# 그냥 코드를 빠져나가면 된다 # with문 덕분에 close()을 하지 않아도 된다.
```

#### with문의 비밀: 컨텍스트 매니저

아무 함수나 with절에 올 수 있는 것은 아니다. 컨텍스트 매니저(Context Manager)를 제공하는 함수여야 with문과 함께 사용할 수 있다. 

컨텍스트 매니저는 ```__enter__()```메소드와 ```__exit__()```메소드를 구현하고 있는 객체이다. with문은 컨텍스트 매니저를 획득한 후 코드 블록의 실행을 시작할 때 컨텍스트 매니저의 ```__enter__()```메소드를 호출하고, 코드블록이 끝날 때 ```__exit__()```를 호출한다. 

- ```__exit__()```메소드에 프로그래머들이 흔하게 잊곤 한느 자원 해제 코드를 구현해 놓으면 자원을 해제하는 명시적인 코드가 없어도 자원 획득/해제를 안전하게 처리할 수 있게 된다. (with문을 사용한다는 전제하)

```
with open('test.txt', 'r') as file: # 코드블록 시작하기 전에 컨텍스트 매니저 __exit__()호출
	s = file.read()
	print(s) # 컨텍스트 매니저 __exit__()호출
```

*ex) 컨텍스트 매니저 구현 예*

```
class open2(object):
    def __init__(self, path):
        print ('initialized')
        self.file = open(path)

    def __enter__(self):
        print ('entered')
        return self.file

    def __exit__(self, ext, exv, trb):
        print ("exited")
        self.file.close()
        return True

with open2("test.txt") as file:
    s = file.read()
    print(s)
```

*ex) 실행 결과*

```
> open2.py
initialized
entered
hello
exited
```

컨텍스트 매니저를 훨씬 간편하게 구현 할 수 있는 방법이 있다.

- 바로 @contextmanager 데코레이터를 이용하는 것이다.

@contextmanager 데코레이터는 ```__call__()```메소드는 물론이고, 컨텍스트 매니저 규약을 준수하는 데 필요한 ```__enter__()``` 메소드와 ```__exit__()``` 메소드를 모두 갖추고 있다. 

```
from contextlib import contextmanager # contextlib 모듈로부터 contextmanager를 반입

@contextmanager # @contextmanager 데코레이터로 함수 수식
def 함수이름():
	# 자원 획득
	try:
		yield 자원 # yield문을 통해 자원 반환: with문의 코드블록이 시작될 때 실행.
	finally:
		# 자원 해제 # with문의 코드블록이 종료될 때 실행된다.
```

- @contextmanager로 수식되는 함수의 구조에서 눈여겨봐야 할 곳은 크게 3가지이다.

1. try ~ finally 블록을 갖고 있다.

2. try 블록에서는 yield문을 통해 자원을 반환한다. 이때 yield문은 자신의 매개변수로 넘겨진 자원을 반환한 뒤 임시적으로 현재 함수의 실행을 정지시킨다. yield에 의해 정지된 함수는 with문의 코드블록 실행이 끝날 때 다시 실행된다. 

3. finally 블록에서 획득한 자원을 해제한다.

요약하면, @contextmanager로 수식하는 함수는 try 블록이 ```__enter__()``` 메소드의 역할을, finally 블록이 ```__exit__()``` 메소드의 역할을 수행한다고 할 수 있다.

#### open()함수 다시보기

컴퓨터가 다루는 모든 파일은 바이너리 파일이다. 바이너리 파일 중에서 텍스트 데이터만 기록하고 있는 파일을 텍스트 파일이라고 한다. open() 함수는 코드에서 입력되는 매개변수에 따라 텍스트 파일을 처리할 것인가 또는 바이너리 파일을 처리할 것인가를 결정한다.

- open() 함수는 모두 8개의 매개변수를 받아들인다. 이들 매개변수는 하나의 필수 매개변수과 일곱 개의 선택적 매개변수로 이루어져 있다. open() 함수의 반환값은 물론 파일 객체이다.

```
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closed=True, opener=None)
```

### 텍스트 파일 읽고/쓰기

#### 문자열을 담은 리스트를 파일에 쓰는 writelines() 메소드

writelines()는 문자열을 요소로 가지는 순서열 객체를 매개변수로 입력받아 해당 순서열 객체의 내용을 모두 파일에 기록한다.

```
lines = ["we'll find a way we always have - Interstellar\n", 
         "I'll find you and I'll kill you - Taken\n",
         "I'll be back - Terminator 2\n"]
         
with open('movie_quotes.txt', 'w') as file:
    file.writelines(lines)
```

*ex) 실행 결과*

```
> writelist.py

> type movie_quotes.txt
we'll find a way we always have - Interstellar
I'll find you and I'll kill you - Taken
I'll be back - Terminator 2
```

#### 2줄 단위로 텍스트를 읽는 readline()과 redlines() 메소드

*ex) readline() method 예*

```
with open('movie_quotes.txt', 'r') as file:    
    line = file.readline()
    
    while line != '': # readline() 메소드는 파일의 끝에 도달하면 ''를 반환한다. 그런데 실제로 빈 줄을 읽어 들였을 경우에는? 빈 줄을 읽어 들인 경우에는 개행 문자를 반환한다.
        print(line, end='')
        line = file.readline()
```

*ex) 실행 결과*

```
> readline.py
we'll find a way we always have - Interstellar
I'll find you and I'll kill you - Taken 
I'll be back - Terminator2
```

*ex) readlines() method 예*

```
with open('movie_quotes.txt', 'r') as file:    
    lines = file.readlines()
    
    line = ''
    for line in lines:
        print(line, end='')
```

*ex) 실행 결과*

```
> readlines.py
we'll find a way we always have - Interstellar
I'll find you and I'll kill you - Taken
I'll be back - Terminator 2
```

#### 문자 집합과 인코딩

컴퓨터의 발명, 발전이 미국의 학계와 기업을 중심으로 이루어지다 보니 문자 집합도 미국을 기준으로 제정되었고, 미국에서 제정된 ASCII는 1960년대에 제정된 문자 집합으로, 이후에 개발된 문자 집합들의 토대를 이루고 있다.

미국의 엔지니어들은 ASCII으로 행복하게 살아가고 있었지만, 다른나라의 사람들은 그렇지 못했다. 자국언어에서 사용해야 하는 문자들을 ASCII로는 표현 할 수가 없었다. 

그래서 미국 표준을 보완한 새로운 국제 표준이 등장했는데 그것이 ISO/IEC 8859-1이다.

이 표준 제정 이후 중앙 유럽어, 남유럽어, 북유럽어, 아랍어 등을 지원하는 ISO/IEC 8859-N 표준이 새로 제정 되었다.

- DBCS라는 2바이트(16비트)를 활용해서 문자 집합을 구성하는 방법으로 한글 문자 집합 표준도 만들어졌다.

	- KS X 1001, EUC-KR, CP949 등이 있다.

**문자 집합을 저장하고 표현하는 방법을 통일해서 문서와 소프트웨어를 작성하고 열람한다면 얼마나 좋을까?**

이런 배경에서 소프트웨어 회사들이 힘을 모아 유니코드 협회를 만들고 유니코드(Unicode)를 제정했다.

하지만 기존의 시스템을 추가하자 코드 포인트가 2바이트를 넘어서게 되었고, 새로운 문자를 위한 코드 포인트가 부족해지게 되었다.

- 이런 요구사항들을 충족시키려다보니 유니코드를 인코딩(부호화)하는 방법을 정의하는 표준이 필요해졌다.

	- UTF-7, UTF-8, UTF-16, UTF-32등이 바로 그것이다.

*UTF는 우리 말로 하면 변환 인코딩 형식(Unicode Transformation Format)이라고 하는데, 이 중에서 가장 많이 사용하는 것은 UTF-8이다!*

#### 바이너리 파일 다루기

파이썬에서 struct 모듈의 도움이 없이는 바이너리 파일을 제대로 다루기가 어렵다. struct 모듈은 일반 데이터 형식과 bytes 형식 사이의 변환을 수행하는 함수들을 담고 있다. 

*ex) struct 예*

```
>>> import struct 
>>> packed = struct.pack('i', 123) # pack() 함수는 첫 번째에 매개변수 1에 따라 4바이트 크기의 bytes 객체 packed를 준비하고 두 번째 매개변수를 bytes에 복사해 넣는다.
>>> for b in packed:  
    	print(b) # bytes 객체 packed의 각바이트에 있는 내용을 출력.
    	
123
0
0
0
>>> unpacked = struct.unpack('i', packed) 
>>> unpacked 
(123,)
>>> type(unpacked) # unpack() 함수는 튜플 형식을 반환한다.
<<class 'tuple'>>
```	

- struct.pack(), struct.unpack() 함수의 예는 형식 문자열을 'i'로만 지정했는데 이것은 '바이트 순서:시스템 기본값, 데이터 구조:4바이트 크기의 정수형식 1개'로 데이터를 반환하겠다는 뜻이다.

## 네트워크 프로그래밍

### 네트워크 프로그래밍에 앞서 알아둬야 할 기초

#### 인터넷의 유래

네트워크(Network)는 그물(Net)에서 파생된 단어로, 어떤 물건이나 사람 등의 상호 연결되어 있는 체계를 말한다. 보통 우리가 이야기하는 네트워크는 컴퓨터들이 상호 연결되어 있는 '컴퓨터 통신 네트워크'이다. 

냉전시대 미국은 소련과의 우주경쟁에서 뒤쳐졌다는 위기감에 DARPA라는 기관을 설립했다. DARPA의 각 연구기관에서는 컴퓨터를 이용해서 연구를 수행했고, 네트워크와 네트워크를 연결하는 새로운 구상을 하게 되었다. 이 방법을 이용하면 연구기관들을 잇는 회선을 일일히 구축하지 않고도 최소한의 비용으로 연구소들의 컴퓨터를 연결 할 수 있었다. 

*필요한 자료들을 '빛의 속도'로 획득할 수 있게 되었다*

**엄청난 혁신이었다**

- 이른바 DARPANET이라고 불리던 이 네트워크는 더 많은 대학과 연구기관으로, 또한 세계의 연구기관과 민간으로 연결되기 시작하더니 1980년대 말에 이르러서는 인터넷이라고하는 국제 통신망을 형성하게 되었다.

#### TCP/IP 스택

컴퓨터끼리 네트워크에서 데이터를 주고 받으려면 그 네트워크에서 통용되는 '프로토콜(Protocol)'을 따라야한다. 프로토콜은 규약, 규칙이라는 뜻의 낱말로써, 여기에서는 컴퓨터들이 네트워크를 통해 데이터를 주고받기 위한 '통신규약'을 말한다.

- TCP/IP는 다음과 같이 크게 네 개의 계층으로 구성되어 있으며, 한 계층 위에 다른 계층이 포개진 형태 때문에 이것을 TCP/IP 스택(stack)이라고 부르기도 한다.

| Application Layer  |
|---|
| Transport Layer  |
| Internet Layer  |
| Link Layer  |

- **단순해 보이는 이 네 단계의 프로토콜 모음이 오늘날 인터넷을 떠받치고 있다**

#### 링크 계층

TCP/IP는 네트워크의 물리적인 구성으로부터 독립적인 프로토콜이다. 컴퓨터가 네트워크에 전화전에 모뎀으로 연결되어 있든, LAN에 이더넷 케이블로  연결되어 있든, 혹은 와이파이에 연결되어 있든 전혀 신경 쓰지 않는다.

- 이것은 링크 계층에서 네트워크의 물리적인 연결 매체를 통해 패킷을 주고 받는 작업을 담당해주기 때문이다.

#### 인터넷 계층

인터넷 계층은 패킷을 수신해야 할 상대의 주소를 지정하고, 나가는 패킷에 대해서는 적절한 크기로 분할하며 들어오는 패킷에 대해서는 재조립을 수행한다! 이 계층에서 사용되는 규약이 바로 인터넷 프로토콜(Internet Protocol), 즉, IP이다. TCP/IP에서 IP가 바로 이것이다.

#### 전송 계층

전송 계층(Transport Layer)에는 이름 그대로 패킷의 '운송'을 담당하는 프로토콜들이 정의되어 있다. 그 중에서도 전송 제어 프로토콜(TCP, Transmission Control Protocol)는 송신측과 수신측 간의 연결성을 제공하며, 신뢰할 수 있는 패킷 전송 서비스를 제공한다. 여러 개의 패킷을 송신하는 경우 패킷 사이의 순서를 보장하며, 패킷이 유실되기라도 하면 재전송을 해주기까지 한다. TCP/IP 프로토콜에서 TCP가 바로 이 프로토콜을 가리키는 것이며, TCP는 IP가 제공하지 않는 연결성, 신뢰성을 제공한다. 웹 문서를 전달하는 기능을 하는 HTTP를 비롯한 수많은 응용 프로토콜들이 바로 이 TCP와 IP 프로토콜 위에서 동작한다.

#### 애플리케이션 계층

이 계층은 각 응용 프로그램 나름의 프로토콜들이 정의되는 곳이다. 웹 문서를 주고 받기 위한 HTTP, 파일 교환을 위한 FTP, 네트워크 관리를 위한 SNMP 등이 애플리케이션 계층에서 정의된 프로토콜의 대표적인 예이다. 애플리케이션의 계층의 프로토콜들은 전송 계층의 프로토콜 중 TCP에 기반할 수도 있고, UDP에 기반할 수도 있다. 

- HTTP와 FTP는 상대적으로 큰 데이터를 처리해야 하기 때문에 연결성과 신뢰성을 제공하는 TCP에 기반하고 있고, SNMP는 단순한 정보만을 다루는 데다 패킷을 일부 유실한다 해도 임무에 지장을 주지 않기 때문에 비용이 저렴한 UDP에 기반한다.

### TCP/IP의 주소 체계: IP 주소

우편 배달부가 우편물을 배달하기 위해서는 '주소'가 필요하다. 인터넷에서도 패킷을 배달하려면 이것을 어디에서 보냈는지, 또 어디로 보낼지에 대한 정보 즉 주소가 필요하다. 그리고 인터넷에서 사용하는 이 주소를 일컬어 'IP 주소(Address)'라고 부른다.

- 현재는 주소 고갈이 임박한 IPv4 체계에서 IPv6체계로 전환이 전 세계적으로 진행되고 있다.

### 포트

큰 빌딩은 대개 출입구가 여러 개 있다. O마트의 예를 보면 주차장 출입구만 해도 일반 고객 승용차와 수화물 차량 출입구가 나눠져 있고, 살마들이 드나드는 출입구도 여러 곳이 있다. 이 출입구를 통해 차도, 사람도, 물건도 드나든다.

컴퓨터도 네트워크 패킷이 드나들려면 '주소'뿐만아니라 출입문이 필요하다. 

이 출입문을 일컬어 포트(Port)라고 한다.

### TCP/IP의 동작 과정

TCP/IP는 서버/클라이언트 방식으로 동작한다. 통신을 수행하는 양단 중 한쪽에서는 한쪽에게 서비스를 제공해야 한다는 것이다. 서버/클라이언트 방식으로 만들어진 TCP/IP 서비스의 예를 들면, FTP서버와 FTP클라이언트, SMTP 메일 서버와 메일 클라이언트 등등 이들 모두가 TCP/IP 기반으로 만들어졌다.

### socket과 TCPServer를 이용한 TCP/IP 프로그래밍

파이썬의 라이브러리들이 공통으로 사용하는 라이브러리가 있다. 바로 socket 모듈이다.

socket 모듈은 TCP/IP, UDP/IP를 지원하는 버클리 소켓 인터페이스를 여러 가지 함수와 socket클래스를 통해 제공한다.

socket 클래스를 이용하면 거의 모든 인터넷 프로토콜을 구현할 수 있다는 장점이 있는 반면, 익히고 사용하기가 간단하지 않다는 단점도 있다.

| **클래스**  	| **메소드**  	| **설명**  	|
|---	|---	|---	|
| TCPServer  	| serve_forever()  	| 클라이언트의 접속 요청을 수신 대기한다. 접속 요청이 있을 경우 수락하고 BaseRequestHandler의 handler() 메소드를 호출한다.  	|
| BaseRequestHandler  	| handler()  	| 클라이언트 접속 요청을 처리한다.  	|
| socket  	| connect()  	| 서버에 접속 요청을 한다.  	|
|  	| send()  	| 데이터를 상대방에게 전송한다.  	|
|  	| recv()  	| 데이터를 수신한다.  	|

*ex) TCPServer와 BaseRequestHandler와 socket 클래스의 사용법 예*

```
class MyTCPHandler(socketserver.BaseRequestHandler):
	def handle(self):
		print(self.client_address[0]) # 클라이언트의 IP주소 출력
		buffer = self.request.recv(1024).strip() # 데이터 수신
		self.request.send (buffer) # 데이터 송신
```

- BaseRequestHandler로부터 상속을 받은 MyTCPHandler는 handle() 메소드를 재정의한다. handle() 메소드는 클라이언트의 연결 요청을 서버가 수락했을 때 호출된다. 다시 말하면 handle() 메소드가 호출되었다는 것은 통신을 수행할 준비가 됐다는 것이다!

*ex) 클라이언트가 보내오는 메세지를 서버가 그대로 '메아리'쳐 돌려보내는 프로그램 예*

```
import socketserver
import sys

class MyTCPHandler(socketserver.BaseRequestHandler):
    def handle(self):
        print('클라이언트 접속 : {0}'.format(self.client_address[0]))
        sock = self.request
        
        rbuff  = sock.recv(1024) # 데이터를 수신하고 그 결과를 rbuff에 담는다. rbuff는 bytes 형식이다.
        received = str(rbuff, encoding="utf-8")
        print('수신 : {0}'.format(received))
        
        # 수신한 데이터를 그대로 돌려보냄.
        sock.send(rbuff) # 수신한 데이터를 그대로 클라이언트에게 다시 송신한다.
        print('송신 : {0}'.format(received))
        sock.close()

if __name__ == '__main__':

    if len(sys.argv) < 2:
        print('{0} <Bind IP>'.format(sys.argv[0]))
        sys.exit()
        
    bindIP = sys.argv[1]
    bindPort = 5425 # 

    server = socketserver.TCPServer((bindIP, bindPort), MyTCPHandler)
    
    print('메아리 서버 시작...')
    server.serve_forever() # 클라이언트로부터 접속 요청을 받아들일 준비를 한다.
```

*ex) 메아리 클라이언트 예*

```
import socket
import sys

if __name__ == '__main__':
    
    if len(sys.argv) < 4:
        print("{0} <Bind IP> <Server IP> <Message>".format(sys.argv[0]))
        sys.exit()
        
    bindIP = sys.argv[1]
    serverIP = sys.argv[2]
    message = sys.argv[3]

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # SOCK_STREAM = TCP socket 
    sock.bind((bindIP, 0))

    try:
        sock.connect((serverIP, 5425)) # 연결 요청을 수행한다.
        
        # 메아리 송신
        sbuff = bytes(message, encoding="utf-8")
        sock.send(sbuff) # 메세지를 송신한다.
        print("송신 : {0}".format(message))

        # 메아리 수신
        rbuff = sock.recv(1024) # 메세지를 수신한다.
        received = str(rbuff, encoding="utf-8")
        print("수신 : {0}".format(received))
    finally:
        sock.close()
```

#### 흐르는 패킷

TCP 프로토콜은 연결 지향, 흐름 지향 프로토콜이다. 전기처럼 양쪽이 연결되어 있어야 하고 보내는 쪽에서 받는 쪽으로 패킷을 흘려 보낸다. 

하지만 TCP 프로토콜은 전기와 달리 흐름 속에서 각 개별 패킷의 경계를 구분해야 한다. 시작이 어디고 끝이 어디인지를 파악해야 한다.

### 프로토콜 설계와 네트워크 애플리케이션 프로그래밍 예제

#### 파일 업로드 프로토콜

파일 업로드 프로토콜(FUP)은 헤더와 바디의 두 부분으로 나뉜다. 바디에는 실제로 전달하고자 하는 데이터를 담고, 헤더에는 본문 길이를 비롯해 메세지의 속성 몇 가지를 담는다. 바디의 길이는 담는 데이터에 따라 달라지지만 헤더의 길이는 16바이트로 항상 일정하다. 따라서 수신한 패킷을 분석할 때는 가장 먼저 16바이트를 먼저 확인해서 (바디의 길이를 포함한) 메세지의 속성을 확인하고, 그 다음에 바디의 길이 만큼을 또 읽어 하나의 메세지 끝을 끊어내야 한다.

#### 파일 업로드 서버와 클라이언트 구현

예제 프로그램의 구현은 세 가지 부분으로 나눠서 진행한다.

- 서버/클라이언트 공용 모듈 구현

- 서버 구현

- 클라이언트 구현

**서버/클라이언트가 같이 사용할 모듈 만들기**

```
REQ_FILE_SEND  = 0x01 # 메세지 타입 상수 정의
REP_FILE_SEND  = 0x02
FILE_SEND_DATA = 0x03
FILE_SEND_RES  = 0x04

NOT_FRAGMENTED = 0x00 # 파일 분할 여부 상수 정의
FRAGMENTED = 0x01

NOT_LASTMSG = 0x00 # 분할된 메세지의 마지막 여부 상수 정의
LASTMSG = 0x01

ACCEPTED = 0x00 # 파일 전송 수락 여부 상수 정의
DENIED = 0x01

FAIL = 0x00 # 파일 전송 성공 여부 상수 정의
SUCCESS = 0x01

class ISerializable:
    def GetBytes(self): # 메세지, 헤더, 바디는 모두 이 클래스를 상속한다. 즉, 이들은 자신의 데이터를 바이트 배열로 변환하고 그 바이트 배열의 크기를 반환해야 한다.
        pass

    def GetSize():
        pass

class Message(ISerializable):
    def __init__(self):
        self.Header = ISerializable()
        self.Body = ISerializable()
        
    def GetBytes(self):
        buffer = bytes(self.GetSize())

        header = self.Header.GetBytes()
        body = self.Body.GetBytes()

        return header + body

    def GetSize(self):
        return self.Header.GetSize() + self.Body.GetSize()
```

- 메세지의 헤더

```
from message import ISerializable
import struct

class Header(ISerializable):
    def __init__(self, buffer):
        self.struct_fmt = '=3I2BH' # 3 unsigned int, 2 byte, 1 unsigned short
        self.struct_len = struct.calcsize(self.struct_fmt)

        if buffer != None:            
            unpacked = struct.unpack(self.struct_fmt, buffer)

            self.MSGID = unpacked[0]
            self.MSGTYPE = unpacked[1]
            self.BODYLEN = unpacked[2]
            self.FRAGMENTED = unpacked[3]
            self.LASTMSG = unpacked[4]
            self.SEQ = unpacked[5]

    def GetBytes(self):
        return struct.pack(
            self.struct_fmt, 
            *( 
                self.MSGID,
                self.MSGTYPE,
                self.BODYLEN,
                self.FRAGMENTED,
                self.LASTMSG,
                self.SEQ
            ))

    def GetSize(self):
        return self.struct_len
```

- 메세지 본문(body)를 표현하는 클래스

```
from message import ISerializable
import message
import struct

class BodyRequest(ISerializable): # 파일 전송 요청 메세지(0x01)에 사용할 본문 클래스이다. FILESIZE와 FILENAME 데이터 속성을 갖는다.
    def __init__(self, buffer):
        if buffer != None:
            slen = len(buffer)
            
            # 1 unsigned long long, N character
            self.struct_fmt = str.format('=Q{0}s', slen-8) 
            self.struct_len = struct.calcsize(self.struct_fmt)
            if slen > 4: # unsigned long long의 크기
                slen = slen - 4
            else:
                slen = 0

            unpacked = struct.unpack(self.struct_fmt, buffer)

            self.FILESIZE = unpacked[0]
            self.FILENAME = unpacked[1].decode(
                encoding='utf-8').replace('\x00', '')
        else:
            self.struct_fmt = str.format('=Q{0}s', 0)
            self.struct_len = struct.calcsize(self.struct_fmt)
            self.FILESIZE = 0
            self.FILENAME = ''


    def GetBytes(self):
        buffer = self.FILENAME.encode(encoding='utf-8')
        
        # 1 unsigned long long, N character
        self.struct_fmt = str.format('=Q{0}s', len(buffer)) 
        
        return struct.pack(
            self.struct_fmt, 
            *( 
                self.FILESIZE,
                buffer
            ))

    def GetSize(self):
        buffer = self.FILENAME.encode(encoding='utf-8')
        
        # 1 unsigned long long, N character
        self.struct_fmt = str.format('=Q{0}s', len(buffer)) 
        self.struct_len = struct.calcsize(self.struct_fmt)
        return self.struct_len

class BodyResponse(ISerializable): # 파일 전송 요청에 대한 응답 메세지(0x02)에 사용할 본문 클래스이다. 요청 메세지의 MSGID와 수락 여부를 나타내는 RESPONSE 데이터 속성을 갖는다.
    def __init__(self, buffer):
    
        # 1 unsigned int, Byte
        self.struct_fmt = '=IB' 
        self.struct_len = struct.calcsize(self.struct_fmt)

        if buffer != None:
            unpacked = struct.unpack(self.struct_fmt, buffer)

            self.MSGID = unpacked[0]
            self.RESPONSE = unpacked[1]
        else:
            self.MSGID = 0
            self.RESPONSE = message.DENIED

    def GetBytes(self):
        return struct.pack(
            self.struct_fmt, 
            *( 
                self.MSGID,
                self.RESPONSE
            ))

    def GetSize(self):
        return self.struct_len
        
class BodyData(ISerializable): # 실제 파일을 전송하는 메세지(0x03)에 사용할 본문 클래스이다. 앞서 프로토콜 정의에서 언급되었던 것처럼 DATA 필드만 갖고 있다.
    def __init__(self, buffer):
        if buffer != None:
            self.DATA = buffer

    def GetBytes(self):
        return self.DATA

    def GetSize(self):
        return len(self.DATA)

class BodyResult(ISerializable): # 파일 전송 결과 메세지, 메세지(0x04)에 사용할 본문 클래스이다. 요청 메세지의 MSGID와 성공 여부를 나타내는 RESULT 데이터 속성을 갖는다.
    def __init__(self, buffer):
        
        # 1 unsigned int, Byte
        self.struct_fmt = '=IB' 
        self.struct_len = struct.calcsize(self.struct_fmt)
        if buffer != None:
            unpacked = struct.unpack(self.struct_fmt, buffer)
            self.MSGID = unpacked[0]
            self.RESULT = unpacked[1]
        else:
            self.MSGID = 0
            self.RESULT = message.FAIL

    def GetBytes(self):
        return struct.pack(
            self.struct_fmt,
            *( 
                self.MSGID,
                self.RESULT
            ))

    def GetSize(self):
        return self.struct_len
```

- MessageUtil 클래스의 구현

```
import socket

import message
from message import Message
from message_header import Header
from message_body import BodyRequest
from message_body import BodyResponse
from message_body import BodyData
from message_body import BodyResult


class MessageUtil:
    @staticmethod
    def send(sock, msg): # send() 메소드는 msg 매개변수가 담고 있는 모든 바이트를 내보낼 때까지 반복해서 socket.send() 메소드를 호출한다.
        sent = 0
        buffer = msg.GetBytes()
        while sent < msg.GetSize():            
            sent += sock.send(buffer)

    @staticmethod
    def receive(sock):
        totalRecv = 0
        sizeToRead = 16 # 헤더의 크기
        hBuffer = bytes() # 헤더 버퍼

        # 헤더 읽기
        while sizeToRead > 0: # 첫 반복문에서는 스트림으로부터 메세지 헤더의 경계를 끊어낸다.            
            buffer = sock.recv(sizeToRead)
            if len(buffer) == 0:
                return None

            hBuffer += buffer
            totalRecv += len(buffer)
            sizeToRead -= len(buffer)

        header = Header(hBuffer)

        totalRecv = 0
        bBuffer = bytes()
        sizeToRead = header.BODYLEN

        while sizeToRead > 0: # 첫 반복문에서 얻은 헤더에서 본문의 길이를 뽑아내어 그 길이만큼 다시 스트림으로부터 본문을 읽는다.
            buffer = sock.recv(sizeToRead)
            if len(buffer) == 0:
                return None

            bBuffer += buffer
            totalRecv += len(buffer)
            sizeToRead -= len(buffer)

        body = None

        if header.MSGTYPE == message.REQ_FILE_SEND:
            body = BodyRequest(bBuffer)
        elif header.MSGTYPE == message.REP_FILE_SEND:
            body = BodyResponse(bBuffer)
        elif header.MSGTYPE == message.FILE_SEND_DATA:
            body = BodyData(bBuffer)
        elif header.MSGTYPE == message.FILE_SEND_RES:
            body = BodyResult(bBuffer)
        else:
            raise Exception(                     
                    "Unknown MSGTYPE : {0}".
                    format(header.MSGTYPE))

        msg = Message()
        msg.Header = header
        msg.Body = body
            
        return msg
```

- 파일 업로드 서버의 구현

```
import os
import sys
import socket
import socketserver
import struct

import message
from message import Message

from message_header import Header
from message_body import BodyData
from message_body import BodyRequest
from message_body import BodyResponse
from message_body import BodyResult

from message_util import MessageUtil

CHUNK_SIZE = 4096
upload_dir = ''

class FileReceiveHandler(socketserver.BaseRequestHandler):
    def handle(self):
        print("클라이언트 접속 : {0}".format(self.client_address[0]))

        client = self.request # client socket

        reqMsg = MessageUtil.receive(client) # 클라이언트가 보내온 파일 전송 요청 메세지를 수신한다.

        if reqMsg.Header.MSGTYPE != message.REQ_FILE_SEND:
            client.close()
            return

        reqBody = BodyRequest(None)

        print(
            "파일 업로드 요청이 왔습니다. 수락하시겠습니까? yes/no")
        answer = sys.stdin.readline()

        rspMsg = Message()
        rspMsg.Body = BodyResponse(None)
        rspMsg.Body.MSGID = reqMsg.Header.MSGID
        rspMsg.Body.RESPONSE = message.ACCEPTED

        rspMsg.Header = Header(None)

        msgId = 0
        rspMsg.Header.MSGID = msgId
        msgId = msgId + 1
        rspMsg.Header.MSGTYPE = message.REP_FILE_SEND
        rspMsg.Header.BODYLEN = rspMsg.Body.GetSize()
        rspMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED
        rspMsg.Header.LASTMSG = message.LASTMSG
        rspMsg.Header.SEQ = 0

        if answer.strip() != "yes": # 사용자가 'yes'가 아닌 답을 입력하면 클라이언트에게 '거부'응답을 보낸다.
            rspMsg.Body = BodyResponse(None)
            rspMsg.Body.MSGID = reqMsg.Header.MSGID
            rspMsg.Body.RESPONSE = message.DENIED
        
            MessageUtil.send(client, rspMsg)
            client.close()
            return
        else:
            MessageUtil.send(client, rspMsg) # 물론'yes'를 입력하면 클라이언트에게 '승낙'응답을 보낸다.

            print("파일 전송을 시작합니다...")

            fileSize = reqMsg.Body.FILESIZE
            fileName = reqMsg.Body.FILENAME
            recvFileSize = 0 
            with open(upload_dir + "\\" + fileName, 'wb') as file: # 업로드 받을 파일을 생성한다.
                dataMsgId = -1
                prevSeq = 0
                
                while True:
                    reqMsg = MessageUtil.receive(client)
                    if reqMsg == None:
                        break

                    print("#", end='')
                    
                    if reqMsg.Header.MSGTYPE != message.FILE_SEND_DATA:
                        break

                    if dataMsgId == -1:
                        dataMsgId = reqMsg.Header.MSGID
                    elif dataMsgId != reqMsg.Header.MSGID:
                        break                    

                    if prevSeq != reqMsg.Header.SEQ: # 메세지 순서가 어긋나면 전송을 중단한다.
                        print("{0}, {1}".format(prevSeq, reqMsg.Header.SEQ))
                        break
                    
                    prevSeq += 1

                    recvFileSize += reqMsg.Body.GetSize() # 전송받은 파일의 일부를 담고 있는 bytes 객체를 서버에서 생성한 파일에 기록한다.
                    file.write(reqMsg.Body.GetBytes())

                    if reqMsg.Header.LASTMSG == message.LASTMSG: # 마지막 메세지만 반복문을 빠져나온다.
                        break
               
                file.close()

                print()
                print("수신 파일 크기 : {0} bytes".format(recvFileSize))

                rstMsg = Message()
                rstMsg.Body = BodyResult(None)
                rstMsg.Body.MSGID = reqMsg.Header.MSGID
                rstMsg.Body.RESULT = message.SUCCESS
                
                rstMsg.Header = Header(None)
                rstMsg.Header.MSGID = msgId
                msgId += 1
                rstMsg.Header.MSGTYPE = message.FILE_SEND_RES
                rstMsg.Header.BODYLEN = rstMsg.Body.GetSize()
                rstMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED
                rstMsg.Header.LASTMSG = message.LASTMSG
                rstMsg.Header.SEQ = 0

                if fileSize == recvFileSize: # 파일 전송 요청에 담겨온 파일 크기와 실제로 받은 파일의 크기를 비교하여 같으면 성공 메세지를 보낸다.
                    MessageUtil.send(client, rstMsg)
                else:
                    rstMsg.Body = BodyResult(None)
                    rstMsg.Body.MSGID = reqMsg.Header.MSGID
                    rstMsg.Body.RESULT = message.FAIL
                    MessageUtil.send(client, rstMsg) # 파일 크기에 이상이 있다면 실패 메세지를 보낸다.

            print("파일 전송을 마쳤습니다.")                
            client.close()

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("사용법 : {0} <Directory>".format(sys.argv[0]))
        sys.exit(0)

    upload_dir = sys.argv[1]
    if os.path.isdir(upload_dir) == False:
        os.mkdir(upload_dir)
         
    bindPort = 5425
    server = None
    try:
        server = socketserver.TCPServer(
            ('', bindPort), FileReceiveHandler)
            
        print("파일 업로드 서버 시작...")
        server.serve_forever()
    except Exception as err:
        print(err)

    print("서버를 종료합니다.")
```
    
- 클라이언트의 구현

```
import os
import sys
import socket
import struct

import message
from message import Message

from message_header import Header
from message_body import BodyData
from message_body import BodyRequest
from message_body import BodyResponse
from message_body import BodyResult

from message_util import MessageUtil

CHUNK_SIZE = 4096

if   __name__ == '__main__':
    if len(sys.argv) < 3:
        print("사용법 : {0} <Server IP> <File Path>".
              format(sys.argv[0]))
        sys.exit(0)

    serverIp   = sys.argv[1]
    serverPort = 5425
    filepath   = sys.argv[2]
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # TCP 소켓을 생성한다.
        
    try:
        print("서버:{0}/{1}".format(serverIp, serverPort))        
    
        sock.connect((serverIp, serverPort)) # 접속 요청을 수락한다.

        msgId = 0

        reqMsg = Message()        
        filesize = os.path.getsize(filepath)
        reqMsg.Body = BodyRequest(None)
        reqMsg.Body.FILESIZE = filesize
        reqMsg.Body.FILENAME = filepath[filepath.rindex('\\')+1:]
    
        msgId += 1
        reqMsg.Header = Header(None)
        reqMsg.Header.MSGID = msgId
        reqMsg.Header.MSGTYPE = message.REQ_FILE_SEND
        reqMsg.Header.BODYLEN = reqMsg.Body.GetSize()
        reqMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED
        reqMsg.Header.LASTMSG = message.LASTMSG
        reqMsg.Header.SEQ = 0
          
        MessageUtil.send(sock, reqMsg) # 클라이언트는 서버에 접속하자마자 파일 전송 요청 메세지를 보낸다.
        rspMsg = MessageUtil.receive(sock) # 그리고 서버의 응답을 받는다.

        if rspMsg.Header.MSGTYPE != message.REP_FILE_SEND:
            print("정상적인 서버 응답이 아닙니다.{0}".
                format(rspMsg.Header.MSGTYPE))
            exit(0)

        if rspMsg.Body.RESPONSE == message.DENIED:
            print("서버에서 파일 전송을 거부했습니다.")
            exit(0)

        with open(filepath, 'rb') as file: # 서버에서 전송 요청을 수락했다면, 파일을 열어 서버로 보낼 준비를 한다.
            totalRead = 0
            msgSeq = 0 #ushort
            fragmented = 0 #byte
            if filesize < CHUNK_SIZE:
                fragmented = message.NOT_FRAGMENTED
            else:
                fragmented = message.FRAGMENTED
    
            while totalRead < filesize:
                rbytes = file.read(CHUNK_SIZE)
                totalRead += len(rbytes)

                fileMsg = Message()            
                fileMsg.Body = BodyData(rbytes) # 모든 파일의 내용이 전송될 때까지 파일을 0x03 메세지에 담아 서버로 보낸다.

                header = Header(None)
                header.MSGID = msgId
                header.MSGTYPE = message.FILE_SEND_DATA
                header.BODYLEN = fileMsg.Body.GetSize()
                header.FRAGMENTED = fragmented
                if totalRead < filesize:
                    header.LASTMSG = message.NOT_LASTMSG
                else:
                    header.LASTMSG = message.LASTMSG

                header.SEQ = msgSeq
                msgSeq += 1
            
                fileMsg.Header = header
                print("#", end = '')

                MessageUtil.send(sock, fileMsg)

            print()

            rstMsg = MessageUtil.receive(sock) # 서버에서 파일을 제대로 받았는지에 대한 응답을 받는다.
                    
            result = rstMsg.Body
            print("파일 전송 성공 : {0}".
                format(result.RESULT == message.SUCCESS))

    except Exception as err:
        print("예외가 발생했습니다.")
        print(err)

    sock.close()    
    print("클라이언트를 종료합니다.")
```

## SQLite

### 데이터베이스에 대해

데이터베이스(Database)는 자료를 저장하고 저장된 자료를 다시 운용하기 위한 목적으로 구축된 시스템이다.

데이터베이스는 간단한 가계부에서부터 기업에서 사용하는 경영정보 시스템에 이르기까지 다양한 분야와 폭넓은 범위에 걸쳐 사용될 정도로 중요한 분야이다. 

### 데이터베이스의 역사

#### 태초에 '데이터'가 있었더라

사람들이 데이터베이스를 생각해 내기전, 아니 컴퓨터라는 기계를 생각해 내기 훨씬 이전부터 데이터는 존재했었다. 아주 옛날 진흙판에 동그라미를 찍어 수를 표시하던 것에서부터 종이를 이용하여 기록할 때까지, 그 매체는 다르지만 사람들은 데이터를 잃어버리지 않기 위해 끊임없이 기록을 해왔다.

#### 계층형/네트워크형 데이터베이스

늘어나는 데이터와 산업 전반에 걸쳐 거대해지는 시스템에 대응 하는 데이터 처리 방법을 연구하던 사람들은 '데이터 모델(Data Model)'이라는 도구를 사용하기 시작했고, 이것은 현실세계의 데이터를 다시 논리적으로 정의하고 표현하는 방법으로, 사람들은 이 기법을 통해 더욱 논리적인 데이터 베이스 시스템을 가질 수 있게 되었다. 이러한 모델링 기법을 이용한 초창기의 데이터베이스가 계층형, 네트워크형 데이터베이스이다!

#### 관계형 데이터베이스

현재 가장 일반적으로 사용되는 데이터베이스 시스템이다. 관계형 데이터베이스는 데이터의 구조를 테이블(Table), 즉 표의 형태로 구성한다. SQLite가 바로 이 관계형 데이터베이스에 해당한다.

### DBMS

DBMS(Database Management System)는 데이터베이스의 역할(데이터를 저장하고 이를 운용하게 하는 것)그 자체를 수행하는 소프트웨어를 말한다. Oracle, SQLServer 그리고 MySQL, 그리고 SQLite가 바로 이 DBMS이다.

#### 관계형 데이터베이스의 기본구조

관계형 데이터베이스는 데이터베이스가 여러 개의 테이블을 소유하는 형식으로 구성된다. 각 테이블은 실제 데이터를 담고 있는데, 데이터가 담기는 구조는 '표'형태로 이루어져 있다. 해당 표의 속성이 담긴 열은 '필드(field)'라고 하고, 실제 데이터를 이루는 각 행은 '레코드'라고 한다.

#### SQL 익히기

SQL은 데이터베이스와 테이블의 생성과 수정, 삭제 기능부터 데이터의 검색, 추가, 삭제, 수정 등의 데이터 처리 기능을 모두 수행할 수 있다.

#### 테이블의 생성: CREATE TABLE

레코드를 추가하고 조회하는 등의 작업을 하려면 테이블이 있어야 한다. 

CREATE TABLE문은 각 필드의 자료형과 크기 등으로 구성된 테이블의 구조(이것을 스키마(Schema)라고 한다)를 매개변수로 하여 테이블을 생성하며, 다음과 같은 형식으로 사용한다.

```
CREATE TABLE <테이블> ( 필드1 필드형식1, 필드2 필드형식2, ... )
```

#### 레코드 추가: INSERT 문

INSERT 문은 레코드를 테이블에 추가할 때 사용한다. 

```
INSERT INTO <테이블> ([필드1, 필드2, ...]) VALUE([데이터1, 데이터2, ...])
```

#### 레코드 조회: SELECT 문

SELECT 문의 기본적인 구조는 아래의 형식과 같다. 우리말로 해석하면 "<테이블>에서 <필드>를 선택하라."라는 뜻이 된다.

```
SELECT <필드> FROM <테이블>
```

#### WHERE: 특정 조건의 레코드에 대해 작업

WHERE 절은 SELECT 문에 조건을 한정하는 기능을 한다. WHERE 절은 아래와 같이 SELECT 문 뒤에 붙여서 사용한다. 

```
<SELECT 문 ...> WHERE <조건>
```

#### ORDER BY: 조회 결과의 정렬

ORDER BY 절은 조회 결과가 여러 레코드로 구성되어 있을 경우, 이를 특정한 기준으로 정렬해 준다. WHERE절과 마찬가지로 SELECT문 뒤에 붙여서 사용한다. 

```
sqlite> SELECT * FROM PHONEBOOK ORDER NAME ASC:
윤경한|010-1111-1111|zizou0812@gmail.com
윤경한1|010-1111-1111|zizou0812@gmail.com
윤경한2|010-1111-1111|zizou0812@gmail.com
```

#### 레코드 수정: UPDATE 문

UPDATE문은 테이블에 이미 존재하는 레코드의 특정 필드를 수정할 때 사용한다. 

```
UPDATE <테이블> Set [필드1]=[데이터1], [필드2]=[데이터2], ... WHERE [조건]
```

#### 레코드 삭제: DELETE 문

DELETE 문은 레코드를 삭제할 때 사용한다. DELETE문은 모든 SQL 구문 중에서 가장 간단하다고 할 수 있다. 

```
DELETE FROM <테이블> WHERE [조건]
```

#### SQLite의 파이썬 API

파이썬3에는 SQLite 라이브러리가 기본 탑재되어 있다. 다음과 같이 import문으로 sqlite3모듈을 반입하면 SQLite API를 사용할 준비가 끝난것이다. 

```
import sqlite3
```

#### 커넥션 열고 닫기

커넥션은 sqlite.connect() 함수를 이용해 생성한다. connect() 함수에는 데이터베이스 파일의 경로를 매개변수로 입력한다

```
import sqlite3

conn = sqlite3.connect('test.db') # 커넥션 열기 # test.db 파일이 있다면 그 파일을 열고, 그렇지 않다면 새로 만든다.

conn.close() # 커넥션 닫기 
```

#### 커서로 작업하기

커서는 커넥션 객체의 cursor() 메소드를 이용해서 얻을 수 있다. 

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor() # 커서 열기

cursor.close() # 커서 닫기
conn.close()
```

#### 테이블 생성 

다음은 test.db 파일안에 PHONEBOOK 테이블을 생성한다.

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE PHONEBOOK 
(NAME CHAR(32), PHONE CHAR(32), EMAIL CHAR(64) PRIMARY KEY)
""")

cursor.close()
conn.close()
```

#### 레코드 추가 

execute() 메소드는 매개변수 치환 기능을 지원한다. SQL문을 만들기 위해 일일히 문자열을 결합하는 대신 매개변수 치환 기능을 사용하면 읽기도 좋고 사용하기도 좋은 코드가 작성된다.

SQL 문자열에 매개변수를 치환할 부분에 ?를 넣어놓고 ?에 들어갈 매개변수를 튜플 안에 넣어 execute() 메소드의 매개변수로 넘기면 된다.

```
cursor.execute("""
INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL)
VALUE(?, ?, ?) # 이곳에 '윤경한' '010-111-1111', 'zizou0812@gmail.com'가 입력된다
""", ('윤경한', '010-111-1111', 'zizou0812@gmail.com'))
```

- 레코드의 추가, 수정, 삭제 등을 실행하고 난 뒤에는 반드시 Connection 객체의 commit() 함수를 불러줘야 한다. 그렇지 않으면 실제 데이터베이스 파일에는 아무 변경이 이루어지지 않는다. 이것은 SQLite가 데이터의 일관성(Consistency)을 위한 트랜젝션(Transaction)을 지원하기 때문이다. 

*ex) 레코드 예제*

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor()

cursor.execute("""
INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL) 
VALUES(?, ?, ?)
""", ('윤경한', '010-111-1111', 'zizou0812@gmail.com'))

id = cursor.lastrowid
print(id)

cursor.execute("""
INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL) 
VALUES(?, ?, ?)
""", ('윤경한1', '010-111-1111', 'zizou0812@gmail.com'))

id = cursor.lastrowid
print(id)

conn.commit()

cursor.close()
conn.close()
```

*ex) 실행 결과*

```
> insert_record.py
1
2
```

#### 레코드 조회

SELECT문을 실행한 후 결과를 얻어올 때는 커서 객체의 fetchone() 또는 fetchall() 메소드를 이용한다. fetchone() 메소드는 이름처럼 SELECT 실행 결과에서 레코드를 하나씩만 가져온다.

```
row = cursor.fetchone()
print(row)
```

반면에, fetchall() 메소드는 한 번에 모든 결과 레코드를 가져온다.

```
rows = cursor.fetchall()
for row in rows:
	print("NAME: {0}, PHONE: {1}, EMAIL: {2} ",
		format(row[0], row[1], row[2]))
```

*ex) SELECT문을 실행하고 결과를 출력하는 예*

```
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.cursor()

cursor.execute("SELECT NAME, PHONE, EMAIL FROM PHONEBOOK")

rows = cursor.fetchall()
for row in rows:
   print ("NAME: {0}, PHONE: {1}, EMAIL: {2} ".
        format(row[0], row[1], row[2]))

cursor.close()
conn.close()
```

*ex) 실행 결과*

```
> select_record.py
NAME: 윤경한, PHONE: 010-111-1111, EMAIL: zizou0812@gmail.com
NAME: 윤경한1, PHONE: 010-111-1111, EMAIL: zizou0812@gmail.com
```

## 파이썬으로 이미지 요리하기

### 이미지 매직

이미지 매직(Image Magick)은 포토샵 같은 이미지 편집 소프트웨어 이다. GUI를 갖고 있는 포토샵과는 달리 이미지 매직은 명령 프롬프트에서 실행하는 것이 특징이다. 이미지 매직은 형식 변환, 이미지 회전, 도형 그리기, 텍스트 출력, 이미지간 합성, 이미지 자르기, 크기 변환 등등 이미지 편집에 필요한 다양한 기능을 제공한다. 

### Wand: 이미지 매직 파이썬 API 라이브러리

Wand는 깔끔한 인터페이스를 제공하는 이미지 매직용 파이썬 라이브러리이다.

#### Wand 설치 

```
> pip install Wand
```

#### Wand를 이용한 이미지 편집

Wand를 이용한 이미지 편집 프로그래밍도 관련 모듈을 코드에 반입하는 것으로 시작된다. 주로 사용할 모듈은 wand.image이다. 이 모듈 안에서도 특히 Image 클래스를 주로 사용한다.


| **기능**  | **메소드 이름**  |
|---|---|
| 파일 형식 바꾸기  | image.convert()  |
| 크기 바꾸기  | image.resize()  |
| 이미지 자르기  | 슬라이스 연산자.  |
| 이미지 회전  | image.retate()  |
| 이미지 뒤집기  | image.flip() # 상하 뒤집기, image.flop() # 좌우 뒤집기  |
| 이미지 명도, 채도, 색상 변경하기  | image.modulate()  |
| 이미지 합성  | image.composite()  |
| 워터 마크  | image.watermark()  |

- 이미지 도형이나 텍스트를 그려 넣을 때는 image.drawing 모듈의 Drawing 클래스도 함께 사용한다.

| **기능**  | **메소드 이름**  |
|---|---|
| 이미지에 텍스트와 도형 넣기  | Drawing.line(), Drawing.rectangle(), Drawing.text(), Drawing.draw()  |

#### 이미지 파일 형식 바꾸기

이미지 파일 형식을 바꿀 때에는 wand.Image 클래스의 convert() 메소드를 사용한다.

convert() 메소드는 새 이미지 형식의 이름을 매개변수로 입력받는다. 

#### 이미지 크기 바꾸기

이미지의 크기를 바꿀 때에는 resize() 메소드를 이용한다. resize() 메소드는 다음과 같이 재조정할 이미지의 너비와 높이를 매개변수로 입력받는다.

```
with Image(filename=original_path) as image:
	image.resize(100, 50) # 어떤 이미지건 너비 100, 높이 50으로 크기 변경
```

#### 이미지 자르기

이미지 자르기를 위한 슬라이스 연산자([])는 다음과 같이 사용하며, (x1, y1)과 (x2, y2) 좌표로 이루어지는 사각형 영역을 잘라낸다. 

```
cropped = image[x1:y1, x2:y2]
```

#### 이미지 회전 

이미지 회전은 Image 클래스의 rotate() 메소드를 이용한다. rotate()의 매개변수는 두 가지이다. 하나는 회전 각도이고 하나는 이미지를 회전시켰을 때 남는 공간에 채워넣을 색상이다.

```
rotated.rotate(degree, background=Color(bgcolor))
```

#### 이미지 뒤집기

이미지를 상하로 뒤집을 때는 flip() 메소드를, 좌우로 뒤집을 때는 flop() 메소드를 사용한다. 

```
with Image(filename=original_path) as image:
	image.flip() # 상하 뒤집기
	image.flop() # 좌우 뒤집기
```

#### 이미지에 텍스트와 도형 넣기

텍스트와 도형을 그려 넣을 때는 wand.drawing.Drawing 클래스의 도움이 필요하다. Drawing 클래스를 사용하는 방법은 먼저 wand.drawing 모듈부터 Drawing 클래스를 반입한다. Image 클래스도 반입해야 한다.

```
from wand.drawing import Drawing
from wand.image import Image
```

- 그 다음에는 Image와 Drawing의 인스턴스를 생성한다.

```
with Image(filename=original_path) as image:
	with Drawing() as draw:
```

#### 이미지의 명도, 채도, 색상 변경하기

모든 색은 명도, 채도, 색상 이렇게 세 가지 속성을 가진다.

*ex) test*


```
import sys
from wand.image import Image

if len(sys.argv) < 5:
    print('{0} <ORIGINAL PATH> <BRIGHTNESS> <SATURATION> <HUE>'
          .format(sys.argv[0]))
    sys.exit()

original_path = sys.argv[1]
brightness = float(sys.argv[2])
saturation = float(sys.argv[3])
hue = (float(sys.argv[4]) * 100 / 180 ) + 100 

with Image(filename=original_path) as image:
    with image.clone() as clone:
        clone.modulate(brightness, saturation, hue) 
        clone.save(filename= 'modulated_' + original_path)
```

#### 이미지 합성

이미지의 합성은 Image 객체의 composite() 메소드로 수행 가능하다. 

```
image1.composite(image2, 100, 100) # image1 위의 (100, 100) 위치에 image2를 합성
```

- 한쪽 이미지를 약간 투명하게 만들어서 더 자연스럽게 합성하고 싶다면, 이미지를 투명하게 만들 때에는 Image 객체의 transparentize() 메소드를 이용한다. transparentize() 메소드는 투명도를 0에서 1사이의 값으로 입력받는다.

- 다음과 같이 transparentize() 메소드에 0.7을 매개변수로 입력하여 호출하면 해당 이미지의 투명도를 70%로 변환한다.

```
image2.transparentize(0.7)
```

*ex) 두개의 이미지를 사용자로부터 입력받고 그 중 하나를 70% 투명도로 다른 이미지 위에 합성하는 예*

```
import sys
from wand.image import Image

if len(sys.argv) < 3:
    print('{0} <Image 1> <Image 2>'.format(sys.argv[0]))
    sys.exit()

image1_path = sys.argv[1]
image2_path = sys.argv[2]

with Image(filename=image1_path) as image1:
    with Image(filename=image2_path) as image2:
        with image1.clone() as clone:
            image2.transparentize(0.7)
            clone.composite(image2, 100, 100)
            clone.save(filename= image1_path + "_" + image2_path)
```

#### 워터마크

Image 클래스에는 composite() 메소드와 transparentize() 메소드의 기능을 한꺼번에 수행하는 메소드가 있는데, 바로 watermark()이다!

- watermark() 메소드의 첫 번째 매개변수는 합성할 Image 객체, 두 번째 매개변수는 투명도, 세 번째와 네 번째 매개변수는 각각 합성할 이미지의 x,y 좌표를 나타낸다.

*ex) watermark() 메소드 예*

```
import sys
from wand.image import Image

if len(sys.argv) < 3:
    print('{0} <Image 1> <Image 2>'.format(sys.argv[0]))
    sys.exit()

image1_path = sys.argv[1]
image2_path = sys.argv[2]

with Image(filename=image1_path) as image1:
    with Image(filename=image2_path) as image2:
        with image1.clone() as clone:
            clone.watermark(image2, 0.7, 100, 100)
            clone.save(filename= image1_path + "_" + image2_path)
```

## Pygame으로 게임 만들기!!!

### pygame 소개

pygame은 게임과 같은 멀티미디어 소프트웨어 개발을 위해 만들어진 파이썬 라이브러리이다. SDL(Simple DirectMedia Layer) 라이브러리를 기반으로 만들어진 pygame은 윈도우, 리눅스, 맥 등 다양한 운영체제를 지원하며, 조이스틱 입력, 그래픽 처리, 사운드 재생 등 다양한 기능을 탑재하고 있다.

#### pygame 라이브러리 설치

#### 게임 루프

게임 루프는 게임과 사용자 간의 지속적인 상호 작용을 하는 무한 루프이다. 게임이 자신의 상태를 화면에 표시하면 사용자는 표시된 상태에 따라 조이스틱이나 키보드 등을 이용해서 명령을 입력한다.

게임은 이렇게 입력된 명령을 처리하고 자신의 상태를 변경한 후, 다시 사용자에게 자신의 상태를 화면에 표시한다. 게임 루프는 시작부터 끝까지 이 과정을 지속적으로 반복한다.

반복 수행해야 하는 일을 정리하면 다음과 같다.

1. 사용자 입력 처리 : 사용자가 조이스틱, 키보드를 통해 입력한 명령을 처리한다.

2. 게임 상태 업데이트 : 주인공의 에너지, 총알 수, 위치, 적과의 충돌 여부 등을 갱신한다.

3. 게임 상태 그리기 : 2.에서 갱신된 내용을 화면에 그려 넣는다.

#### pygame을 사용하는 방법

pygame을 이용하는 게임 코드는 크게 다섯 부분으로 나뉜다.

1. pygame 관련 모듈 반입
2. pygame 초기화
3. 스크린 크기 설정
4. 게임 루프
5. pygame 관련 모듈 사용 자원 해제

- pygame 모듈을 반입하는 것으로 시작 

```
import pygame
```

- 모듈을 반입한 후에는 pygame에 관련된 다른 기능을 사용하기 전에 pygame.init() 메소드부터 호출해야 한다. 이 메소드가 하는 일은 반입된 모든 pygame 관련 모듈을 초기화 하는 것이다.

```
pygame.init()
```

- 그 다음에는 pygame.display.set_mode() 메소드를 호출하여 게임 스크린의 크기를 지정한다. 

```
screen = pygame.display.set_mode(400, 300))
```

- 게임 루프를 작성하기 전에 게임 루프의 주기를 결정할 pygame.time.Clock 객체를 생성한다.

```
clock = pygame.time.Clock()
```

- 게임 루프를 작성

```
while True:
	# 1) 사용자 입력을 처리
	# 2) 게임 상태 업데이트
	# 3) 게임 상태 그리기
	clock.tick(30)
```

- 사용자의 명령이나 게임 상태 업데이트에 의해서 게임 루프를 빠져 나오게 되면 어플리케이션이 종료되기 전에 다음과 같이 pygame.quit() 메소드를 호출한다. 

```
pygame.quit()
```

#### 처음 만들어보는 pygame 애플리케이션

*ex) 스크린의 색상이 완전히 빨간색이 되면 다시 하얀색이 되어 빨간색으로 변하기를 반복하는 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((400, 300)) 
pygame.display.set_caption("Hello, pygame!")

clock = pygame.time.Clock()
run = True
gb = [255, 255]

# Game Loop
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    # 2) 게임 논리 실행
    if gb[0] == 0:
        gb[0] = 255
        gb[1] = 255
    else:
        gb[0] -= 1
        gb[1] -= 1
   
    # 3) 게임 장면 그리기
    screen.fill(pygame.color.Color(255, gb[0], gb[1]))
    pygame.display.flip()
    
    clock.tick(60)

pygame.quit()
```

#### pygame에서의 사용자 입력 처리

pygame에서 사용자 입력 이벤트를 담당하는 모듈은 pygame.event이다. pygame.event.get() 함수는 게임의 이벤트 큐에 있는 모든 이벤트를 순서열로 만들어 반환한다.

```
events = pygame.event.get()
```

*ex) KEYDOWN, KEYUP + QUIT 이벤트 테스트의 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((300, 100)) 
pygame.display.set_caption("Keyboard Test")

clock = pygame.time.Clock()
run = True
key_status = ""
key = None

# 게임 루프
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        elif event.type == pygame.KEYDOWN:
            key_status = "Key Down"
            key = event.key
        elif event.type == pygame.KEYUP:
            key_status = "Key Up"
            key = event.key
            
    # 2) 게임 상태 업데이트
    
   
    # 3) 게임 상태 그리기
    screen.fill(pygame.color.Color(255, 255, 255))
    
    if key != None:
        pygame.display.set_caption(
            pygame.key.name(key) + " " + key_status)
    
    pygame.display.flip()    
    clock.tick(60)

pygame.quit()
```

스페이스 키가 눌러져 있는지를 알고 싶을 때는 다음과 같이 pygame.key.get_pressed() 함수가 반환한 튜플에 해당 키를 나타내는 상수(pygame.K_SPACE)을 첨자로 넘기면 된다.

```
keys = pygame.key.get_pressed()
if keys[pygame.K_SPACE]:
	print("스페이스 키 눌렀음")
```

*ex) 커서 키가 눌러져 있는지를 감시하고 현재 눌러져 있는 키의 이름을 출력하는 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((300, 100)) 
pygame.display.set_caption("Keyboard Test2")

clock = pygame.time.Clock()
run = True
key_status = ""
key = None

# 게임 루프
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
    # 누르고 있는 키 확인하기.
    keys = pygame.key.get_pressed() 
    if keys[pygame.K_LEFT]:
        print("LEFT")
    elif keys[pygame.K_RIGHT]:
        print("RIGHT")
    elif keys[pygame.K_UP]:
        print("UP")
    elif keys[pygame.K_DOWN]:
        print("DOWN")
        
    # 2) 게임 상태 업데이트    
   
    # 3) 게임 상태 그리기
    screen.fill(pygame.color.Color(255, 255, 255))
    
    if key != None:
        pygame.display.set_caption(
            pygame.key.name(key) + " " + key_status)
    
    pygame.display.flip()    
    clock.tick(60)

pygame.quit()
```

#### pygame으로 그리기

#### 텍스트 그리기

pygame으로 텍스트를 그릴 때는 pygame.font.SysFont 클래스를 이용한다. 

```
# 1) Sysfont 생성자에 폰트명과 크기를 입력

sf = pygame.font.SysFont("Monospace", 20)

# 2) SysFont.render 메소드가 하는 일은 텍스트를 그려넣은 Surface 객체를 반환하는 것.
#	이 메소드의 1번째 매개변수는 출력할 텍스트,
# 	2번째 매개변수는 안티알리아싱(Anti-aliasing) 여부,
# 	3번째 매개변수는 텍스트의 색상

text = sf.render("Hello, World", True, (0,0,255))

# 3) Surface.blit() 메소드는 다른 Surface 객체를 자신에게 그려넣는 일을 한다. 
# 	이 메소드의 1번째 매개변수는 그려넣을 Surface 객체, 
# 	2번째 매개변수에 해당 Surface 객체를 그려넣을 좌표

screen.blit(text, (10,10)) 
```	

#### 도형 그리기

pygame.draw 모듈에는 다양한 도형 그리기 함수가 있다. 

*ex) 도형 그리기의 예*

```
import pygame

pygame.init() 
screen = pygame.display.set_mode((300, 100)) 
pygame.display.set_caption("Drawing Shapes")

clock = pygame.time.Clock()
run = True
key = None
start_pos = [0, 0]

# 게임 루프
while run:
    # 1) 사용자 입력 처리
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        elif event.type == pygame.KEYDOWN:
            key = event.key
            
    # 2) 게임 상태 업데이트    
    if start_pos[0] > screen.get_width():
        start_pos[0] = 0
    else:
        start_pos[0] += 1
    
    # 3) 게임 상태 그리기
    screen.fill(pygame.color.Color(255, 255, 255))
    
    if key == pygame.K_1:
        pygame.draw.line(screen, 
            pygame.color.Color(0, 0, 0), 
            start_pos, 
            (screen.get_width(), screen.get_height()), 1)
    elif key == pygame.K_2:
        pygame.draw.ellipse(screen,
            pygame.color.Color(255, 0, 0), 
            pygame.Rect(start_pos, (50, 50)))
    elif key == pygame.K_3:
        pygame.draw.polygon(screen,
            pygame.color.Color(0, 255, 0), 
            [start_pos, 
             (0, screen.get_height()), 
             (screen.get_width(), screen.get_height())])
    elif key == pygame.K_4:
        pygame.draw.rect(screen,
            pygame.color.Color(0, 0, 255), 
            pygame.Rect(start_pos, (50, 50)))
    
    pygame.display.flip()    
    clock.tick(60)

pygame.quit()
```

#### 이미지 그리기

pygame.image.load() 함수는 이미지 파일을 읽어 들여 Surface 객체를 만들어 반환한다. 

```
# load() 함수는 이미지 파일로부터 Surface 객체를 반환
img = pygame.image.load("image.png")

# img 객체가 그려질 위치와 크기를 나타내는 pygame.Rect 객체를 반환.
rect = img.get_rect()

while True:
	screen.blit(img, rect) # Surface.blit() 메소드를 이용해 img 객체를 그린다.
```

#### pygame으로 오디오 재생하기

pygame.mixer.Sound 클래스는 오디오를 재생하는 기능을 가지고 있으며, OGG 또는 압축하지 않은 WAV 형식의 오디오 파일을 지원한다. 

```
# Sound 생성자에 오디오 파일 경로를 입력
fire_sound = pygame.mixer.Sound('fire.ogg')

# play() 메소드는 오디오 파일을 재생한다.
fire_sound.play()

# stop() 메소드는 오디오 파일의 재생을 중지시킨다.
fire_sound.stop()
```

### 스프라이트의 이해

스프라이트(Sprite)는 다른 이미지와 합성하기 위해 사용하는 이미지나 애니메이션을 말한다. "게임 화면 내에서 움직이는 물체"라고 생각해도 된다. 

- 스프라이트를 사용하면 더 작은 용량으로 더 작은 메모리로 객체의 상태 변화나 객체들 간의 충동 처리 등이 용이하게 구현 가능하다.

#### pygame.sprite.Sprite와 pygame.sprite.Group

다음은 Sprite 클래스가 제공하는 메소드의 목록이다.

| **메소드**  | **기능**  |
|---|---|
| update()  | 객체의 상태를 업데이트 한다.  |
| add()  | 스프라이트를 그룹에 추가한다.  |
| remove()  | 스프라이트를 그룹에서 제거한다.  |
| kill()  | 스프라이트가 속해 있는 모든 그룹에서부터 스프라이트를 제거한다.  |
| alive()  | 스프라이트가 한 그룹에라도 속해있는지의 여부를 반환한다.  |
| groups()  | 스프라이트가 속해 있는 모든 그룹을 반환한다.  |

- Sprite의 파생 클래스는 다음의 사항을 만족해야 한다.

1. 스프라이트 객체를 그룹에 추가하기 전에 Sprite.__init__() 메소드를 호출해야 한다.
2. pygame.Surface 형식의 image 데이터 속성을 할당해둬야 한다.
3. pygame.Rect 형식의 rect 데이터 속성을 할당해둬야 한다.
4. update() 메소드를 오버라이드 해야 한다.


다음의 예제에서는 Sprite 클래스의 상속 조건 4가지를 만족시키는 Runner 클래스를 정의한다. 

*ex) Sprite_Runner의 예*

```
import pygame
from pygame.color import Color
from pygame.sprite import Sprite
from pygame.surface import Surface

class Runner(Sprite):
    def __init__(self):
        Sprite.__init__(self)

        self.sprite_image = 'runnersprite.png'
        self.sprite_width = 70
        self.sprite_height = 100 
        self.sprite_sheet = pygame.image.load(
                                self.sprite_image).convert()
        self.sprite_columns = 14
        self.current_frame = 0
        self.image = Surface((self.sprite_width, self.sprite_height))

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
        self.rect = self.image.get_rect()
       
    def update(self):
        if self.current_frame == self.sprite_columns - 1:
            self.current_frame = 0
        else:
            self.current_frame += 1

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
```

*ex) 애니메이션 효과 연출의 예*

```
import pygame
from pygame.color import Color
from runner import Runner

FPS = 28

if __name__ == "__main__": 
    pygame.init()
 
    size = (400, 300)
    screen = pygame.display.set_mode(size) 
    pygame.display.set_caption("Runner Animation")
 
    run = True
    clock = pygame.time.Clock()

    background_img = pygame.image.load("background.png")
    
    runner1 = Runner()
    runner1.rect.x = 0
    runner1.rect.y = 170

    # 게임 루프
    while run:
        # 1) 사용자 입력 처리
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

        # 2) 게임 상태 업데이트      
        runner1.update()

        # 3) 게임 상태 그리기
        screen.blit(background_img, screen.get_rect())
        screen.blit(runner1.image, runner1.rect)
        pygame.display.flip()
 
        clock.tick(FPS)
        
    pygame.quit()
```

- Sprite 클래스는 pygame.sprite.Group 클래스와 함께 사용하도록 고안되었다. Group은 Sprite 객체의 컨테이너 기능을 하는 클래스이다. 

다음은 Group 클래스의 메소드 목록이다.

| **메소드**  | **기능**  |
|---|---|
| sprites()  | 이 그룹에 소속되어 있는 모든 스프라이트의 목록을 반환한다.  |
| copy()  | 그룹을 복사한다.  |
| add()  | 스프라이트를 그룹에 추가한다.  |
| remove()  | 스프라이트를 그룹에서 제거한다.  |
| has()  | 그룹이 특정 스프라이트를 갖고 있는지 확인한다.  |
| update()  | 그룹에 소속되어 있는 모든 스프라이트 객체의 update() 메소드를 호출한다.  |
| draw()  | 그룹에 소속되어 있는 각 스프라이트 객체의 image 데이터 속성과 rect 데이터 속성을 매개변수로 Surface.blit() 메소드를 호출한다.  |
| clear()  | 그룹이 갖고 있는 스프라이트 위로 배경을 그린다.  |
| empty()  | 모든 스프라이트를 그룹에서 제거한다.  |    


#### 스프라이트간의 충돌 처리

pygame.sprite.groupcollide() 함수는 스프라이트 그룹간의 충돌 여부를 평가하고, 충돌이 일어난 스프라이트 객체를 자동으로 그룹에서 제거해준다. 게다가 어떤 스프라이트에 충돌이 발생했는지를 dict 객체에 담아 출력해주기까지 한다.

```
while True: # 게임 루프
	collided = pygame.sprite.groupcollide(group1, group2, False, True)
	for item collide.items():
		print(item)
```

### 투석기 게임

#### 게임 컨셉 및 구조

이 문제는 16세기에 갈릴레오가 해결을 해주었다. 던져진 물체는 포물선 운동을 한다는 사실을 갈릴레오가 밝혀내고 이것을 이론으로 정리해놨기 때문이다.

- 포물선 운동 공식을 적용해야 한다.

#### 게임에 사용할 상수 정의

*ex) 상수 정의의 예*

```
g = 0.7
BASE_Y = 250

CATAPULT_READY = 0
CATAPULT_FIRE = 1

STONE_READY = 0
STONE_FLY = 1

MIN_POWER = 1
MAX_POWER = 20

MIN_DIRECTION = 20
MAX_DIRECTION = 85

GAME_INIT = 0
GAME_PLAY = 1
GAME_CLEAR = 2
GAME_OVER = 3
```

### 스프라이트 클래스 정의: 배경, 투석기, 돌, 외계인, 폭발

#### 게임에 사용할 스프라이트의 부모 클래스

Animation 클래스는 두 가지 메소드를 구현한다. 하나는 init_animation() 메소드로, 스프라이트 시트 파일을 읽어 들이고 FPS에 따른 프레임 변경 시간 등을 초기화한다. 

또 다른 하나는 calc_next_frame() 메소드이다. 이 메소드는 시간이 얼마나 지났는지를 보고 애니메이션 프레임을 전환할지를 결정한다.

*ex) Animation 클래스 구현의 예*

```
import pygame
from pygame import Surface
from pygame.color import Color
from pygame.sprite import Sprite

class Animation(Sprite):
    def init_animation(self):
        Sprite.__init__(self)

        self.sprite_sheet = pygame.image.load(self.sprite_image).convert()
        self.current_frame = 0
        self.image = Surface((self.sprite_width, self.sprite_height))

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
        self.rect = self.image.get_rect()        
        self.elapsed = pygame.time.get_ticks()
        self.threshold =  1000/self.fps
 
    def calc_next_frame(self):
       tick = pygame.time.get_ticks()
       if tick - self.elapsed > self.threshold:
           self.elapsed = tick
           if self.current_frame == self.sprite_columns:
               self.current_frame = 0
           else:
               self.current_frame += 1
```

#### Stone 스프라이트 클래스

Stone 스프라이트 클래스는 투석기가 던지는 돌을 표현한다. Stone 스프라이트 애니메이션의 각프레임 크기는 8픽셀이며 총 프레임의 수는 4개이다.

Stone 객체는 발사되기 전에는 STONE_READY 상태를 갖고 있다가, 사용자가 투석기에게 발사 명령을 내리면 setup() 메소드를 통해 초기 발사 파워(power), 발사각(direction), 발사 위치(initial_pos)를 객체에 저장한 후 상태를 STONE_FLY로 변경 한다. 

STONE_FLY 상태가 된 Stone 객체는 게임 루프가 호출하는 move() 메소드를 통해 외계인을 향해 날아간다. 이 때 Stone의 위치가 게임 화면을 벗어나면 상태를 다시 STONE_READY로 돌려 발사 준비 상태로 돌아간다. 

*ex) Stone 클래스의 구현의 예*

```
import math
import pygame
from pygame.color import Color
from animation import Animation
from const import *

class Stone(Animation):
    # STATE : STONE_READY -> STONE_FLY
    #           ^---------------|
    # READY일 때만 이동 가능
    # FIRE일 때는 아무것도 못함.
    def __init__(self):
        self.sprite_image = 'stone.png'
        self.sprite_width = 8
        self.sprite_height = 8
        self.sprite_columns = 4
        self.fps = 20
        self.state = STONE_READY
        self.init_animation()
               
    def update(self): 
        # 돌은 투석기가 발사한 이후부터 목표 또는 
        # 지면에 충돌할 때까지 날기만 하므로
        # 상태에 따른 스프라이트 정지 등은 필요 없음.
        self.calc_next_frame()
                
        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))

    def setup(self, initial_pos, power, direction):
        self.initial_pos = initial_pos
        self.rect.x = initial_pos[0]
        self.rect.y = initial_pos[1]
        self.power = power
        self.direction = direction
        self.state = STONE_FLY

    def move(self, time, space, decrement_stones):
        pos = self.calculate_position(time, g, self.direction)

        pos = self.map_position(
            self.initial_pos[0], self.initial_pos[1], 
            pos[0], pos[1])
        self.rect.x = pos[0]
        self.rect.y = pos[1]

        if pos[0] > space[0] or pos[1] > space[1]:
            self.state = STONE_READY
            decrement_stones()

    # 포탄 위치 계산
    def calculate_position(self, t, g, direction):
        r = math.radians(direction)
        x = self.power*math.cos(r)*t
        y = self.power*math.sin(r)*t - 0.5*g*math.pow(t, 2)

        return (int(x), int(y))

    # 포탄의 위치를 화면 좌표에 맞게 변환
    def map_position(self, x, y, new_x, new_y):
        return (x + new_x, y + (new_y*-1))
```

#### Catapult 스프라이트 클래스 정의

Catapult 클래스는 투석기를 앞/뒤로 이동시키는 forward()/backward() 메소드와 돌을 발사하는 fire() 메소드를 갖고 있다. fire() 메소드는 게임 루프로부터 발사 파워와 발사각을 입력 받아 데이터 속성에 저장하고 Catapult 객체의 상태를 CATAPULT_READY로 변경한다. 그 다음 update() 메소드가 호출될 때 이 상태를 확인하고 발사 애니메이션을 실행한다. 

발사 애니메이션의 끝에 도달하면 Catapult 객체의 상태는 다시 CATAPULT_READY로 돌아가고, stone 객체의 setup() 메소드를 호출함으로써 돌이 날아가도록 만든다. setup() 메소드를 호출받은 stone 객체의 상태는 STONE_FLY로 바뀌어 외계인을 향해 비행을 시작한다.    

*ex) Catapult 클래스 구현의 예*

```
import pygame
from pygame.color import Color
from animation import Animation
from stone import Stone
from const import *

class Catapult(Animation):
    # STATE : CATAPULT_READY -> CATAPULT_FIRE
    #           ^------|
    # READY일 때만 이동 가능
    # FIRE일 때는 아무것도 못함.
    def __init__(self, stone):
        self.sprite_image = 'catapult.png'
        self.sprite_width = 32
        self.sprite_height = 32
        self.sprite_columns = 5
        self.fps = 30
        self.stone = stone
        self.state = CATAPULT_READY
        self.init_animation()

    def update(self): 
        if self.state == CATAPULT_FIRE:
            self.calc_next_frame()

            if self.current_frame == self.sprite_columns:
                self.current_frame = 0
                # 돌멩이 날리기 시작
                self.state = CATAPULT_READY
                self.stone.setup(
                    (self.rect.x, self.rect.y), 
                    self.power, self.direction)
        else:
            self.current_frame = 0
                
        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))

    def forward(self):
        if self.rect.x < 100:
            self.rect.x += 1

    def backward(self):
        if self.rect.x > 0:
            self.rect.x -= 1

    def fire(self, power, direction):
        self.state = CATAPULT_FIRE
        self.power = power
        self.direction = direction
```

#### Alien 스프라이트 클래스 정의

Alien 클래스는 우리의 적인 외계인 스프라이트를 표현한다!

Alien 클래스는 숨 쉬는 것 말고는 특별한 기능을 갖고 있지 않다. 

*ex) Alien 클래스 구현의 예*

```
from pygame.color import Color
from animation import Animation

class Alien(Animation):
    def __init__(self):
        self.sprite_image = 'alien.png'
        self.sprite_width = 32
        self.sprite_height = 32
        self.sprite_columns = 3
        self.fps = 10
        self.init_animation()
               
    def update(self): 
        self.calc_next_frame()

        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
```

#### Explosion 스프라이트 클래스 정의

Explosion 클래스는 폭발 애니메이션을 구현한다. 돌과 외계인이 충돌 했을 때 사용된다.

*ex) Explosion 클래스 구현의 예*

```
from pygame.color import Color
from animation import Animation

class Explosion(Animation):
    def __init__(self):
        self.sprite_image = 'explosionsprite.png'
        self.sprite_width = 100
        self.sprite_height = 100 
        self.sprite_columns = 25
        self.fps = 16
        self.init_animation()
       
    def update(self): 
        self.calc_next_frame()
        if self.current_frame == self.sprite_columns:
            self.current_frame = 0
            self.kill()
        
        rect = (self.sprite_width*self.current_frame, 0, 
                self.sprite_width, self.sprite_height)
        self.image.blit( self.sprite_sheet, (0, 0), rect)
        self.image.set_colorkey(Color(255, 0, 255))
```

#### 메인 모듈(게임 루프)


*ex) 메인 모듈 구현의 예*

```
import math
import pygame
from pygame import draw
from pygame.color import Color
from pygame.sprite import Sprite

from catapult import Catapult
from stone import Stone
from alien import Alien
from explosion import Explosion
from const import *

FPS = 60
stone_count = 3

def decrement_stones():
    global stone_count
    stone_count -= 1

class Background(Sprite):
    def __init__(self):        
        self.sprite_image = 'background.png'
        self.image = pygame.image.load(
                self.sprite_image).convert()
        self.rect = self.image.get_rect()
        self.rect.x = 0
        self.dx = 1

        Sprite.__init__(self)
        
    def update(self):
        self.rect.x -= self.dx
        if self.rect.x == -800:
            self.rect.x = 0

if __name__ == "__main__": 
    pygame.init()
 
    size = (400, 300)
    screen = pygame.display.set_mode(size)
 
    pygame.display.set_caption("Catapult VS Alien")
 
    run = True
    clock = pygame.time.Clock()
    t = 0
    fire_sound = pygame.mixer.Sound('fire.ogg')
    crash_sound = pygame.mixer.Sound('crash.ogg')

    power = 15
    direction = 45
    
    game_state = GAME_INIT
    background = Background()
    background_group = pygame.sprite.Group()
    background_group.add(background)
    
    stone = Stone() 
    stone.rect.y = -100   # 위치 변경
    stone_group = pygame.sprite.Group()
    stone_group.add(stone)

    catapult = Catapult(stone)    
    catapult.rect.x = 50 # 위치 변경                       
    catapult.rect.y = BASE_Y
    catapult_group = pygame.sprite.Group()
    catapult_group.add(catapult)

    alien = Alien()
    alien.rect.x = 350
    alien.rect.y = BASE_Y
    alien_group = pygame.sprite.Group()
    alien_group.add(alien)    

    explosion = Explosion()
    explosion_group = pygame.sprite.Group()
    explosion_group.add(explosion)

    # 게임 루프
    while run:
        # 1) 사용자 입력 처리
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
            elif event.type == pygame.KEYUP:
                if event.key == pygame.K_SPACE:
                    # 초기화면에서 스페이스를 입력하면 시작
                    if game_state == GAME_INIT: 
                        game_state = GAME_PLAY
                    elif game_state == GAME_PLAY: 
                        # GAME_PLAY 상태일 때 스페이스를 입력하면 발사
                        if stone.state == STONE_READY:
                            t = 0
                            catapult.fire(power, direction)
                            fire_sound.play()

        if game_state == GAME_PLAY:
            # 누르고 있는 키 확인하기.
            keys = pygame.key.get_pressed()  
            if keys[pygame.K_LEFT]:
                catapult.backward()
            elif keys[pygame.K_RIGHT]:
                catapult.forward()
            elif keys[pygame.K_UP]:
                if direction < MAX_DIRECTION:
                    direction += 1
            elif keys[pygame.K_DOWN]:
                if direction > MIN_DIRECTION:
                    direction -= 1    
            elif keys[pygame.K_SPACE]:
                if power > MAX_POWER:
                    power = MIN_POWER
                else:
                    power += 0.2

        # 2) 게임 상태 업데이트
        if stone.state == STONE_FLY:
            t += 0.5
            stone.move(t, 
                       (screen.get_width(), screen.get_height()), 
                       decrement_stones)
        
        if alien.alive():
            collided = pygame.sprite.groupcollide(
                        stone_group, alien_group, False, True)
            if collided:
                explosion.rect.x = \
                    (alien.rect.x + alien.rect.width/2) - \
                     explosion.rect.width/2
                explosion.rect.y = \
                    (alien.rect.y + alien.rect.height/2) - \
                    explosion.rect.height/2
                crash_sound.play()

        elif not explosion.alive(): 
            # 외계인도 죽고 폭발 애니메이션도 끝났을 때.
            game_state = GAME_CLEAR
       
        # 외계인이 살아 있는데 돌멩이 수가 0이면 게임 오버.
        if alien.alive() and stone_count == 0:
            game_state = GAME_OVER

        if game_state == GAME_PLAY: # 게임 객체 업데이트
            catapult_group.update()
            stone_group.update()
            alien_group.update()
        
        # 3) 게임 상태 그리기
        background_group.update()
        background_group.draw(screen)
                
        if game_state == GAME_INIT: 
            # 초기화면
            sf = pygame.font.SysFont("Arial", 20, bold=True)
            title_str = "Catapult VS Alien"
            title = sf.render(title_str, True, (255,0,0))
            title_size = sf.size(title_str)
            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)
            
            sub_title_str = "Press [Space] Key To Start"
            sub_title = sf.render(sub_title_str, True, (255,0,0))
            sub_title_size = sf.size(sub_title_str)
            sub_title_pos = (screen.get_width()/2 - sub_title_size[0]/2, 200)

            screen.blit(title, title_pos)
            screen.blit(sub_title, sub_title_pos)

        elif game_state == GAME_PLAY: 
            # 플레이 화면
            catapult_group.draw(screen)
            stone_group.draw(screen) 
            alien_group.draw(screen)

            # 파워와 각도를 선으로 표현.
            line_len = power*5 
            r = math.radians(direction)        
            pos1 = (catapult.rect.x+32, catapult.rect.y)
            pos2 = (pos1[0] + math.cos(r)*line_len, 
                    pos1[1] - math.sin(r)*line_len)
            draw.line(screen,Color(255, 0, 0), pos1, pos2)                 

            # 파워와 각도를 텍스트로 표현.
            sf = pygame.font.SysFont("Arial", 15)
            text = sf.render("{0} °, {1} m/s".
                             format(direction, int(power)), True, (0,0,0))
            screen.blit(text, pos2)

            # 돌의 개수를 표시
            sf = pygame.font.SysFont("Monospace", 20)
            text = sf.render("Stones : {0}".
                             format(stone_count), True, (0,0,255))
            screen.blit(text, (10, 10))

            if not alien.alive():
                explosion_group.update()
                explosion_group.draw(screen)

        elif game_state == GAME_CLEAR: 
            # 게임 클리어
            sf = pygame.font.SysFont("Arial", 20, bold=True)
            title_str = "Congratulations! Mission Complete"
            title = sf.render(title_str, True, (0,0,255))
            title_size = sf.size(title_str)
            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)
            screen.blit(title, title_pos)

        elif game_state == GAME_OVER: 
            # 게임 오버
            sf = pygame.font.SysFont("Arial", 20, bold=True)
            title_str = "Game Over"
            title = sf.render(title_str, True, (255,0,0))
            title_size = sf.size(title_str)
            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)
            screen.blit(title, title_pos)

        pygame.display.flip() 
        clock.tick(FPS)
 
    pygame.quit()
```

    
    
    
   	

	











		











    
    

    
    

    

    

    
	
	

    
	
	
	

	

	
	
	

	
	
	
	
	
    


	








 	

	





    

    

    
















































































































































