---
layout: post
title:  "재미그래밍 - 대용량 데이터베이스 솔루션"
date:   2018-01-29
author: Yoonkh
categories: Python
tags: 
- Code
comments: True
---

# 재미그래밍 - 새로쓴 대용량 데이터베이스 솔루션 1 (180129)

## 요약

- 학습 목표: DB의 심층 구조 파악, 학습
- 학습 결과: DB의 개념 이해

## 학습 내용 

1. **데이터 저장구조의 특징**

	관계형 데이터 베이스 이전에서는 대부분 키(key)와 데이터가 매우 밀접한 관련이 있었다. 데이터의 저장은 필연적으로 키의 영향을 받을 수 밖에 없었다. 따라서, 키를 찾기만 하면 원하는 데이터를 찾을 수 있어야 하기 때문에 키를 찾는 것이 곧 데이터를 찾는 것이 되었다. 
	
	테이블과 인덱스가 별도로 분리되어 있는 구조는 관계형 데이터베이스의 가장 일반적인 데이터 저장형식이다.
		
	- 분리형 테이블 구조

		- **테이블 스페이스**: 논리적인 저장공간을 뜻한다. 
		- **세그먼트**: 테이블 스페이스를 용도별로 나눈것을 의미한다.
		- **응축**: 블록 내에 저장될 로우가 한조각이 되도록 하기 위한 공간을 있지만 이어진 조각이 없어 저장이 불가능하게 될 때 자동으로 블록의 로우들을 재구성하는 작업이 일어나는데 이를 응축이라 한다. 		
		- **이주**: 로우가 다른 블록으로 이동하면 ROWID의 변경을 의미하여 이를 변경시키지 않고 여러 블록을 Access 하는 오버헤드를 감수하는 상태를 로우의 이주라고 한다.
		- **체인**: 필요한 공간만큼 블록을 연결해서 저장해야 하는데 이것을 체인이 발생했다고 한다. 
		
	- 클러스터링 팩터(clustering factor)

		인덱스의 컬럼값으로 정렬되어 있는 인덱스 로우의 순서와 테이블에 저장되어 있는 데이터 로우의 위치가 얼마나 비슷한 순서로 저장되어 있는지의 정도를 나타낸 것을 '클러스터링 팩터'라고 표현한다.
	
		클러스터링 팩터가 좋은 인덱스로 액세스를 하면 많은 로우를 액세스하더라도 적은 블록을 액세스하게 되어 효율적이다.
		
	- 분리형 테이블의 액세스 영향 요소

		- **소형테이블**: 소량의 데이터라면 그리 많지 않은 블록에 흩어져 있을것이고, 앞서 발생한 액세스에 의해 이미 메모리 내에 존재할 가능성이 높다.
		- **중형테이블**: 등록시에는 부담이 되더라도 좋은 액세스를 위해서는 찾기 좋은 형태로 저장해 두는 것이 바람직하다. 데이터 등록시 부하 부담을 무시할 수 없다면 특정 위치에 저장하는 것을 재검토해야 한다. 
		- **대형테이블**: 
		
			- 1. *단순 저장형 개념으로 사용시* 
				- 신속한 저장을 요구한다. 분리형이 가장 적절한 형태이다. 
			- 2. *대량의 데이터 수집, 랜덤 액세스가 주로 발생할시* 
				- 대량의 데이터가 급속히 들어오는 경우는 적다. 범위 처리를 자주 하지 않는다. 분리형 구조가 가장 적절하다. 
			- 3. *대량의 데이터 지속적 증가, 매우 다양한 액세스를 가지는 경우* 
				- 데이터 관리 및 액세스에 대한 부담이 크다. 최소한의 필요부분 액세스를 위해 인덱스를 전략적으로 구성해야 한다. 


	- 인덱스 일체형 테이블 

		테이블과 인덱스가 일체형으로 되어 있다는 것은 인덱스와 다른 일반 컬럼들이 모두 같은 위치에 저장되어 있는 형태를 의미한다. 
		
		분리형 구조에서는 처리 범위가 넒어지면 부담이 증가한다. 
		
		| **구분**  | **Ordinary**  | **Index-Organized Table**  |
|:-:|---|---|
| 로우의 유일 식별자  | ROWID  | 기본키  |
| 기본키 미지정  | 허용  | 허용하지 않음(반드시 기본키가 존재해야함)  |
| Secondary인덱스의 생성  | ROWID사용   | 논리적 ROWID나 비트맵 인덱스  |
| 로우 액세스  | ROWID로 액세스  | 기본키로 액세스  |
| 전체테이블 스캔  | 임의의 순서로 로우를 리턴함  | 기본키의 순서로 로우를 리턴함  |
| 클러스터링 가능여부  | Cluster에 저장 가능  | Cluster에 저장이 불가능  |
| LONG, LONG RAW, LOB  | LONG, LOB중 하나포함  | LOB는 가능하나 LONG은 불가능  |
| 분산(Distributed)  | 허용  | 버전에 따라 차이가 있음  |
| 데이터 이중화(Replication)  | 허용  | 버전에 따라 차이가 있음  |
| 파티션 적용  | 허용  | 버전에 따라 차이가 있음  |
| 병렬 처리  | 허용  | 버전에 따라 차이가 있음, CTAS를 통한 병렬 데이터 로딩, 파티션 및 일반 IOT의 병렬 고속 전체스캔(FFS), 파티션 IOT의 병렬 인덱스 스캔  |

		- 오버플로우 영역 

			- **일체형 테이블의 부담요소**: 인덱스와 모든 컬럼이 같은 장소에 저장된다는 것은 저장공간의 분할이 발생한다든지 저장 밀도가 나빠지는 등의 부담이 증가한다. 

			- **부담을 줄일 수 있는 방법**: 가장 쉽고 확실한 방법은 같이 적재할 컬럼을 줄이는 것이다. 따라서 테이블을 생성 시 컬럼을 지정할 때 순서를 잘 결정할 필요가 있다. 

			- **일체형 체인**: IOT 테이블의 생성시 INCLUDING과 임계치를 이용하여 결정되며 일체형 체인은 전략적으로 사용할 수 있다. 일체형의 체인은 단순히 체인되었다는 의미보다는 인덱스 영역의 저장 밀도를 향상시킬 수 있는 전략이라고 볼 수 있다. 
		
	- 클러스터링 테이블의 개념 

		- DBMS에서의 클러스터란 테이블이나 인덱스처럼 저장공간을 가지고 있는 하나의 오브젝트이다. 
		- 클러스터는 테이블의 상위 개념이다. 
		- 클러스터로 생성된 오브젝트 내에 테이블이 생성된다. 
		- 테이블이 없는 클러스터는 어떤 데이터도 입력할 수 없다.
		
	- 단일 테이블 클러스터링 

		- 클러스터에 하나의 테이블만을 생성시킨다. 
		- 같은 클러스터 컬럼 값을 가진 로우는 같은 장소에 저장되므로 넓은 범위의 데이터를 동시에 액세스하고자 할 때 주로 활용한다. 
	- 다중 클러스터링 

		- 다중 클러스터링이란?
		
			- 단위 클러스터에 두 개 이상의 테이블을 함께 저장하는 것이다. 
			- 같은 클러스터 키 컬럼 값을 가진 각 테이블의 로우는 정해진 장소에 같이 저장되므로 테이블 조인 속도를 향상 시키고자 할 때 주로 사용한다. 
			- 각 로우에는 클러스터 키 ID를 가지고 있으며, 블록헤더에 클러스터 정보를 가지고 있으므로, 단위 클러스터에는 동일한 값인 클러스터 키 값을 가질 필요가 없으며 클러스터 키 값은 실제로 저장되지 않는다. 

		- 해쉬 클러스터링 

			- 해쉬 클러스터링의 특징 
			
				- SIZE, HASHKEYS, HASH IS 파라미터를 변경할 수 없다
				- ```=```로만 액세스가 가능하다. 
				- 클러스터가 생성되면서 저장공간이 미리 할당된다. 
				- 지정된 클러스터보다 많은 로우가 들어오면 오버플로우 영역에 저장한다. 
				- 컬럼 값의 분포가 고르지 않으면 해쉬 Collsion이 발생한다. 
				- 인덱스를 경유하지 않고 액세스하므로 인덱스보다 효율적인 액세스를 할 수 있다. 

			- 해쉬 클러스터링의 활용 범위 

				- 각종 코드를 관리하는 테이블, 우편 번호, 시스템 사용자 정보를 관리하는 데 사용한다. 
				- 해쉬 클러스터에 저장시키는 개념의 좀 더 발전한 형태가 해쉬 파티션이므로, 해쉬 파티션을 적용하는 것이 옳다. 































