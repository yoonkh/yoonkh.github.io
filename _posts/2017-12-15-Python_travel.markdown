---
layout: post
title:  "파이썬을 여행하는 히치하이커를 위한 안내서 - 1장 인터프리터 선택하기, 2장 파이썬 설치하기"
date:   2017-12-15
author: Yoonkh
categories: Python
tags:	Python
comments: True
---


# 파이썬을 여행하는 히치하이커를 위한 안내서 

## 들어가기

### 인터프리터 언어 선택하기

#### 파이썬 2와 3 중 어느 버전을 선택할까?

파이썬 버전에 관한 몇 가지 사실 

- 오랜 시간 동안 파이썬 2.7이 표준이었다.
- 파이썬 3에서 많은 변화가 생겼고, 일부 개발자들은 이러한 변화 때문에 불행해졌다.
- 파이썬 2.7의 필수 보안 업데이트는 2020년까지 지속될 것이다.
- 파이썬 3는 파이썬 2가 지난 몇 년간 그래왔듯이 끊임없이 진화하고 있다.

#### 추천하는 파이썬 버전

**파이썬 3를 사용할 사람**

- 파이썬 3를 사랑한다.
- 어떤 버전을 사용할지 모르겠다.
- 변화를 좋아한다.

**파이썬 2를 사용할 사람**

- 파이썬 2를 사랑하며, 대다수가 파이썬 3를 사용할 미래를 떠올리면서 슬프다.
- 파이썬 3를 사용하면, 소프웨어의 안정성 요구사항이 영향을 받는다.
- 의존한느 소프트웨어가 파이썬 2를 필요로 한다.

### 파이썬 3가 최선일까?

### 구현 

사람들이 **파이썬**에 대해 얘기할 때, 파이썬 언어 자체를 언급하는 경우가 대다수지만 가끔 C파이썬 구현체(implementation)를 지칭하기도 한다. 실제로 파이썬은 다양한 방식으로 구현될 수 있다.

- **C파이썬**

	- C파이썬(CPython)은 파이썬의 표준 구현이며 C언어로 작성되었다. C파이썬은 파이썬 코드를 중간 바이트코드로 컴파일하고, 그 결과를 가상머신이 해석한다. C파이썬은 파이썬 패키지, C 확장 모듈과 호환성이 가장 높다.

- **스택리스**

	- 스택리스 파이썬(Stackless Python)은 보통의 C파이썬이며, C파이썬에서 사용 가능한 모든 라이브러리를 사용 할 수 있다. 그러나 파이썬 인터프리터를 호출 스택과 분리함으로써 코드 실행 순서를 변경할 수 있는 기능이 있다. 스택리스는 태스크릿(tasklet)이라는 콘셉트를 도입하여 함수를 감싸 '마이크로스레드(Microthread)로 바꾼다.

- **파이파이**

	- 파이파이(PyPy)는 파이썬 언어의 정적 타입 부분 집합인 RPython을 사용해 구현되었으며, 특정 종류의 최적화가 가능하다.
	
- **자이썬**

	- 자이썬(Jython)은 파이썬 코드를 자바 바이트코드로 컴파일하는 파이썬 인터프리터 구현이며, 컴파일 결과는 자바 가상머신에서 실행 될 수 있다. 자바 클래스를 파이썬 모듈 불러오듯 가져와 사용할 수도 있다.
	
- **아이언파이썬**

	- 아이언 파이썬(IronPython)은 닷넷(.NET) 프레임워크를 위한 파이썬 구현이다. 여기서는 파이썬 라이브러리와 닷넷 프레임워크 라이브러리를 모두 사용할 수 있으며, 파이썬 코드를 다른 닷넷 프레임워크 언어에 노출 시킬 수 있다.
	
- **파이썬넷**

	- 파이썬넷(PythonNet)은 파이썬을 위한 닷넷(Python for .NET)의 줄임말로, 파이썬과 닷넷 CLR(Common Language Runtime, 공용 언어 런타임)을 매끄럽게 통합한 패키지이다.
	
- **스컬트**

	- 스컬트(Skulpt)는 파이썬을 자바스크립트로 구현한 것이다. C파이썬의 표준 라이브러리가 모두 포팅되지는 않았으며, math, random, turtle, image, unittest time의 일부, urllib, DOM, re가 포함되어 있다.
	
- **마이크로파이썬**
	- 마이크로파이썬(MicroPython)은 마이크로 컨트롤러에서 실행되도록 최적화된 파이썬 3의 구현이며, Thumb v2명령어를 사용하는 32비트 ARM프로세서를 지원한다.

### 파이썬 설치하기

#### 맥에 파이썬 설치하기

맥 운영체제 최신 버전에는 파이썬 2.7이 내장되어 있다. 따라서 맥에서는 파이썬을 별도로 설치하거나 설정할 필요가 없다.

**Setuptools와 pip**

홈브류는 파이썬과 함께 Setuptools와 pip도 설치한다. 설치된 pip 실행 파일은 파이썬 3 기준 pip3, 파이썬 2 기준 pip 명령어에 매핑된다.

**virtualenv**

virtualenv는 고립된 파이썬 환경을 생성한다. 환경마다 폴더를 하나씩 만들어, 환경 내에서 패키지를 사용하는데 필요한 모든 실행 파일을 담는다.

#### 상용 파이썬 재배포판

소속 부서나 수업에서 파이썬 상용 재배포판(commercial redistribution)을 설치하면, 최소한의 작업으로 모두가 일관된 환경을 사용할 수 있다. 이번 절에 나열된 재배포판은 모두 파이썬의 C 구현(C파이썬)이다.

- **인텔의 파이썬 배보판**

	- 인텔의 파이썬 배보판의 지향점은 누구나 무료의 고성능 파이썬을 경험하는 것이다. 인텔 수학 커널 라이브러리와 같은 기본 라이브러리를 파이썬 패키지와 연결하고, 인텔 스레딩 빌딩 블록(Threading Building Block, TBB) 라이브러리를 포함한 향상된 스레딩 기능을 제공하여 성능이 대폭 향상되었다. 

- **컨티넘 애널리틱스의 아나콘다**

	- 컨티넘 애널리틱스의 파이썬 배포판은 BSD 라이선스로 배포되고 있으며, 무료패키지 색인에 나열된 수많은 과학/수학 바이너리가 미리 컴파일되어 제공된다. pip와는 다른 콘다(Conda)라는 패키지 관리자가 있다. 이 도구를 사용해 가상 환경도 관리할 수 있지만 가상 환경보다는 Buildout과 같은 역할을 한다. 즉, 사용자를 위해 라이브러리와 외부 의존성을 관리한다. 패키지 형식이 호환되지 않으니, 다른 인스톨러의 패키지 색인에 등록된 패키지는 설치할 수 없다.

- **액티브스테이트의 액티브파이썬**

	- 액티브 스테이트 배포판은 ActiveState Community Licence로 배포되며 무료 평가판이 제공된다. 그 외에는 라이선스를 구매해야 한다. 액티브 스테이트는 펄(Perl)과 Tcl을 위한 해법도 제공한다.

- **Enthought의 캐노피**

	- Enthought에서 제공하는 배포판은 Canopy Software License로 공개되었다. enpkg라는 패키지 관리자와 함께 제공되는데, 캐노피의 패키지 색인과 연결되어 pip 대신 사용한다.

### 개발 환경

#### 텍스트 편집기 

- **VS 코드**

	- 마이크로소프트는 2015년에 VS 코드(VS CODE)를 발표했다. 비주얼 스토디오 계열의 클로즈드 소스 무료 텍스트 편집기다. 깃허브의 일렉트론을 기반으로 작동한다. 텍스트메이트처럼 키 바인딩 기능이 있으며, 크로스 플랫폼 도구이다.


#### 통합 개발 환경

많은 개발자가 텍스트 편집기와 통합 개발 환경(integrated development environment, IDE)을 함께 사용한다. IDE는 크고 복잡한 협업 프로젝트에서 주로 사용한다.

- **파이참/인텔리제이 아이디어**

	- 파이참은 가장 사랑 받는 파이썬 IDE이다. 파이참의 코드 완성 도구는 거의 완벽하고, 웹 개발 도구 역시 훌륭하다. 과학 커뮤니티에서는 (웹 개발 도구가 포함되지 않은) 파이참 무료에디션도 충분히 편하다고 권하는 사람들이 있다. 파이참은 Jetbrains가 개발했다. Jetbrains는 이클립스와 경쟁하는 자바 IDE인 인텔리제이 아이디어(IntelliJ IDEA)로도 유명하다. 젯브레인(Jetbrain)에서는 파이썬 IDE로 파이참을 추천하지만, 자바와 결부된 작업, 예를 들어 자바와 파이썬 API를 통틀어 탐색을 수행하거나 자바에서 파이썬으로 포팅하는 용도로는 인텔리제이 아이디어를 추천한다.

#### 기능이 강화된 대화형 도구

IDLE은 실제로는 IDE지만, 이전 섹션에 포함되지 않았다. 대부분의 사람들이 대화형 도구가 (기업 프로젝트의 경우) IDE만큼 강력하지 않다고 여기기 때문이다. 대신, 교육용으로는 최적이다. IPython은 스파이더 IED와 통합되어 있으며, 다른 IDE에 통합 될 수도 있다. 대화형 도구는 파이썬 인터프리터를 대체하는 대신, 사용자가 선택한 인터프리터 셀을 추가 도구와 기능으로 보강한다.

- **IDLE**

	- IDLE은 통합 개발 학습 환경의 약자다. 파이썬 표준 라이브러리의 일부이며 파이썬과 함께 배포된다.

		- IDLE은 다음 기능을 제공한다. 
		
			- 파이썬 셀 창(인터프리터)
			 
			- 코드에 색을 입힌 여러 창의 텍스트 편집기
			
			- 최소한의 디버깅 능력

- **IPython**

	- IPython은 파이썬 상호작용을 돕기 위한 풍부한 툴킷을 제공한다. 주요 구성 요소는 다음과 같다.

		- 강력한 파이썬 셀(터미널과 Qt 기반)
		- 터미널 셀과 동일한 핵심 기능을 가진 웹 기반 노트북, 그리고 풍부한 미디어, 텍스트, 코드, 수식 표현, 화면 내 데이터 시각화를 표현

#### 격리도구

격리도구는 실행 중인 애플리케이션과 호스트 환경을 원하는 수준으로 격리 할 수 있도록 돕는다. 격리를 통해 다양한 파이썬 버전과 라이브러리 의존성 환경에서 코드를 테스트하고 디버그 할 수 있으며, 일관된 개발 환경을 유지할 수 있다

**도커**

도커(Docker)는 virtualenv, conda, Buildhour와 같이 환경 격리를 도와주지만 가상환경을 제공하는 대신 도커 컨테이너를 제공한다. 컨테이너는 가상환경보다 높은 수준의 격리를 제공한다. 예를 들자면, 컨테이너마다 다른 네트워크 인터페이스와 방화벽 규칙, 다른 호스트 이름을 사용할 수 있다. 이렇게 실행되는 컨테이너들은 운영체제로의 액세스를 조정하는 별도의 유틸리티인 도커 엔진을 사용해 관리한다. 

- 맥이나 윈도우, 혹은 원격 호스트에서 도커 컨테이너를 실행한다면, 가상 머신(들)과 인터페이스하는 도커 머신(Docker Machine)이 필요하다. 

- 도커 컨테이너는 셸 명령어와 관련이 있는 리눅스 컨테이너를 기반으로 만들어졌다. 

- 도커는 ```chroot```를 사용하지 않으며, 리눅스 컨테이너도 사용하지 않는다. 

- 도커 이미지를 올바르게 구성하면 Buildout 또는 conda를 사용하여 만든 환경보다 공간을 적게 차지한다. 도커가 이미지 전체를 저장하는 대신 이미지의 'diff'만 저장하는 AUFS 결합 파일 시스템을 사용하기 때문이다. 

## 실전 돌입하기

### 훌륭한 코드 작성하기 

#### 코드 스타일 

- **PEP8**

	- PEP8은 파이썬을 위한 코드 스타일 가이드이며 작명 컨벤션, 코드 레이아웃, 공백, 그 외 유사 스타일 주제를 다룬다. 대체로 파이썬 코드를 작성할 때는 PEP8을 준수하는 것이 좋다. 코드 스타일이 통일되면 한 프로젝트 안에서 여러 개발자가 코드의 일관성을 유지하며 개발할 수 있는 밑거름이 된다. 

- **PEP 20(파이썬 계명)**

	- PEP20은 파이썬 코드를 작성할 때 겪는 의사 결정에 도움을 주는 원리 모음이다. 파이썬 셸에서 import this를 입력하면 전문을 볼 수 있다. 이름과는 달리 20개가 아닌 19개의 경구만 포함되어 있다(마지막 경구는 아직 작성되지 않았다)

- **일반적인 조언**

	- 파이썬 스타일 철학

		- "명시가 암시보다 좋다" 
		
			다음은 두 개의 값을 입력 받아 이들로 구성된 딕셔너리 형태의 결과를 출력하는 코드의 예다.

			나쁜예)
			
			```
			def make_dict(*args):
				x, y = args
				return dict(**locals())
			```
			
			좋은예)
			
			```
			def make_dict(x, y):
				return {'x': x, 'y':y}
			```
			
			좋은예의 코드에서는 함수에 x와 y가 명시적으로 입력되어 이들로 구성된 딕셔너리가 명시적으로 출력된다. 다른 개발자들이 함수 코드 첫 줄과 마지막 줄만 읽고도 무슨 함수인지 이해할 수 있도록 코드를 작성해야 한다. 나쁜예의 코드에서는 입력 값과 출력 값, 그리고 함수의 내용을 한눈에 이해하기 어렵다(물론, 함수가 두 줄뿐이라면 쉽긴 하다)
			
		- "여유로운 것이 밀집한 것보다 좋다" 

			한 줄에 하나의 구문만 작성하자. 간혹 리스트 컴프리헨션(list comprehension)과 같은 일부 복합 구문은 간결성과 표현성이 뛰어나기에 여러 개의 줄이 되어도 괜찮다. 그러나 서로 다른 구문은 여러 개의 줄로 구분하는 게 좋다. 이는 코드의 diff 결과의 가독성을 높이기도 한다. 
			
			나쁜예)
			
			```
			print('one'); print('two')
			
			if x == 1: print('one')
			
			if (<복잡한 표현 1> and
				 <복잡한 표현 >):
				 # 원하는 작업 수행 
		   	```
		   
		   	좋은예)
		   
		   	```
			   print('one')
			   print('two')

			   if x == 1:
			       print('one')
		       
			      cond1 = <복잡한 표현 1>
			      cond2 = <복잡한 표현 2>
			      if cond1 and cond2:
					# 원하는 작업 수행 
		   	``` 
      	   
      	   		파이써니스타들은 코드가 길어지더라도 한 줄에 한 구문씩 작성하고, 긴 조건무늘 여러 줄로 나누어 작성한다. 가독성을 위해서라면 파일 크기가 몇 바이트 증가하거나 계산 시간이 수 마이크로초 증가하는 것쯤은 기꺼이 감수한다. 
      	   
   		- "오류 앞에서 절대 침묵하지 말지어다" 

			파이썬에서는 try문을 사용하여 오류를 처리한다. 다음의 내용은 벤자민 글라이츠만의 HowDoI 패키기 코드 중 일부이며, 오류 앞에서 침묵해도 되는 상황이 언제인지 알 수 있다.
			
			```
			def format_output(code, args):
	  	   			if not args['color']:
	  	   				return code
	   				lexer = None
	   				
	   				# 스택오버플로 태그에서 렉서를 찾거나
	   				# 쿼리 문자열로부터 렉서를 찾으려 시도
	   				for keyword in args['query'].split() + args['tags']:
	   					try:
	   						lexer = get_lexer_by_name(keyword)
	   						break
						except ClassNotFound:
							pass
							
					# 위에서 렉서를 찾지 못하면 렉서 추정 도구(guess_lexer)를 사용함
					if not lexer:
						lexer = guess_lexer(code)
						
					return highlight(code, lexer, TerminalFomatter(bg='dark'))
			``` 			
			
		- "함수 인자는 사용하기에 직관적이어야 한다"

			API 디자인에 따라 함수를 통해 소통하는 다운스트림 개발자의 경험이 달라진다. 인자는 다음과 같은 네 가지 방법으로 함수에 전달 될 수 있다.
			
			```
			def func(positional, keyword=value, *args, **kwargs):
				pass
			```
			
			1. 위치 인자(positional)은 필수이며 기본 값을 가지지 않는다.
			2. 키워드 인자(keyword=value)는 선택 사항이며 기본 값을 가진다.
			3. 가변 인자 리스트(*args)는 선택 사항이며 기본 값을 가진다. 
			4. 가변 키워드 인자 딕셔너리(**kwargs)는 선택 사항이며 기본 값을 가진다. 

		- "구현 결과를 설명하기 어렵다면, 그 아이디어는 나쁘다." 

			파이썬은 해커를 위한 강력한 도구이며, 어떠한 종류의 까다로운 작업도 가능하게 하는 후크와 도구를 풍부하게 보유하고 있다. 예를 들어 파이썬에서는 다음 작업이 가능하다. 
			
			- 객체를 생성하고 인스턴스화하는 방법을 변경
			- 파이썬 인터프리터가 모듈을 불러오는 방법을 변경
			- C 루틴을 파이썬에 임베딩

		- "우리는 모두 책임 있는 사용자다"

			파이썬에는 '프라이빗' 키워드가 없기 때문에 클라이언트 코드가 객체의 속성과 메서드를 덮어쓸 수 있다. 이는 자바와 같은 방어적 성격의 프로그래밍 언어와 매우 다른 철학을 보여준다. 자바에는 사용자가 안전한 방식으로 코드를 작성할 수 있도록 보호하는 장치가 내장되어 있지만, 파이썬은 그렇지 않다. 따라서 파이썬 사용자는 모두 책임감을 가져야 한다. 
			
		- "함수의 결과값은 한 곳에서만 반환하자"

			함수가 복잡할수록 반환문의 개수가 증가하기 쉽다. 그러나 의도를 명확히 하고 가독성을 유지하려면 의미 있는 결과 값을 최대한 적은 위치에서 반환하는 게 좋다. 함수 실행이 종료되는 경우는 두 가지다. 하나는 오류가 발생하여 종료되는 경우이고, 나머지 하나는 함수가 정상적으로 실행되어 결과 값을 반환한 뒤 종료되는 경우이다. 함수 실행 중 오류가 발생하면 None이나 False를 반환하는 것이 적절하다. 이 때 함수에서 오류와 관련된 문맥이 파악되자마자 결과 값을 반환하도록 하여 함수 구조를 수평적으로 만드는 것이 좋다. 만약 오류가 발생하지 않는다면, 그 다음 코드가 실행되기 위한 조건이 충족된 것이며, 함수 실행이 멈추지 않고 지속된다. 가끔은 여러 개의 반환문을 사용하는 것도 필요하다. 

- **컨벤션**

	- 컨벤션은 모두에게 수긍이 가는 방식이지만 유일한 선택지는 아니다. 컨벤션은 일반적으로 널리 사용되며, 코드의 가독성을 높이는 데 도움이 된다.

		- 같음을 확인하기 위한 대안

			나쁜예)
			
			```
			if attr == True:
			print 'True!'
			
			if attr == None:
			print 'attr is None!'
			```
			
			좋은예)
			
			```
			# 값이 존재하는지 확인
			if attr:
				print 'attr is truthy!'
				
			# 값이 존재하지 않는지 확인
			if not attr:
				print 'attr is falsey!'
				
			# 값이 'True'인지 확인
			if attr is True:
				print 'attr is True'
				
			# 값이 'None'인지 확인
			if attr is None:
				print 'attr is None!'
			```
			
		- 딕셔너리 요소에 접근하기 

			dict.has_key 메서드 대신 x in d 구문을 사용하거나 dict.get()에 기본 인자를 전달하자.
			
			나쁜예)
			
			```
			>>> d = {'hello': 'world'}
			>>>
			>>> if d.has_key('hello'):
			... 	print(d['hello']) # 'world' 출력
			... else:
			... 	print('default_value')
			world
			```
			
			좋은예)
			
			```
			>>> d = {'hello': 'world}
			>>> 
			>>> print (d.get('hello', 'default_value')
			world
			>>> print (d.get('howdy', 'default_value')
			default_value
			>>>
			>>> # 아니면,
			... if 'hello' in d:
			... 	print(d['hello'])
			...
			world
			```
			
		- 리스트 다루기

			리스트 컴프리헨션은 리스트 자료형을 다루는 명확하고 강력한 도구다!
			
			일반 반복문)
			
			```
			# 4보다 큰 성분만 남기기
			a = [3, 4, 5]
			b = []
			for i in a:
				if i > 4:
					b.append(a)
					
			# 모든 리스트 성분에 3씩 더하기
			a = [3, 4, 5]
			for i in range(len(a)):
				a[i] += 3
			```
			
			리스트 컴프리헨션)
			
			```
			# 리스트 컴프리헨션이 좀 더 깔끔하다
			a = [3, 4, 5]
			b = [i for i in a if i > 4]
			
			# 아니면 다음과 같이 사용해보자
			b = filter(lambda x: x > 4, a)
			
			# 여기도 마찬가지로 깔끔하다
			a = [3, 4, 5]
			a = [i + 3 for i in a]
			
			# 람다 표현식을 사용할 수도 있다
			a = map(lambda i: i + 3, a)
			```
			







			







			





















