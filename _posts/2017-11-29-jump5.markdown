---
layout: post
title:  "Jump to Python - 파이썬 프로그래밍, 어떻게 시작해야할까?"
date:   2017-11-29
author: Yoonkh
categories: Python
tags:	Python
comments: True
---


## 내가 프로그램을 만들 수 있을까?

**"문법도 어느 정도 알겠고, 책 내용도 대부분 이해된다. 하지만 이러한 지식을 바탕으로 내가 도대체 어떤 프로그램을 만들 수 있을까?"**

- 이럴 때는 "어떤 프로그램을 짜야지"라는 생각보다는 다른 사람들이 만든 프로그램 파일을 자세히 들여다보고 분석하는 데서 시작하는 것이 좋다!!!

```
프로그램을 만들려면 가장 먼저 "입력"과 "출력"을 생각하라.
```

#### 연습!

- 함수 이름은? GuGu로 짓자
- 입력받는 값은? 2
- 출력하는 값은? 2단(2, 4, 6, 8, …, 18)
- 결과는 어떤 형태로 저장하지? 연속된 자료형이니까 리스트!

1. 에디터를 열고 다음과 같이 입력한다. GuGu라는 함수에 2를 입력값으로 주면 result라는 변수에 결과값을 넣으라는 뜻이다.

```
result = GuGu(2)
```

2. 이제 결과값을 어떤 형태로 받을 것인지 고민해 보자. 2단이니까 2, 4, 6, ... 18까지 갈 것이다. 이런 종류의 데이터는 리스트 자료형이 딱이다

3. 자, 일단 이름을 GuGu로 지은 함수를 다음과 같이 만들어 보자.

```
def GuGu(n):
    print(n)
```

- 위와 같은 함수를 만들고 GuGu(2)처럼 실행하면 2를 출력하게 된다. 즉, 입력값으로 2가 잘 들어오는지 확인하는 것이다.

4. 이제 결과값을 담을 리스트를 하나 생성하자. 앞에서 작성한 print(n)은 입력이 잘 되는지를 확인하기 위한 것이었으므로 지워도 좋다.

```
def GuGu(n):
    result = []
```

5. 다음으로 result에 2, 4, 6,... 18을 어떻게 넣어야 할지 생각해 보자. 필자는 다음과 같이 리스트에 요소를 추가하는 append 내장 함수를 사용하기로 결정했다.

```
def GuGu(n):
    result = []
    result.append(n*1)
    result.append(n*2)
    result.append(n*3)
    result.append(n*4)
    result.append(n*5)
    result.append(n*6)
    result.append(n*7)
    result.append(n*8)
    result.append(n*9)
    return result

print(GuGu(2))
```

**결과값: [2, 4, 6, 8, 10, 12, 14, 16, 18]**

정말 무식한 방법이지만 입력값 2를 주었을 때 원하는 결과값을 얻을 수 있다.

6. 그런데 위의 함수는 반복이 너무 많다. 가만히 보면 result.append(n*□)의 □위치에 1부터 9까지 숫자만 다르게 들어가 있다는 것을 알 수 있다. 똑같은 일을 반복할 때는 "반복문"을 사용한다고 했다. 그렇다면 1부터 9까지 출력해 주는 반복문을 만들면 되지 않을까?

```
>>> i = 1
>>> while i < 10:
...     print(i)
...     i = i + 1
```

```
결과값:
1
2
3
4
5
6
7
8
9
```

7. 이상의 생각들을 바탕으로 완성한 GuGu 함수는 다음과 같다.

```
def GuGu(n):
    result = []
    i = 1
    while i < 10:
        result.append(n * i)
        i = i + 1
    return result
```

#### TEST

```
print(GuGu(2))
```

**결과값: [2, 4, 6, 8, 10, 12, 14, 16, 18]**

# 결과는 대만족이다!!!
    
## 3과 5의 배수 합치기

```
10 미만의 자연수에서 3과 5의 배수를 구하면 3, 5, 6, 9이다. 이들의 총합은 23이다.
1000 미만의 자연수에서 3의 배수와 5의 배수의 총합을 구하라.
```

```
result = 0
for n in range(1, 1000):
    if n % 3 == 0 or n % 5 == 0: 
        result += n
print(result)
```

- 이 문제에는 한가지 함정이 있는데 3으로도 5로도 나누어지는 15와 같은 수를 이중으로 더해서는 안 된다는 점이다. 따라서 15와 같이 3의 배수도 되고 5의 배수도 되는 값이 이중으로 더해지지 않기 위해 or 연산자를 사용

## 게시판 페이징하기

A 씨는 게시판 프로그램을 작성하고 있다. 그런데 게시물의 총 건수와 한 페이지에 보여줄 게시물 수를 입력으로 주었을 때 총 페이지수를 출력하는 프로그램이 필요하다고 한다.

- A씨가 필요한 프로그램을 만들기 위해 입력값과 결과값이 어떻게 나와야 하는지 먼저 살펴봐야한다. 게시물의 총 건수가 5이고 한 페이지에서 보여 줄 게시물 수가 10이면 총 페이지수는 당연히 1이 된다. 만약 게시물의 총 건수가 15이고 한 페이지에서 보여 줄 게시물 수가 10이라면 총 페이지수는 2가 될 것이다.

1. 다음과 같이 총 건수(m)를 한 페이지에 보여줄 게시물 수(n)로 나누고 1을 더하면 총 페이지수를 얻을 수 있다.

```
총 페이지수 = 총 건수 / 한 페이지당 보여줄 건수 + 1
```

2. 이러한 공식을 적용했을 경우 총 페이지수가 표의 값처럼 구해지는지 확인해 보자(m을 n으로 나눌 때 소수점 아래 자리를 버리기 위해서 / 대신 // 연산자를 사용하였다).

```
def getTotalPage(m, n):
    return m // n + 1

print(getTotalPage(5, 10))    # 1 출력
print(getTotalPage(15, 10))   # 2 출력
print(getTotalPage(25, 10))   # 3 출력
print(getTotalPage(30, 10))   # 4 출력
```

3. 실패 케이스는 총 게시물 수와 한 페이지에 보여줄 게시물 수를 나눈 나머지 값이 0이 될 때 발생함을 유추할 수 있을 것이다. 이 실패 케이스를 해결하려면 다음과 같이 코드를 변경해야 한다.

```
def getTotalPage(m, n):
    if m % n == 0:
        return m // n
    else:
        return m // n + 1

print(getTotalPage(5, 10))
print(getTotalPage(15, 10))
print(getTotalPage(25, 10))
print(getTotalPage(30, 10))
```

## 간단한 메모장 만들기

```
# C:/Python/memo.py
import sys

option = sys.argv[1]
memo = sys.argv[2]

print(option)
print(memo)
```

2. memo.py를 작성했다면 다음과 같은 명령을 수행해 보자.

```
C:\Python>python memo.py -a "Life is too short"
-a
Life is too short
```

3. 이제 입력으로 받은 메모를 파일에 쓰도록 코드를 변경해 보자.

```
# c:/Python/memo.py
import sys

option = sys.argv[1]

if option == '-a':
    memo = sys.argv[2]
    f = open('memo.txt', 'a')
    f.write(memo)
    f.write('\n')
    f.close()
```

4. 이제 다음과 같은 명령을 수행해 보자.

```
C:\Python>python memo.py -a "Life is too short"  
C:\Python>python memo.py -a "You need python"
```

- 그리고 파일에 정상적으로 메모가 기입되었는지 다음과 같이 확인해 보자.

```
C:\Python>type memo.txt
Life is too short
You need python
```

5. 이번에는 작성한 메모를 출력하는 부분을 만들 차례이다. 메모 출력은 다음과 같이 동작하도록 만들어 보자.

```
python memo.py -v
```

- 이제 메모 출력을 위해서 다음과 같이 코드를 변경해 보자.

```
# c:/Python/memo.py
import sys

option = sys.argv[1]

if option == '-a':
    memo = sys.argv[2]
    f = open('memo.txt', 'a')
    f.write(memo)
    f.write('\n')
    f.close()
elif option == '-v':
    f = open('memo.txt')
    memo = f.read()
    f.close()
    print(memo)
```

6. 코드를 수정한 후 다음과 같은 명령을 수행해 보자.

```
C:\Python>python memo.py -v
Life is too short
You need python
```

## 탭을 4개의 공백으로 바꾸기

문서 파일을 읽어서 그 문서 파일 내에 있는 탭(tab)을 공백(space) 4개로 바꾸어주는 스크립트

1. 우선 다음과 같이 tabto4.py 파일을 작성해 보자.

```
# c:/Python/tabto4.py
import sys

src = sys.argv[1]
dst = sys.argv[2]

print(src)
print(dst)
```

2. 다음과 같이 수행했을 때 입력값들이 정상적으로 출력되는지 확인해 보자.

```
C:\Python>python tabto4.py a.txt b.txt
a.txt
b.txt
```

- 입력으로 전달한 a.txt와 b.txt가 정상적으로 출력되는 것을 확인할 수 있다.

3. 테스트를 위한 원본 파일(탭을 포함하는 파일)인 a.txt를 다음과 같이 작성한다. 각 단어들은 탭(\t) 문자로 분리되도록 입력해야 한다.

```
Life    is  too short
You need    python
```

4. 이제 탭 문자를 포함한 a.txt 파일을 읽어서 탭을 공백 4개로 변환할 수 있도록 코드를 변경해 보자.

```
# c:/Python/tabto4.py
import sys

src = sys.argv[1]
dst = sys.argv[2]

f = open(src)
tab_content = f.read()
f.close()

space_content = tab_content.replace("\t", " "*4)
print(space_content)
```

5. tabto4.py를 위와 같이 변경한 후 다음과 같은 명령을 수행해 보자.

```
C:\Python>python tabto4.py a.txt b.txt
Life    is    too    short
You    need    python
```

6. 이제 변경된 내용을 b.txt 파일에 저장할 수 있도록 다음과 같이 프로그램을 변경해 보자.

```
# c:/Python/tabto4.py
import sys

src = sys.argv[1]
dst = sys.argv[2]

f = open(src)
tab_content = f.read()
f.close()

space_content = tab_content.replace("\t", " "*4)

f = open(dst, 'w')
f.write(space_content)
f.close()
```

7. 프로그램을 실행하기 위해 다음과 같은 명령을 수행한다.

```
C:\Python>python tabto4.py a.txt b.txt
```

## 하위 디렉토리 검색하기

1. 우선 다음과 같이 sub_dir_search.py 파일을 작성해 보자.

```
# C:/Python/sub_dir_search.py

def search(dirname):
    print (dirname)

search("c:/")
```

2. 이제 이 디렉터리에 있는 파일들을 검색할 수 있도록 소스를 변경해 보자.

```
# C:/Python/sub_dir_search.py
import os

def search(dirname):
    filenames = os.listdir(dirname)
    for filename in filenames:
        full_filename = os.path.join(dirname, filename)
        print (full_filename)

search("c:/")
```

3. 이제 C:/ 디렉터리에 있는 파일들 중 확장자가 .py인 파일들만을 출력하도록 코드를 변경해 보자.

```
# C:/Python/sub_dir_search.py
import os

def search(dirname):
    filenames = os.listdir(dirname)
    for filename in filenames:
        full_filename = os.path.join(dirname, filename)
        ext = os.path.splitext(full_filename)[-1]
        if ext == '.py': 
            print(full_filename)

search("c:/")
```

4. 하지만 우리가 원하는 것은 ```C:/``` 디렉터리 바로 밑에 있는 파일 뿐만 아니라 그 하위 디렉터리(sub directory)를 포함한 모든 파이썬 파일들을 검색하는 것이다. 하위 디렉터리도 검색이 가능하게 하기 위해서는 다음과 같이 코드를 변경해야 한다.

```
# C:/Python/sub_dir_search.py
import os

def search(dirname):
    try:
        filenames = os.listdir(dirname)
        for filename in filenames:
            full_filename = os.path.join(dirname, filename)
            if os.path.isdir(full_filename):
                search(full_filename)
            else:
                ext = os.path.splitext(full_filename)[-1]
                if ext == '.py': 
                    print(full_filename)
    except PermissionError:
        pass

search("c:/")
```

- try ... except PermissionError로 함수 전체를 감싼 이유는 os.listdir 수행 시 권한이 없는 디렉터리에 접근하더라도 프로그램이 오류로 종료되지 않고 그냥 수행되도록 하기 위해서이다.
