---
layout: post
title:  "파이썬을 여행하는 히치하이커를 위한 안내서 - 훌륭한 코드 작성하기"
date:   2017-12-16
author: Yoonkh
categories: Python
tags:	Python
comments: True
---

## 실전 돌입하기

### 훌륭한 코드 작성하기 

#### 코드 스타일 

- **PEP8**

	- PEP8은 파이썬을 위한 코드 스타일 가이드이며 작명 컨벤션, 코드 레이아웃, 공백, 그 외 유사 스타일 주제를 다룬다. 대체로 파이썬 코드를 작성할 때는 PEP8을 준수하는 것이 좋다. 코드 스타일이 통일되면 한 프로젝트 안에서 여러 개발자가 코드의 일관성을 유지하며 개발할 수 있는 밑거름이 된다. 

- **PEP 20(파이썬 계명)**

	- PEP20은 파이썬 코드를 작성할 때 겪는 의사 결정에 도움을 주는 원리 모음이다. 파이썬 셸에서 import this를 입력하면 전문을 볼 수 있다. 이름과는 달리 20개가 아닌 19개의 경구만 포함되어 있다(마지막 경구는 아직 작성되지 않았다)

- **일반적인 조언**

	- 파이썬 스타일 철학

		- "명시가 암시보다 좋다" 
		
			다음은 두 개의 값을 입력 받아 이들로 구성된 딕셔너리 형태의 결과를 출력하는 코드의 예다.

			나쁜예)
			
			```
			def make_dict(*args):
				x, y = args
				return dict(**locals())
			```
			
			좋은예)
			
			```
			def make_dict(x, y):
				return {'x': x, 'y':y}
			```
			
			좋은예의 코드에서는 함수에 x와 y가 명시적으로 입력되어 이들로 구성된 딕셔너리가 명시적으로 출력된다. 다른 개발자들이 함수 코드 첫 줄과 마지막 줄만 읽고도 무슨 함수인지 이해할 수 있도록 코드를 작성해야 한다. 나쁜예의 코드에서는 입력 값과 출력 값, 그리고 함수의 내용을 한눈에 이해하기 어렵다(물론, 함수가 두 줄뿐이라면 쉽긴 하다)
			
		- "여유로운 것이 밀집한 것보다 좋다" 

			한 줄에 하나의 구문만 작성하자. 간혹 리스트 컴프리헨션(list comprehension)과 같은 일부 복합 구문은 간결성과 표현성이 뛰어나기에 여러 개의 줄이 되어도 괜찮다. 그러나 서로 다른 구문은 여러 개의 줄로 구분하는 게 좋다. 이는 코드의 diff 결과의 가독성을 높이기도 한다. 
			
			나쁜예)
			
			```
			print('one'); print('two')
			
			if x == 1: print('one')
			
			if (<복잡한 표현 1> and
				 <복잡한 표현 >):
				 # 원하는 작업 수행 
		   ```
		   
		   좋은예)
		   
		   ```
		   print('one')
		   print('two')
		   
		   if x == 1:
		       print('one')
		       
	      cond1 = <복잡한 표현 1>
	      cond2 = <복잡한 표현 2>
	      if cond1 and cond2:
	      		# 원하는 작업 수행 
      	   ``` 
      	   
      	   파이써니스타들은 코드가 길어지더라도 한 줄에 한 구문씩 작성하고, 긴 조건무늘 여러 줄로 나누어 작성한다. 가독성을 위해서라면 파일 크기가 몇 바이트 증가하거나 계산 시간이 수 마이크로초 증가하는 것쯤은 기꺼이 감수한다. 
      	   
		- "오류 앞에서 절대 침묵하지 말지어다" 

			- 파이썬에서는 try문을 사용하여 오류를 처리한다. 다음의 내용은 벤자민 글라이츠만의 HowDoI 패키기 코드 중 일부이며, 오류 앞에서 침묵해도 되는 상황이 언제인지 알 수 있다.
			
			```
			def format_output(code, args):
	  	   			if not args['color']:
	  	   				return code
	   				lexer = None
	   				
	   				# 스택오버플로 태그에서 렉서를 찾거나
	   				# 쿼리 문자열로부터 렉서를 찾으려 시도
	   				for keyword in args['query'].split() + args['tags']:
	   					try:
	   						lexer = get_lexer_by_name(keyword)
	   						break
						except ClassNotFound:
							pass
							
					# 위에서 렉서를 찾지 못하면 렉서 추정 도구(guess_lexer)를 사용함
					if not lexer:
						lexer = guess_lexer(code)
						
					return highlight(code, lexer, TerminalFomatter(bg='dark'))
			``` 			
			
		- "함수 인자는 사용하기에 직관적이어야 한다"

			API 디자인에 따라 함수를 통해 소통하는 다운스트림 개발자의 경험이 달라진다. 인자는 다음과 같은 네 가지 방법으로 함수에 전달 될 수 있다.
			
			```
			def func(positional, keyword=value, *args, **kwargs):
				pass
			```
				
			1. 위치 인자(positional)은 필수이며 기본 값을 가지지 않는다.
			2. 키워드 인자(keyword=value)는 선택 사항이며 기본 값을 가진다.
			3. 가변 인자 리스트(*args)는 선택 사항이며 기본 값을 가진다. 
			4. 가변 키워드 인자 딕셔너리(**kwargs)는 선택 사항이며 기본 값을 가진다. 
	
		- "구현 결과를 설명하기 어렵다면, 그 아이디어는 나쁘다." 

			파이썬은 해커를 위한 강력한 도구이며, 어떠한 종류의 까다로운 작업도 가능하게 하는 후크와 도구를 풍부하게 보유하고 있다. 예를 들어 파이썬에서는 다음 작업이 가능하다. 
			
			- 객체를 생성하고 인스턴스화하는 방법을 변경
			- 파이썬 인터프리터가 모듈을 불러오는 방법을 변경
			- C 루틴을 파이썬에 임베딩

		- "우리는 모두 책임 있는 사용자다"

			파이썬에는 '프라이빗' 키워드가 없기 때문에 클라이언트 코드가 객체의 속성과 메서드를 덮어쓸 수 있다. 이는 자바와 같은 방어적 성격의 프로그래밍 언어와 매우 다른 철학을 보여준다. 자바에는 사용자가 안전한 방식으로 코드를 작성할 수 있도록 보호하는 장치가 내장되어 있지만, 파이썬은 그렇지 않다. 따라서 파이썬 사용자는 모두 책임감을 가져야 한다. 
			
		- "함수의 결과값은 한 곳에서만 반환하자"

			함수가 복잡할수록 반환문의 개수가 증가하기 쉽다. 그러나 의도를 명확히 하고 가독성을 유지하려면 의미 있는 결과 값을 최대한 적은 위치에서 반환하는 게 좋다. 함수 실행이 종료되는 경우는 두 가지다. 하나는 오류가 발생하여 종료되는 경우이고, 나머지 하나는 함수가 정상적으로 실행되어 결과 값을 반환한 뒤 종료되는 경우이다. 함수 실행 중 오류가 발생하면 None이나 False를 반환하는 것이 적절하다. 이 때 함수에서 오류와 관련된 문맥이 파악되자마자 결과 값을 반환하도록 하여 함수 구조를 수평적으로 만드는 것이 좋다. 만약 오류가 발생하지 않는다면, 그 다음 코드가 실행되기 위한 조건이 충족된 것이며, 함수 실행이 멈추지 않고 지속된다. 가끔은 여러 개의 반환문을 사용하는 것도 필요하다. 

- **컨벤션**

	- 컨벤션은 모두에게 수긍이 가는 방식이지만 유일한 선택지는 아니다. 컨벤션은 일반적으로 널리 사용되며, 코드의 가독성을 높이는 데 도움이 된다.

		- 같음을 확인하기 위한 대안

			나쁜예)
			
			```
			if attr == True:
			print 'True!'
			
			if attr == None:
			print 'attr is None!'
			```
			
			좋은예)
			
			```
			# 값이 존재하는지 확인
			if attr:
				print 'attr is truthy!'
				
			# 값이 존재하지 않는지 확인
			if not attr:
				print 'attr is falsey!'
				
			# 값이 'True'인지 확인
			if attr is True:
				print 'attr is True'
				
			# 값이 'None'인지 확인
			if attr is None:
				print 'attr is None!'
			```
			
		- 딕셔너리 요소에 접근하기 

			dict.has_key 메서드 대신 x in d 구문을 사용하거나 dict.get()에 기본 인자를 전달하자.
			
			나쁜예)
			
			```
			>>> d = {'hello': 'world'}
			>>>
			>>> if d.has_key('hello'):
			... 	print(d['hello']) # 'world' 출력
			... else:
			... 	print('default_value')
			world
			```
			
			좋은예)
			
			```
			>>> d = {'hello': 'world}
			>>> 
			>>> print (d.get('hello', 'default_value')
			world
			>>> print (d.get('howdy', 'default_value')
			default_value
			>>>
			>>> # 아니면,
			... if 'hello' in d:
			... 	print(d['hello'])
			...
			world
			```
			
		- 리스트 다루기

			리스트 컴프리헨션은 리스트 자료형을 다루는 명확하고 강력한 도구다!
			
			일반 반복문)
			
			```
			# 4보다 큰 성분만 남기기
			a = [3, 4, 5]
			b = []
			for i in a:
				if i > 4:
					b.append(a)
					
			# 모든 리스트 성분에 3씩 더하기
			a = [3, 4, 5]
			for i in range(len(a)):
				a[i] += 3
			```
			
			리스트 컴프리헨션)
			
			```
			# 리스트 컴프리헨션이 좀 더 깔끔하다
			a = [3, 4, 5]
			b = [i for i in a if i > 4]
			
			# 아니면 다음과 같이 사용해보자
			b = filter(lambda x: x > 4, a)
			
			# 여기도 마찬가지로 깔끔하다
			a = [3, 4, 5]
			a = [i + 3 for i in a]
			
			# 람다 표현식을 사용할 수도 있다
			a = map(lambda i: i + 3, a)
			```
			







