---
layout: post
title:  "파이썬을 여행하는 히치하이커를 위한 안내서 - 훌륭한 코드 작성하기"
date:   2017-12-16
author: Yoonkh
categories: Python
tags:	Python
comments: True
---

## 실전 돌입하기

### 훌륭한 코드 작성하기 

#### 코드 스타일 

- **PEP8**

	- PEP8은 파이썬을 위한 코드 스타일 가이드이며 작명 컨벤션, 코드 레이아웃, 공백, 그 외 유사 스타일 주제를 다룬다. 대체로 파이썬 코드를 작성할 때는 PEP8을 준수하는 것이 좋다. 코드 스타일이 통일되면 한 프로젝트 안에서 여러 개발자가 코드의 일관성을 유지하며 개발할 수 있는 밑거름이 된다. 

- **PEP 20(파이썬 계명)**

	- PEP20은 파이썬 코드를 작성할 때 겪는 의사 결정에 도움을 주는 원리 모음이다. 파이썬 셸에서 import this를 입력하면 전문을 볼 수 있다. 이름과는 달리 20개가 아닌 19개의 경구만 포함되어 있다(마지막 경구는 아직 작성되지 않았다)

- **일반적인 조언**

	- 파이썬 스타일 철학

		- "명시가 암시보다 좋다" 
		
			다음은 두 개의 값을 입력 받아 이들로 구성된 딕셔너리 형태의 결과를 출력하는 코드의 예다.

			나쁜예)
			
			```
			def make_dict(*args):
				x, y = args
				return dict(**locals())
			```
			
			좋은예)
			
			```
			def make_dict(x, y):
				return {'x': x, 'y':y}
			```
			
			좋은예의 코드에서는 함수에 x와 y가 명시적으로 입력되어 이들로 구성된 딕셔너리가 명시적으로 출력된다. 다른 개발자들이 함수 코드 첫 줄과 마지막 줄만 읽고도 무슨 함수인지 이해할 수 있도록 코드를 작성해야 한다. 나쁜예의 코드에서는 입력 값과 출력 값, 그리고 함수의 내용을 한눈에 이해하기 어렵다(물론, 함수가 두 줄뿐이라면 쉽긴 하다)
			
		- "여유로운 것이 밀집한 것보다 좋다" 

			한 줄에 하나의 구문만 작성하자. 간혹 리스트 컴프리헨션(list comprehension)과 같은 일부 복합 구문은 간결성과 표현성이 뛰어나기에 여러 개의 줄이 되어도 괜찮다. 그러나 서로 다른 구문은 여러 개의 줄로 구분하는 게 좋다. 이는 코드의 diff 결과의 가독성을 높이기도 한다. 
			
			나쁜예)
			
			```
			print('one'); print('two')
			
			if x == 1: print('one')
			
			if (<복잡한 표현 1> and
				 <복잡한 표현 >):
				 # 원하는 작업 수행 
		   ```
		   
		   좋은예)
		   
		   ```
		   print('one')
		   print('two')
		   
		   if x == 1:
		       print('one')
		       
	      cond1 = <복잡한 표현 1>
	      cond2 = <복잡한 표현 2>
	      if cond1 and cond2:
	      		# 원하는 작업 수행 
      	   ``` 
      	   
      	   파이써니스타들은 코드가 길어지더라도 한 줄에 한 구문씩 작성하고, 긴 조건무늘 여러 줄로 나누어 작성한다. 가독성을 위해서라면 파일 크기가 몇 바이트 증가하거나 계산 시간이 수 마이크로초 증가하는 것쯤은 기꺼이 감수한다. 
      	   
		- "오류 앞에서 절대 침묵하지 말지어다" 

			- 파이썬에서는 try문을 사용하여 오류를 처리한다. 다음의 내용은 벤자민 글라이츠만의 HowDoI 패키기 코드 중 일부이며, 오류 앞에서 침묵해도 되는 상황이 언제인지 알 수 있다.
			
				```
				def format_output(code, args):
						if not args['color']:
							return code
						lexer = None

						# 스택오버플로 태그에서 렉서를 찾거나
						# 쿼리 문자열로부터 렉서를 찾으려 시도
						for keyword in args['query'].split() + args['tags']:
							try:
								lexer = get_lexer_by_name(keyword)
								break
							except ClassNotFound:
								pass

						# 위에서 렉서를 찾지 못하면 렉서 추정 도구(guess_lexer)를 사용함
						if not lexer:
							lexer = guess_lexer(code)

						return highlight(code, lexer, TerminalFomatter(bg='dark'))
				``` 			
			
		- "함수 인자는 사용하기에 직관적이어야 한다"

			API 디자인에 따라 함수를 통해 소통하는 다운스트림 개발자의 경험이 달라진다. 인자는 다음과 같은 네 가지 방법으로 함수에 전달 될 수 있다.
			
			```
			def func(positional, keyword=value, *args, **kwargs):
				pass
			```
				
			1. 위치 인자(positional)은 필수이며 기본 값을 가지지 않는다.
			2. 키워드 인자(keyword=value)는 선택 사항이며 기본 값을 가진다.
			3. 가변 인자 리스트(*args)는 선택 사항이며 기본 값을 가진다. 
			4. 가변 키워드 인자 딕셔너리(**kwargs)는 선택 사항이며 기본 값을 가진다. 
	
		- "구현 결과를 설명하기 어렵다면, 그 아이디어는 나쁘다." 

			파이썬은 해커를 위한 강력한 도구이며, 어떠한 종류의 까다로운 작업도 가능하게 하는 후크와 도구를 풍부하게 보유하고 있다. 예를 들어 파이썬에서는 다음 작업이 가능하다. 
			
			- 객체를 생성하고 인스턴스화하는 방법을 변경
			- 파이썬 인터프리터가 모듈을 불러오는 방법을 변경
			- C 루틴을 파이썬에 임베딩

		- "우리는 모두 책임 있는 사용자다"

			파이썬에는 '프라이빗' 키워드가 없기 때문에 클라이언트 코드가 객체의 속성과 메서드를 덮어쓸 수 있다. 이는 자바와 같은 방어적 성격의 프로그래밍 언어와 매우 다른 철학을 보여준다. 자바에는 사용자가 안전한 방식으로 코드를 작성할 수 있도록 보호하는 장치가 내장되어 있지만, 파이썬은 그렇지 않다. 따라서 파이썬 사용자는 모두 책임감을 가져야 한다. 
			
		- "함수의 결과값은 한 곳에서만 반환하자"

			함수가 복잡할수록 반환문의 개수가 증가하기 쉽다. 그러나 의도를 명확히 하고 가독성을 유지하려면 의미 있는 결과 값을 최대한 적은 위치에서 반환하는 게 좋다. 함수 실행이 종료되는 경우는 두 가지다. 하나는 오류가 발생하여 종료되는 경우이고, 나머지 하나는 함수가 정상적으로 실행되어 결과 값을 반환한 뒤 종료되는 경우이다. 함수 실행 중 오류가 발생하면 None이나 False를 반환하는 것이 적절하다. 이 때 함수에서 오류와 관련된 문맥이 파악되자마자 결과 값을 반환하도록 하여 함수 구조를 수평적으로 만드는 것이 좋다. 만약 오류가 발생하지 않는다면, 그 다음 코드가 실행되기 위한 조건이 충족된 것이며, 함수 실행이 멈추지 않고 지속된다. 가끔은 여러 개의 반환문을 사용하는 것도 필요하다. 

- **컨벤션**

	- 컨벤션은 모두에게 수긍이 가는 방식이지만 유일한 선택지는 아니다. 컨벤션은 일반적으로 널리 사용되며, 코드의 가독성을 높이는 데 도움이 된다.

		- 같음을 확인하기 위한 대안

			나쁜예)
			
			```
			if attr == True:
			print 'True!'
			
			if attr == None:
			print 'attr is None!'
			```
			
			좋은예)
			
			```
			# 값이 존재하는지 확인
			if attr:
				print 'attr is truthy!'
				
			# 값이 존재하지 않는지 확인
			if not attr:
				print 'attr is falsey!'
				
			# 값이 'True'인지 확인
			if attr is True:
				print 'attr is True'
				
			# 값이 'None'인지 확인
			if attr is None:
				print 'attr is None!'
			```
			
		- 딕셔너리 요소에 접근하기 

			dict.has_key 메서드 대신 x in d 구문을 사용하거나 dict.get()에 기본 인자를 전달하자.
			
			나쁜예)
			
			```
			>>> d = {'hello': 'world'}
			>>>
			>>> if d.has_key('hello'):
			... 	print(d['hello']) # 'world' 출력
			... else:
			... 	print('default_value')
			world
			```
			
			좋은예)
			
			```
			>>> d = {'hello': 'world}
			>>> 
			>>> print (d.get('hello', 'default_value')
			world
			>>> print (d.get('howdy', 'default_value')
			default_value
			>>>
			>>> # 아니면,
			... if 'hello' in d:
			... 	print(d['hello'])
			...
			world
			```
			
		- 리스트 다루기

			리스트 컴프리헨션은 리스트 자료형을 다루는 명확하고 강력한 도구다!
			
			일반 반복문)
			
			```
			# 4보다 큰 성분만 남기기
			a = [3, 4, 5]
			b = []
			for i in a:
				if i > 4:
					b.append(a)
					
			# 모든 리스트 성분에 3씩 더하기
			a = [3, 4, 5]
			for i in range(len(a)):
				a[i] += 3
			```
			
			리스트 컴프리헨션)
			
			```
			# 리스트 컴프리헨션이 좀 더 깔끔하다
			a = [3, 4, 5]
			b = [i for i in a if i > 4]
			
			# 아니면 다음과 같이 사용해보자
			b = filter(lambda x: x > 4, a)
			
			# 여기도 마찬가지로 깔끔하다
			a = [3, 4, 5]
			a = [i + 3 for i in a]
			
			# 람다 표현식을 사용할 수도 있다
			a = map(lambda i: i + 3, a)
			```
			
### 프로젝트 구조화하기

#### 데코레이터 

데코레이터는 파이썬 2.4에서부터 추가되었다. 데코레이터는 다른 함수나 메서드를 감싸는 (혹은 장식하는) 함수 혹은 클래스 메서드이다. 장식에 사용된 함수나 메서드는 원래의 함수나 메서드를 바꾼다. 

```
>>> def foo():
... 	print("I am inside foo.")
...
...
...
>>> import logging
>>> logging.basicConfig()
>>> 
>>> def logged(func, *args, **kwargs):
... 	logger = logging.getLogger()
... 	def new_func(*args, **kwargs):
... 		logger.debug("calling {} with args {} and kwargs {}".format(
... 						func.__name__, args, kwargs))
... 		return func9*args, **kwargs)
... 	return new_func
...
>>>
... @logged
... def bar():
... 	print("I am insdie bar.")
...
>>> logging.getLogger().setLevel(logging.DEBUG)
>>> bar()
DEBUG:root:calling bar with args () and kwargs {}
I am inside bar.
>>> foo()
I am inside foo.
```

- 이 메커니즘은 함수나 메서드의 핵심 논리를 유지하는 데 유용하다. 

#### 동적 타이핑

파이썬은 변수의 타입이 고정되지 않은 동적 타입(dynamically typed)언어다. 파이썬에서는 동적 타이핑이 약점으로 여겨지기도 한다. 디버깅하기 어려운 복잡한 코드를 야기하는 경우가 있기 때문이다. 만약 a라는 변수가 다양한 무언가에 할당된다면, 개발자나 관리자는 변수가 가리키는 대상이 서로 완전히 무관한지 확인하기 위해 코드에서 a가 등장하는 모든 부분을 추적해야 한다.  

#### 변경 가능/불가능한 자료형

파이썬의 자료형은 내장 자료형과 사용자 정의 자료형으로 나뉜다. 

```
# 리스트는 변경 가능 
my_list = [1, 2, 3]
my_list[0] = 4
print(my_list) # [4, 2, 3] <- 같은 리스트이며, 변경사항이 적용됨

# 정수는 변경 불가능
x=6
x = x + 1 # 메모리의 다른 위치에 새 x가 만들어짐
```

- 변경 가능한 자료형 

	- 객체 내용에 대한 제자리 연산이 가능핟. 리스트와 딕셔너리가 그 예시이며, list.append()나 dict.pop()과 같은 메서드를 사용하면 제자리에서 값이 변경된다. 

- 변경 불가능한 자료형

	- 객체 내용을 바꾸는 메서드를 제공하지 않는다. 예를 들어, 변수 x에 정수 6이 할당되어 있다면, 'increment'메서드를 사용할 수 없다. 그래서 x + 1을 계산하려면 새 정수를 만들어 이름을 정해줘야 한다. 

변경 가능 여부에 따른 결과 중 하나는 변경 가능한 자료형을 딕셔너리 키로 사용할 수 없다는 것이다. 딕셔너리는 키 저장을 위해서 해싱(hashing)을 사용하는데, 값이 변경된다면 같은 값에 해시될 수 없기 때문에 해싱을 사용할 수 없다. 변경 불가능한 자료형 중 리스트 대신 사용할 수 있는 것은 튜플이다. 튜플은 소괄호로 만들 수 있는데, 제자리에서 값을 변경할 수 없기 때문에 딕셔너리 키로 사용할 수 있다. 

#### 의존성 벤더화

**의존성을 벤더화**한 패키지는 외부 의존성(서드파티 라이브러리)을 소스 코드에 포함하고 있다. 이 소스 코드는 *vendor*나 *packages*라는 폴더 안에 들어있다. 대부분의 경우에는 의존성을 별도로 분리하는 게 좋다는 것이 중론이다. 그렇지 않으면 코드 저장소에 불필요한 내용(종종 메가 바이트의 추가 코드)이 늘어나기 때문이다. 

- 만약 커다란 변경사항에 대한 풀리퀘스트(Pull request)를 제출하면, 다른 사용자의 추가 제안이나 요청을 수렴하여 유지 관리를 해야 할 수도 있다는 것이다. 이러한 이유로 Tablib과 Requests는 일부 의존성을 벤더화하였다.


### 코드 테스트 

코드 테스트는 매우 중요하다. 프로젝트가 잘 작동하지 않으면 사람들이 사용하지 않을 것이다. 2001년에 발표된 파이썬 2.1부터는 doctest와 unittest를 포함하였고, 테스트 주도 개발(Test-development, TDD)을 채택하였다. TDD란 함수를 구현하기 이전에 함수의 주 연산과 예외 사례를 정의한 테스트 케이스를 작성하고, 이를 통과하도록 함수 코드를 작성하는 방식이다. 이후로 TDD는 비즈니스 및 오픈소스 프로젝트에 널리받아들여지고 채택되었다. 

#### 테스트를 위한 팁

테스트는 히치하이커가 작성할 수 있는 가장 유용한 코드일 것이다. 

#### 한번에 하나씩 테스트 

기능은 작은 단위에 초점을 맞춰 테스트해야 해당 기능이 제대로 작동하는지 증멸할 수 있다. 

#### 독립은 필수

각 테스트 유닛은 서로 독립적이어야 한다. 각자 실행 가능해야 하고, 테스트 슈트로도 실행 가능해야 하며, 호출 순서에 관계없이 한꺼번에 실행이 가능해야 한다. 

#### 함수 이름은 길고 정확하게

테스트 함수 이름에 테스트 내용이 포함되도록 긴 이름을 사용하자! 이는 코드 실행에서 짧은 이름이 선호되는 것과는 조금 다른 지침인데, 테스트 함수가 명시적으로 호출되는 일이 없기 때문이다. 

#### 속도가 중요하다!

한 번의 테스트가 실행될 때 수 밀리 초 이상이 소요되면 개발 속도가 느려지거나, 테스트가 원하는 만큼 자주 실행되지 않는다. 경우에 따라 복잡한 데이터 구조 때문에 테스트마다 데이터 구조를 로딩하느라 느려지기도 한다. 

#### 메뉴얼을 읽자!

사용하는 도구가 개별 테스트나 테스트 케이스를 어떻게 수행하는지 익혀야 한다. 모듈 내 함수를 개발할 때는 함수 테스트를 자주 해야 하고, 가능하다면 코드가 저장될 때마다 자동으로 수행해야 한다. 

#### 코딩 시작 전과 후에 모든 테스트를 수행하자

코딩 시작 전에 테스트 슈트 전체를 돌리고, 코딩이 끝나고 다시 한 번 돌려야 한다. 그래야 코드 작성 부분 이외의 나머지 부분이 깨지지 않았다고 확신할 수 있다. 

#### 버전 관리 자동화 후크는 매혹적이다

공유 저장소에 코드를 보내기 전에는 모든 테스트를 수행하는 후크를 구현하는 것이 좋다. 

#### 쉬고 싶을 때는 고장 난 테스트를 작성하자

개발 도중 작업을 멈춰야 할 때, 그다음 개발해야 할 부분에 고장 난 단위 테스트를 작성하는 것이 좋다. 다시 작업하러 돌아왔을 때 해당 지점에서부터 다시 시작할 수 있으며 기존 작업을 빠르게 파악할 수 있다. 

#### 테스트를 사용하여 디버깅하자

디버깅의 시작은 버그를 찾아내는 테스트를 작성하는 것이다. 매번 테스트를 작성하는 게 번거로울 수도 있다. 그러나 버그를 찾아내는 테스트 코드는 여러분의 프로젝트 코드 중 가장 가치 있는 부분 중 하나일 것이다. 

#### 공동 작업자가 이해하기 쉬운 테스트를 작성하자

무언가 잘못됐거나 고쳐야 할 때 코드에 좋은 테스트 모음이 있다면, 여러분이나 다른 유지 관리자가 문제를 수정하거나 특정 동작을 수정하기 위해 테스트 슈트에 전적으로 의지할 것이다. 따라서 테스트 코드를 실행 코드와 비슷한 수준 혹은 그 이상으로 많이 읽게 될 것이다. 이때 의도가 불분명한 단위 테스트는 별 도움이 되지 않는다. 

#### 설명하기 쉬운 테스트가 좋다

테스트 코드는 새로 합류한 개발자들을 위한 안내의 용도로 사용된다. 새로 합류한 개발자가 이미 만들어진 코드에서 작업해야 할 때는 테스트 코드를 돌려보고 읽어보는 게 최선의 방법일 때가 많다. 그렇게 하면, 코드 중 문제가 있는 부분이나 예외가 발생하는 부분이 어디인지 발견할 수 있다. 

#### 무엇보다, 혼란에 빠지지 말자

오픈 소스의 세계에서 여러분은 혼자가 아니다!!

#### 테스트를 위한 기본

#### unittest

unittest는 건전지(프로그래머가 바로 사용할 수 있는 라이브러리와 통합 환경을 제공한다는 파이썬의 기본 개념)가 포함된 테스트 모듈로, 파이썬 표준 라이브러리에 포함되어 있다. 

```
# test_example.py
import unittest

def fun(x):
	return x + 1
	
class MyTest(unittest.TestCase):
	def test_that_fun_adds_one(self):
		self.assertEqual(fun(3),4)
		
class MySecondTest(unittest.TestCase):
	def test_that_fun_fails_when_not_adding_number(self):
		self.assertRaises(TypeError, fun, "multiply six by nine")
```

#### Mock(unittest.mock)

파이썬 3.3부터 unittest.mock이 표준 라이브러리에서 제공된다. mock을 사용하면 테스트중인 시스템의 일부를 mock 객체로 바꿔 어떻게 사용되고 있는지 알 수 있다. 

```
from unittest.mock import MegicMock

instance = ProductionClass()
instance.method = MagicMock(return_value=3)
instance.method(3, 4, 5, key='value')

instance.method.assert_called_with(3, 4, 5, key='value')
```

- 테스트 중인 모듈에서 mock 클래스나 mock 객체를 만들고 싶다면, patch 데코레이터를 사용하자!

#### doctest

docktest 모듈은 문서화 문자열 안에 대화형 파이썬 세션처럼 보이는 텍스트가 있는지 검사하고, 해당 세션을 실행하여 쓰여진 대로 정확히 동작하는지 확인한다. 

```
def square(x):
	"""x를 제곱함.
	
	>>> square(2)
	4
	>>> square(-2)
	4
	"""
	
	return x * x
	
if __name__ == '__main__':
	import doctest
	doctest.testmod()
```

- 명령줄에서 해당 모듈을 실행하면(예: python module.py) doctest가 작동하면서, 문서화 문자열에 기술된 대로 동작하지 않으면 경고한다. 

#### 예시 

테스트 슈트를 실행하려면 패키지에 포함되지 않은 별도의 라이브러리가 필요하다(예: Requests에서는 모의 HTTP 서버를 구축하기 위해 Flask패키지를 사용함). 해당 라이브러리는 ```requirements.txt```에 명시되어 있다.

**예시: Tablib에서의 테스트**

Tablib는 테스트를 위해 파이썬 표준 라이브러리의 unittest 모듈을 사용한다. 

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Tests for Tablib."""

import json
import unittest
import sys
import os
import tablib
from tablib.compat import markup, unicode, is_py3
from tablib.core import Row




class TablibTestCase(unittest.TestCase): # 1번
    """Tablib test cases."""

    def setUp(self): # 2번
        """Create simple data set with headers."""

        global data, book

        data = tablib.Dataset()
        book = tablib.Databook()

        #
        # ... 여기서 사용하지 않는 구성 생략 ...
        #

    def tearDown(self): # 3번
        """Teardown."""
        pass


    def test_empty_append(self): # 4번 
        """Verify append() correctly adds tuple with no headers."""
        new_row = (1, 2, 3)
        data.append(new_row)

        # Verify width/data
        self.assertTrue(data.width == len(new_row))
        self.assertTrue(data[0] == new_row)


    def test_empty_append_with_headers(self): # 5번
        """Verify append() correctly detects mismatch of number of
        headers and data.
        """
        data.headers = ['first', 'second']
        new_row = (1, 2, 3, 4)

        self.assertRaises(tablib.InvalidDimensions, data.append, new_row)
```	

- 1번: unittest를 사용하기 위해서는 unittest.TestCase를 상속받는 서브 클래스를 만들고, test로 시작하는 이름의 테스트 메서드를 작성한다. TestCase는 단정 메서드를 제공하며, 같음, 참거짓, 데이터 타입, 집합 포함 여부, 예외 발생 여부 등을 확인한다

- 2번: TestCase.setUp()은 TestCase의 매 테스트 메서드가 실행되기 전에 실행된다. 

- 3번: TestCase.tearDown()은 TestCase의 매 테스트 메서드가 실행되고 난 후에 실행된다. 

- 4번: 모든 테스트 메서드의 이름은 test로 시작해야 하며, 그렇지 않으면 실행되지 않는다. 

- 5번: 하나의 TestCase 안에 여러 개의 테스트가 있을 수 있으나, 각각 하나의 내용만 테스트 해야 한다. 

### 그 외 인기 있는 도구들

#### pytest

pytest는 파이썬 표준인 unittest 모듈에 대한 비표준 대안이다. 즉, 테스트 클래스의 스캐폴딩이 필요 없으며, setup이나 teardown 메서드 또한 필요하지 않을 수 있다. 

#### Nose

Nose는 테스트를 보다 쉽게 할 수 있도록 unittest를 확장한 것이다. Nose는 자동으로 테스트를 발견하며, 수작업으로 테스트 슈트를 만드는 수고를 덜어준다. 

#### tox

tox는 테스트 환경 관리를 자동화하고, 다중 인터프리터 구성에서 테스트하기 위한 도구다.

#### Lettuce 와 Behave 

Lettuce와 Behave는 파이썬 행동 주도 개발(Behavior-driven development, 이하 BDD)을 위한 패키지이다. BDD는 2000년대 초 테스트 주도 개발(TDD)에서 파생한 개발 프로세스이며, TDD에서 '테스트'란 단어를 '행동'으로 대체하여 초보자가 TDD를 어려워하는 문제를 극복하고자 하였다. 

### 문서 

파이썬 개발자에게는 프로젝트의 가독성 뿐만 아니라 문서 가독성도 중요하다. 

#### 프로젝트 문서

프로젝트 문서에는 프로젝트 사용자를 위한 API 문서가 있고, 기여자를 위한 별도의 문서가 있다. 여기서는 후자를 다룬다. 최상위 디렉터리의 README 파일은 프로젝트 사용자와 관리자 모두에게 필요한 정보를 제공하며, 텍스트 또는 마크업 언어로 작성해야 한다. 마크업 언어로는 reStructuredText나 마크다운이 있다. 프로젝트나 라이브러리의 목적을 (사용자가 아무것도 모른다고 가정하고) 설명해야 하며, 소프트웨어의 주요 소스 URL과 기본 크레딧 정보가 포함되어야 한다. README 파일은 코드 독자에게 주요 시작점이 된다. 

#### 프로젝트 공개 

문서에는 프로젝트에 따라 아래 구성 요소 전부 혹은 일부가 포함될 수 있다. 

- 소개(introduction)에서는 프로젝트 기능을 한두 개 정도의 매우 간단한 용례로 소개해야 한다. 30초 가량의 프로젝트 홍보라고 생각하자!

- 튜토리얼(tutorial)에서는 주요 용례를 보다 자세히 설명해야 한다. 독자가 프로토타입을 구성할 수 있을 정도로 단계별로 설명하자!

- API 레퍼런스(API reference)는 코드로부터 만들어지는 게 전형적이며, 공개적으로 사용 가능한 인터페이스, 파라미터, 반환 값을 나열한다.  

- 개발자 문서(Developer documentation)는 미래의 기여자를 위해 작성되며, 코드 컨벤션이나 프로젝트의 일반 디자인 전략이 포함될 수 있다. 

#### 스핑크스 

Sphinx는 가장 널리 사용되는 파이썬 문서화 도구다. reStructuredText 마크업 언어를 HTML, LaTex(출력 가능한 PDF 버전용), 메뉴얼 페이지 그리고 일반 텍스트와 같은 다양한 형식으로 변환한다. 

### 로그

대체로 로그를 남기는 데에는 두 가지 목적이 있다. 

- 진단용 로그

진단용 로그는 애플리케이션 작동에 관한 이벤트 기록이다. 예를 들어, 사용자가 오류 보고서를 남기면 로그에서 해당 오류의 문맥을 파악할 수 있다. 

- 감시용 로그

감시용 로그는 비즈니스 분석에 사용되는 이벤트 기록이다. 사용자의 거래를 추출하여 다른 세부 정보와 결합하여 보고서를 작성하거나 업무를 최적화 할 수 있다. 

#### 라이브러리에서 로그 남기기

**"NullHandler 이외의 핸들러는 라이브러리의 로그 기록기에 추가하지 않는 게 좋다!"**

로그 기록 이벤트가 발생했을 때 무슨 일인지 알아내는 주체는 라이브러리가 아닌 사용자다. 따라서 위의 경고는 아무리 반복해도 지나치지 않는다. Nullhandler는 이름 그대로 아무것도 하지 않으며 사용자가 원하지 않는 경우에 로그 기록을 명시적으로 해제해야 한다. 

#### 애플리케이션에서 로그 남기기

| **방법**  | **장점**  | **단점**  |
|---|---|---|
| INI 형식의 파일 사용  | logging.config.listen()함수를 사용하면, 코드 실행 도중에도 구성을 업데이트하고 소켓의 변경사항을 가져올 수 있다.  | 코드에서 로그를 구성하는 것보다 제어력이 낮다  |
| 딕셔너리나 JSON 형식 파일 사용  | 실행 중 업데이트할 수 있을 뿐만 아니라, json 모듈을 사용해 파일로부터 구성을 불러올 수도 있다.  | 코드에서 로그를 구성하는 것보다 제어력이 낮다.  |
| 코드 사용  | 모든 구성을 완벽히 제어할 수 있다.  | 구성을 수정하려면 소스 코드를 변경해야 한다.  |

### 라이선스 선택 

미국에서는 소스 코드를 배포할 때 라이선스를 명시하지 않으면, 법적으로 사용자는 이를 다운로드/수정/배포하지 못한다. 또한 사람들에게 규칙을 알려주지 않으면 아무것도 프로젝트에 기여하지 못한다. 따라서 라이선스가 필요하다.

#### 업스트림 라이선스

다른 프로젝트에서 파생된 결과물이라면 업스트림(upstream) 라이선스에 따라 라이선스가 정해진다. 예를 들어, 파이썬 소프트웨어 재단에서는 파이썬 소스 코드에 기여한 모든 참여자에게 해당 코드가 파이썬 소프트웨어 재단에 공식적으로 귀속된다는 내용(본인의 저작권은 유지됨)의 동의 서명을 요청한다. 참고로 기여자는 두 가지 라이선스 중 선택할 수 있다. 

#### 선택사항

선택할 수 있는 라이선스는 무수히 많지만, 파이썬 소프트웨어 재단에서는 OSI(Open Source Institute)에서 승인한 라이선스 중에서 고르길 추천한다. 

*오픈 소스 라이선스는 대체로 다음의 두 카테고리 중 하나에 속한다*

- 허용 라이선스

허용 라이선스(permissice license)는 종종 BSD(Berkeley Software Distri-bution, 버클리 소프트웨어 배포) 스타일 라이선스로 불리며, 사용자가 자유롭게 원하는 대로 소프트웨어를 사용하는 데에 초점을 둔다. 

- 카피 레프트 라이선스

카피레프트(copyleft) 라이선스는 덜 허용적인 라이선스라고도 불리며, 소스 코드가 그 자체로 사용 가능하도록 하는 데 중점을 둔다. GPL 라이선스가 가장 잘 알려져 있다.
			







