---
layout: post
title:  "뇌를 자극하는 파이썬 3 - 코딩으로의 초대 1 ~ 10"
date:   2017-12-09
author: Yoonkh
categories: Python
tags:	Python
comments: True
---

# 뇌를 자극하는 파이썬 3

## 코딩으로의 초대

### 코딩의 즐거움 요소

- 무언가를 창조한다는 순수한 즐거움

- 다른 사람들에게 쓸모 있는 것을 만드는 기쁨

- 복잡한 퍼즐을 맞추듯 정교한 부품을 조립하여 완성하는 것에서 얻는 희열

- 항상 배우고 성장하는 즐거움

- 다루기 쉬운 매체를 이용해 작업하는 즐거움

**코딩의 재미는 글로 다 표현이 불가능하다!!!**

*축구를 제대로 해보기전까지는 축구가 얼마나 재미있는지 알 수 없는 것과 같다고 할 수 있다*

- 취미로서의 코딩의 장점: 코딩은 전기세 이외에는 돈이 들지 않는다!!!

### 문제 해결 능력을 키우는 코딩 

- 이미 교육계에서 이루어진 여러 연구가 컴퓨터 프로그래밍이 논리적 추론 능력의 향상에 도움을 준다는 사실을 뒷받침하고 있다!

- 코딩을 즐겁게 하다보면 논리적 추론능력 뿐만 아니라 논리적 사고, 계획하는 능력, 일반적인 문제 해결능력이 저절로 향상된다!

우리가 페이스북 CEO처럼 수십조 원에 달하는 기업을 경영하고 있지는 않더라도 직장이나 삶에서 만나는 문제들을 풀어나가는데 코딩이 도움을 줄 수 있다!

### 아이디어를 현실로!

- 재미있는 이야기 거리가 있어도 그림을 그릴 줄 알아야 그 이야기를 만화로 만들 수 있고, 글을 쓸 줄 알아야 소설을 만들 수 있다!

- 아무리 좋은 아이디어가 있더라도 코딩을 할 줄 모른다면 그것을 실체화 할 수 없다!

**코딩을 할 수 있는 과학도는 얼마든지 컴퓨터 시뮬레이션을 만들어 이론을 검증해 볼 수 있다!**

보통의 발명가라면 아이디어가 떠올랐을 때 갖가지 재료를 구입해서 먼지 날리는 가공을 해야 하겠지만, 코드는 돈도 들지 않고 먼지도 날리지 않는 멋진 재료이다. 시간만 투자한다면 여러분의 아이디어를 살아 움직이는 것으로 만들 수 있다.

### 누구나 할 수 있는 코딩

컴퓨터가 세상에 처음 나왔을 때 얼마동안은 과학자와 기술자의 전유물이었지만, 오늘날에는 초등학생이나 식당주인처럼 누구나 배울 수 있다.

- 의식하지 못하고 코딩을 해왔을 수 있다. 워드프로세서나 스프레드 시트에서 매크로를 이용해서 작업을 자동화 시켜봤다면 그것이 프로그래밍이다!

- 2011년부터 영국에서는 '코딩은 새로운 라틴어'라는 캠패인을 통해 청소년들의 프로그래밍 교육을 확대하고 있다.

- 뉴욕의 블룸버그 시장도 자신의 2012년 새해 목표가 '코딩 익히기'라고 발표하여 사람들에게 코딩에 대한 관심을 불러 일으켰다!

## 코딩을 배우기 전에 읽는 컴퓨터 구조론

### 폰노이만 구조

천재 과학자 폰노이만은 1945년에 데이터와 명령어를 보관하는 기억 장치(MEMORY) 그리고 데이터의 가공을 담당하는 중앙처리장치(CPU)로 구성되는 현대 컴퓨터의 구조를 최초로 정의했다.

- 현재 우리가 사용하고 있는 거의 모든 전자 기기들은 폰노이만 구조를 이용하고 있다.

### 중앙 처리 장치 (CPU)

중앙처리장치는 컴퓨터에서 가장 중요한 장치라고 할 수 있다. 컴퓨터가 수행하는 계산은 모두 이 CPU를 통해서 이루어지기 때문이다. 

- 자동차로 비유하면 엔진과 같다

*컴퓨터를 여러 연주자로 이루어진 오케스트라에 비한다면, 제어 장치는 이 오케스트라의 지휘자라고 할 수 있다. 제어장치와 산술 논리 장치는 다음과 같은 과정을 통햇 곡을 연주한다.

**1.** 먼저 제어장치가 기억 장치로부터 명령어를 가져온다(Fetch)

**2.** 제어장치는 가져온 명령어를 해독(Decode)한다.

**3.** 제어장치는 해독한 명령어에 따라 산술 논리 장치에 데이터를 옮기고 어떤 연산을 수행할지를 지시한다.

**4.** 산술 논리 장치는 제어 장치가 지시한 대로 계산을 수행(Execute)한다.

**5.** 그리고 수행한 결과를 기억 장치에 다시 저장(Store)한다.

*ex) 어떤 CPU의 클럭 주파수가 1GHz라고 한다면, 그 CPU는 1초에 10억회의 명령 주기를 수행하는 성능을 지닌것이다!!!*

### 기억 장치 (Memory)

기억장치는 데이터와 함께 명령어를 저장하는 역할을 한다. 메모리의 용량이 클 수록 더 많은 데이터와 명령어를 저장할 수 있고, 메모리가 빠르게 동작할수록 더 빠르게 CPU와 데이터와 명령어를 교환 할 수 있다.

### 입력/출력 장치

다양한 입출력 장치들은 '입출력 버스'를 통해 중앙 처리 장치, 기억 장치와 정보를 주고 받는다. 

- 버스는 우리가 자주 이용하는 대중교통 수단인 바로 그 버스와 철자가 동일하지만 컴퓨터 과학에서 버스라고 하면 '컴퓨터의 정보 전송 회로'를 말한다.

**중앙처리장치와 기억 장치, 그리고 입출력 장치는 버스로 연결되어 있다.**

컴퓨터에서는 중앙 처리 장치, 기억 장치, 입출력 장치가 동일한 입출력 버스를 사용함으로써 빠르게 동작하는 중앙 처리 장치가 느려터진 입출력 장치 때문에 제 성능을 낼 수 없는 문제가 발생한다!

이문제를 해결하기 위해서 버스를 두가지로 나누었다!

- 먼저 CPU와 기억장치는 시스템 버스로 묶고, 그 다음 다양한 입출력 장치들은 입출력 버스로 묶어 CPU의 입출력 모듈에 연결한다.

- 4차선 고속도로에서 바깥쪽 차선은 저속차량이 이용하고 안쪽 차선은 고속차량이 달리도록 하는 것과 같다.

### 운영체제와 애플리케이션

운영체제는 애플리케이션에 API(Application Programming Interface)를 제공하여 운영체제가 제어하고 있는 하드웨어를 이용할 수 있도록 한다.

- 만약 운영체제가 없었다면 맥북 에어의 하드웨어 제어코드와 MS 서피스 하드웨어 제어코드를 일일이 애플리케이션안에 작성하는 대참사가 발생했을 것이다.

### 소프트웨어는 무엇으로 만드는가?

**"허리를 바로 세우고 왼팔을 앞으로 내저으며 오른팔을 뒤로 내저어라. 동시에 몸의 중심을 앞으로 옮기며 왼발을 받침으로 삼고 오른발을 앞으로 내밀어라. 그리고 별도의 지시가 있기 전까지 이 행동을 계속하라."**

그냥 "앞으로 가"라고 하면 되는데 저런 식으로 사람에게 지시를 내리는 경우는 거의 없을 것이다. 

- 컴퓨터는 어떤 일이든 세세하게 지시해주지 않으면 아무것도 하지 못한다.

이점을 역으로 이용해서 개발된 프로그래밍 언어가 어셈블리이다!!

어셈블리어는 복잡한 기계어 명령을 사람이 이해할 수 있는 기호나 단어로 바꿔 만든 것이다.

*물론 컴퓨터는 "앞으로 가"라는 명령어를 전혀 이해하지 못한다. 컴퓨터는 0과 1만 알아듣기 때문이다!*

- 프로그래머가 어셈블리어로 프로그램 코드를 작성한 후에는 컴파일러라는 소프트웨어를 이용하여 실행 파일을 만들어 냈는데, 이 실행 파일이 바로 프로그램이었다.

**어셈플리어처럼 프로그램을 작성하기 위해 만들어진 인공 언어체계를 '프로그래밍 언어'라고 한다**

- 컴파일러는 소스코드를 컴파일하여 실행파일로 만들기 때문에 프로그램을 실행하기 위해서는 '실행파일'만 있으면 되며, 소스코드는 전혀 필요하지 않다.

- 인터프리터는 소스코드를 미리 실행파일로 만드는 작업이 필요하지 않다. 소스코드를 실시간으로 기계어로 해석해서 실행해주기 때문이다.

## 데이터 다루기: 수와 텍스트와 비트

### 변수 

변수는 데이터를 담는 메모리 공간이다!

여기에는 수를 담을 수도 있고, 글을 담을 수도 있다. 목록이나 이미지 데이터도 담을 수 있다.

```
>>> a = 2020
>>> a
2020
```

'a = 2020'은 "a라는 이름의 변수를 만들고 2020을 해당변수에 입력하라"라는 의미의 코드이다.

**변수 = 데이터를 담는 공간**

### 수 다루기

#### 정수

정수는 음의 정수, 0, 양의 정수를 모두 통틀어 일컫는 말이다!

- 파이썬에서는 메모리가 허용하는한, 무한대의 정수를 다룰 수 있다.

파이썬은 코드가 실행될 때 변수의 형식을 결정한다.

파이썬 인터프리터는 f = -3을 실행할 때가 되어서야 f가 정수라고 판단한다!

```
>>> f = -3
>>> type(f)
<<class 'int'>>
```

#### 여러 가지 진법으로 수 출력하기

파이썬에서 16진수와 2진수로 표현하는 방법!

- 숫자를 16진수로 출력하려면 hex() 함수를 사용해야 한다.

- 숫자를 2진수로 출력하려면 bin() 함수를 사용해야 한다.

#### 실수 

파이썬은 실수를 지원하기 위해 부동 소수형을 제공한다.

부동소수형은 컴퓨터로 소수의 소수점을 표현하는 방식 중 하나이다.

- 부동 소수형은 8바이트만을 이용해서 수를 표현한다. 즉, 한정된 범위의 수만 표현할 수 있다.

- 디지털 방식으로 소수를 표현해야 하므로 정밀도에 한계가 있다.

다음과 같이 변수에 소수점이 있느 수를 대입하면 부동 소수형 변수가 만들어진다!!

```
>>> a = 3.14
>>> a
3.14
```

type() 함수를 사용해서 자료형을 확인하기!

```
>>> type(a) # a는 3.14
<<class 'float'>>
```

- 'float'은 부동소수점을 나타낸다

#### 부동 소수형의 8바이트

부동 소수형은 8바이트만을 이용해서 실수를 표현한다. 비록 8바이트만 가지고 수를 표현하지만, 굉장히 넓은 범위의 수를 다룬다.

- 파이썬의 부동 소수형은 **IEEE754**라는 표준을 따른다.

ex) 7.25를 정규화하여 가수 비트에 담는다면?

7은 2진수로 111, 0.25는 0.01이니 합치면 111.01이 된다. 이를 정규화하면 1.1101이 된다. 시작되는 1은 제거하고 담는다.

- 이러한 일련의 과정들을 **'정규화'**라고 한다.

한편, 8바이트(64비트) 부동 소수형의 경우 지수는 -1024부터 +1023까지의 값을 가질 수 있는데, 2의 보수로 이 값을 표현하면 비교 연산이 복잡해지기 때문에, 성능은 저하된다. 따라서 지수에는 실제 값에 1023을 더해 저장하는 **바이어싱(biasing)**을 사용한다.

- 결국 지수부에 담기는 비트에는 0보다 큰 양수만 담긴다.

#### math 모듈을 이용한 계산

파이썬 코드를 담고 있는 .py 확장자를 가진 파일을 '모듈(module)'이라고 한다. 파이썬은 인터프리터와 함께 매우 다양한 모듈을 제공한다.

- 모듈을 사용하려면 import구문을 이용한다

```
>>> import math 
```

#### π와 e

원주율 π와 자연상수 e는 수학에서 사용되는 주요 상수이다

```
>>> math.pi # 원주율 π
3.141592 ... 
>>> math.e # 자연상수 e
2.718818 ...
```

#### 절대값, 버림과 반올림

| **함수**  | **설명**  | **비고**  |
|---|---|---|
| abs()  | 절대값 계산 함수  | 내장 함수  |
| round()  | 반올림 계산 함수  | 내장 함수  |
| trunc()  | 버림 계산 함수  | math 모듈  |

- 내장 함수(Built-in function)은 파이썬이 인터프리터에 함께 탑재해 놓은 함수로써 별도의 import 구문을 통하지 않고도 사용할 수 있는 함수이다.

*abs() 함수의 사용 예 :*

```
>>> abs(10)
10
>>> abs(-10)
10
```

*round() 함수의 사용 예 :*

```
>>> round(1.4)
1
>>> round(1.5)
2
```

**trunc() 함수는 1.4, 1.5, 1.9를 모두 1로 만든다. trunc() 함수는 앞의 두 함수와는 달리 내장 함수가 아니기 때문에 사용할 때 'math.'를 붙여야 한다.**

*trunc() 함수의 사용 예 :*

```
>>> import math
>>> math.trunc(1.4)
1
>>> math.trunc(1.5)
1
>>> math.trunc(1.9)
1
```

#### 팩토리얼

팩토리얼은 1부터 어떤 양의 정수 n까지의 정수를 모두 곱한 것을 말한다. 예를 들어 5팩토리얼을 수식을 나타내면 다음과 같다.

```
5! = 5x4x3x2x1
```

- math 모듈에서 제공하는 팩토리얼 함수의 이름은 factorial()이다.

| **함수**  | **설명**  |
|---|---|
| factorial()  | 팩토리얼 계산 함수  |

#### 도와 라디안

도(degree)는 원을 360도로 표현한 것이고, 라디안(radian)은 반지름의 1인 원에서 호의 길이가 1인 부채꼴의 각을 기본단위로 삼아 2π로 표현한 것이다. 즉 360도 = 2π 인 것이다!

#### 삼각 함수

math 모듈에서 제공하는 삼각함수 목록

| **함수**  | **설명**  |
|---|---|
| cos()  | 입력된 라디안에 대한 코사인 값을 계산  |
| sin()  | 입력된 라디안에 대한 사인 값을 계산  |
| tan()  | 입력된 라디안에 대한 탄젠트 값을 계산  |
| acos()  | cos()의 역함수  |
| asin()  | sin()의 역함수  |
| atan()  | tan()의 역함수  |

#### 제곱과 제곱근

파이썬으로 제곱을 계산한다면 다음과 같이 가능하다

```
>>> 3*3
9
>>> 3*3*3
27
```

### 텍스트 다루기 

컴퓨터는 수를 계산하기 위해 만들어진 기계이다.

이 수 기게를 이용해서 컴퓨터 과학자들이 글을 다루는 방법을 고안해 냈는데, 각 문자마다 번호를 붙이고 메모리에 저장하거나 계산을 할 때에는 수로 처리하고 모니터나 프린터에 출력할 때는 사람이 아는 문자로 출력하는 방식이다.

파이썬에서는 텍스트를 다루는 자료형으로 String을 제공한다. String은 영어로 끈, 줄 등의 뜻을 가지고 있으므로 문자를 끈으로 가지런히 묶어놓는 것으로 이해하면 된다.

### 문자열 메소드

순서열로부터 물려받은 기능외에도, 문자열은 다양한 기능의 함수를 자체적을 탑재하고 있다.

내장 함수들과는 달리 이런 함수는 문자열 자료형 안에 들어 있다. 이렇게 특정 자료형이 갖고 있는 함수를 메소드(Method)라고 한다.

### 수에서 텍스트로, 텍스트에서 수로

```
print("첫 번째 수를 입력하세요. : ")
a = input()
print("두 번째 수를 입력하세요. : ")
b = input()

result = int(a) * int(b)

print("{0} * {1} = {2}".format(a, b, result))
```

- 실행 결과

```
>input_multiply.py
첫 번째 수를 입력하세요 :
5
두 번째 수를 입력하세요 :
4
5 * 4 = 20
```

**파이썬은 숫자 형식의 생성자 안에 문자열을 해당 형식으로 변환하는 기능을 탑재했다.**

### 비트 다루기

컴퓨터는 원래 0과 1의 비트 데이터만을 다루는 기계이다. 하지만 파이썬에서 다루는 데이터의 기본 단위는 '바이트(Byte)'이다. 1바이트는 비트를 무려 8개나 담을 수 있는 크기다.

비트 수준에서 데이터를 가공해야 하는 경우도 종종 생기는데 비트 연산자는 바로 이를 위한 연산자이다!

#### 시프트 연산자

시프트 연산자(Shift Operator)는 비트를 왼쪽이나 오른쪽으로 이동시키는 기능을 한다.

### 비트 논리 연산자

논리 연산은 참 또는 거짓의 진리 값을 피연산자로 하는 연산이다. 비트 논리 연산(Bitwise Logical Operation)은 데이터의 각 비트에 대해 수행하는 논리 연산이다. 파이썬에서 제공하는 비트 논리 연산자는 네 가지가 있다.

| **연산자**  | **이름**  |
|---|---|
| ```&```  | 논리곱(AND)연산자  |
| ```|```  | 논리합(OR)연산자  |
| ```^```  | 배타적 논리합(XOR)연산자  |
| ```~```  | 보수(NOT)연산자  |

- 비트 논리 연산자는 bool 형식 외에도 정수 계열 형식의 피연산자에 대해서도 사용 할 수 있다.

## 데이터 다루기: 리스트와 튜플과 딕셔너리

### 리스트 

리스트(List)는 이름에서도 알 수 있듯이 데이터의 목록을 다루는 자료형이다.

단일 데이터가 명함이라면, 리스트는 명함을 모아두는 명함집이라고 할 수 있다.

명함집에 명함을 꽂아 넣을 수 있는 슬롯(Slot)이 있는 것처럼, 리스트들도 슬롯이 있다.

리스트의 각 슬롯에 꽂혀있는 개별 데이터를 일컫어 요소(Element)라고 한다.

### 리스트 메소드

| **메소드**  | **설명**  |
|---|---|
| append()  | 리스트의 끝에 새 요소를 추가한다.  |
| extend()  | 기존 리스트에 다른 리스트를 이어 붙입니다. + 연산자와 같은 기능을 한다고 할 수 있다.  |
| insert()  | 첨자로 명시한 리스트 내의 위치에 새 요소를 삽입한다.   |
| remote()  | 매개변수로 입력한 데이터를 리스트에서 찾아 발견한 첫 번째 요소를 제거한다.  |
| pop()  | 리스트의 마지막 요소를 뽑아내어 리스트에서 제거한다.  |
| index()  | 리스트 내에서 매개변수로 입력한 데이터와 일치하는 첫 번째 요소의 첨자를 알려준다.  |
| count()  | 매개변수로 입력한 데이터와 일치하는 요소가 몇 개 있는지 센다.  |
| sort()  | 리스트 내의 요소를 정렬한다.  |
| reverse()  | 리스트 내 요소의 순서를 반대로 뒤집는다.  |

#### 튜플 

리스트는 sort()메소드를 이용해 요소의 순서를 정렬하지만 튜플은 변경이 불가능하므로 아예 해당 메소드가 제공되지 않는다. 새로운 요소를 추가하거나 삽입할 수 있고, 기존 요소를 삭제할 수도 있지만 튜플은 이러한 작업을 허용하지 않는다.

**튜플 = 변경이 불가능한 자료형!**

- 튜플도 리스트와 문자열처럼 순서열 자료형이기 때문에 대괄호를 이용한 참조 연산과 슬라이싱, 튜플간 결합 등의 연산이 가능하다!

*ex) 슬라이싱 예:*

```
>>> a = (1, 2, 3, 4, 5, 6)
>>> a[:3]
(1, 2, 3)
>>> a[4:6]
(5, 6)
```

*ex) + 연산자 튜플 결합의 예:*

```
>>> a = (1, 2, 3)
>>> b = (4, 5, 6)
>>> c = a + b
>>> a 
(1, 2, 3)
>>> b
(4, 5, 6)
>>> c
(1, 2, 3, 4, 5, 6)
```

#### 패킹과 언패킹!

다음과 같이 여러가지 데이터를 튜플로 묶는 것을 튜플 패킹(Tuple Packing)이라고 한다!

```
>>> a = 1, 2, 3
>>> a
(1, 2, 3)
```

그리고 다음과 같이 튜플의 각 요소를 여러 개의 변수에 할당하는 것을 튜플 언패킹(Tuple Unpacking)이라고 한다!

```
>>> one, two, three = a
>>> one 
1
>>> two
2
>>> three
3
```

- 튜플의 언패킹을 활용하면 여러 개의 변수에 한번에 할당을 수행할 수 있다!

#### 튜플 메소드

튜플은 변형이 불가능한 자료형이라서 제공하는 메소드가 index()와 count() 두개뿐이다!!!

| **메소드**  | **설명**  |
|---|---|
| index()  | 매개변수로 입력한 데이터와 일치하는 튜플 내 요소의 첨자를 알려준다!  |
| count()  | 매개변수로 입력한 데이터와 일치하는 요소가 몇 개 있는지 센다!  |


#### 딕셔너리

딕셔너리(Dictionary)는 사용법 측면에서 보면 리스트와 비슷하다고 볼 수 있다!

- 리스트처럼 첨자를 이용해서 요소에 접근하고, 또 그 요소를 변경 할 수도 있다!

딕셔너리의 첨자는 키(Key)라고 하고, 이 키가 가리키는 슬롯에 저장되는 데이터를 값(Value)라고 한다!

딕셔너리는 키-값의 쌍으로 구성된다.

- 딕셔너리는 키를 이용해서 단번에 데이터가 저장된 위치의 주소를 계산해내는데 이런 작업을 해싱(Hashing)이라고 한다!


## 프로그램 흐름 제어하기!

### 흐름 제어를 시작하기 전에

#### bool 자료형

bool은 True와 False 두 가지 값을 나타내는 자료형이다!

```
>>> a = 3 > 2
>>> a
True
>>> a = 2 > 3
>>> a
False
>>> type(a)
<<class 'bool'>>
```

#### 논리 연산자

not, and, or는 참과 거짓을 다루는 논리 연산자이다!

#### 흐름 제어문과 조건문

흐름 제어문은 흐름을 분기하거나 반복하기 전에 조건문의 결과가 참인지를 평가한다!

- bool 형식을 비롯해서 숫자, 문자열, 딕셔너리 등 다양한 객체가 사용된다

```
- False
- None
- 숫자 0 예) 0, 0.0등
- 비어있는 순서열: 예)",(),[]등
- 비어있는 딕셔너리: 예) {}
```

#### 코드블록과 들여쓰기

코드블록(Code Block)은 여러 코드가 이루는 일정한 구역을 말하는데, 프로그래밍 언어마다 이것을 표현하는 방법은 각기 다르다!

#### 비교 연산자

| **연산자**  | **설명**  |
|---|---|
| ==  | 양쪽에 위치한 피연산자가 서로 같으면 True, 그렇지 않으면 False이다!  |
| !=  | 양쪽에 위치한 피연산자가 서로 다르면 True, 그렇지 않으면 False이다!  |
| >  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 크면 True, 그렇지 않으면 False이다!  |
| >=  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 크거나 같으면 True, 그렇지 않으면 False이다!  |
| <  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 작으면 True, 그렇지 않으면 False이다!  |
| <=  | 왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 작거나 같으면 True, 그렇지 않으면 False이다!  |

### 분기문

프로그램의 흐름을 가르는 문장을 일컬어 나눌 분, 갈림길 기, 분기문이라고 한다!

#### if문 

if는 어떤 상황을 가정할 때 사용하는 말이다!

- '만약 ~라면'의 뜻을 갖고 있다. '만약 입력받은 수 a가 0이라면'처럼 

if문은 참아니면 거짓으로 평가될 수 있어야한다.

```
>>> if 조건: # if 뒤에 흐름을 가를 조건이 위치하고, 그 뒤에 콜론(:)이 온다
>>> 	명령1	# :뒤에는 들여쓰기로 이루어진 코드블록이 온다. 이 코드블록은 if문의 조건이 True일 경우 실행된다!
>>> 	명령2
>>> else: # if문의 조건을 충족하지 않을 때, 즉 조건 평가의 결과가 False일 때의 흐름은 else로 향한다!. else뒤에도 코드블록이 오므로 콜론(:)이 위치해야 한다.
>>> 	명령1	
>>> 	명령2
```

*ex) if else의 예제: 

```
import sys

print('수를 입력하세요 : ')
a = int(input())

if a == 0 :
    print('0은 나눗셈에 이용할 수 없습니다.')
    sys.exit(0)

print('3 /', a, '=', 3/a)
```

- 파이썬 프로그램을 종료하는 exit() 함수를 사용하기 위해 sys패키지를 임포트한다

- a가 0인 경우에 경고 메세지를 출력한 뒤 프로그램을 종요시킨다. 

*ex) elif는 else if를 줄여 만든 파이썬 키워드 이다.*

```
print('요일(월~일)을 입력하세요 : ')
dow = input()

if dow == '월' : # 첫번째 조건은 항상 if로 시작
    print('Monday')
elif dow == '화' : # 두번째 조건부터는 elif를 이용!
    print('Tuesday')
elif dow == '수' :
    print('Wednesday')
elif dow == '목' :
    print('Thursday')
elif dow == '금' :
    print('Friday')
elif dow == '토' :
    print('Saturday')
elif dow == '일' :
    print('Sunday')
else : # 마지막의 else는 생략가능!
    print('잘못 입력된 요일입니다.')
```

### 반복문

*루프문(Loop Statement)이라고도 한다.*

#### while문

while문은 코드의 흐름을 반복시킬 수 있는 파이썬의 코드이다.

*ex) while*

```
>>> while 조건:
>>> 	코드블록 
```

- while키워드가 먼저 위치하고 그 다음에 조건이 오게 된다.

조건뒤에는 코드블록을 위치시켜서 전에 콜론(:)이 있어야 한다.

while이 영어로 '~하는동안'이라는 뜻이므로 while코드를 읽을 때에는 '조건이 참인 동안'이라고 해석하면 된다!

```
print('몇 번 반복할까요? : ')
limit = int(input())

count = 0
while count < limit :
    count = count + 1
    print('{0}회 반복.'.format(count))    
    
print('반복이 종료되었습니다.')
```

#### for 문

for문은 조건을 평가하는 것이 아니라 순서열을 순회하다가 순서열의 끝에 도달했는지를 본다

*ex) for*

```
>>> for 반복변수 in 순서열:
>>> 	코드블록
```

- for문에서 사용하는 순서열은 리스트, 튜플, 심지어 문자열 등 어떤 것을 사용해도 괜찮다!

for문은 순서열의 각 원소를 처음부터 차례로 순회하면서 반복변수에 담아낸다.

```
for s in '뇌를 자극하는 파이썬' :
    print(s)
```

*ex) 중첩 for문*

```
for i in range(1, 6) :
        for j in range(i) : # 바깥의 for문에서 입력한 반복변수 i가 멈춤값이다!
            print( "*", end = "", ) # end=""을 매개변수로 입력하면 줄바꿈을 출력하지 않는다!
        
        print() # 아무것도 입력하지 않으면 줄바꿈만 출력
```

#### continue와 break로 반복문 제어하기

파이썬에서 continue문은 반복문이 실행하는 코드블록의 나머지 부분을 실행하지 않고 다음 반복으로 건너가도록 흐름을 조정한다.

```
for i in range(10) :
    if i % 2 == 1 :
        continue # i가 홀수일 때 코드블록의 나머지 부분을 실행하지 않고 다음 반복으로 바로 건너간다.
        
    print(i) # continue가 실행되는 경우에는 이 코드는 실행되지 않는다.        
```

## 함수로 코드 간추리기

### 이 단원을 시작하기에 앞서 알아둬야하는 용어!!

#### 정의

정의(Definition)는 어떤 이름을 가진코드가 구체적으로 어떻게 동작하는지를 '구체적으로 기술'하는것을 말한다.

#### 호출과 반환

모든 함수는 이름을 갖고 있다.

이 이름을 불러주면 파이썬은 그 이름 아래 정의되어 있는 코드를 실행한다.

- 함수가 자신의 코드를 실행하면 결과가 나오는데, 그 결과를 자신의 이름을 부른 코드에게 돌려준다.

- 이때 함수를 부르는 행위를 호출(Call)이라고 하고, 함수를 부르는 코드를 호출자(Caller)라고 한다.

- 함수가 호출자에게 결과를 돌려주는 것을 반환(Return)이라고 한다.

### 함수 정의하기

*ex) 함수를 정의하는 문법*

```
>>> def 함수이름( 매개변수 목록 ):
>>> 	# 코드블록
>>> 	return 결과
```

#### 매개변수를 입력받는 여러가지 방법

매개변수는 호출자와 함수 사이의 관계를 맺어주는 변수를 뜻한다.

매개변수에 어떤 값이 들어있느냐에 따라서 함수의 동작이 달라진다

```
def my_abs( arg ): # arg: 매개변수
	if ( arg < 0 ):
		result = arg * -1
	else:
		result = arg
		
	return result
```

#### 기본값 매개변수와 키워드 매개변수

*ex) 기본값 매개변수*

```
>>> def print_string(text, count=1): # 매개변수를 정의 할 때 값을 할당해 놓으면 기본값 매개변수가 된다!
	 	for i in range(count):
	 		print(text)	
	 		
>>> print_string('안녕하세요') # 호출할 때 두 번째 매개변수를 생략하면 기본값 1이 사용된다!
안녕하세요
>>> print_string('안녕하세요', 2)
안녕하세요
안녕하세요
```

*ex) 키워드 매개변수*

```
>>> def print_personel(name, position='staff', nationality='Korea'):
	 	print('name = {0}'.format(name))
	 	print('position = {0}'.format(position))
	 	print('nationality = {0}'.format(nationality))
	 	
>>> print_personnel(name='윤경한') # position과 nationality는 기본값이 사용된다
name = 윤경한
position = staff
nationality = Korea 	

>>> print_personnel(name='윤경한', nationality='ROK') # position만이 기본값을 사용!
name = 윤경한
position = staff
nationality = ROK

>>> print_personnel(name='윤경한', position='인턴') # nationality만이 기본값을 사용!
name = 윤경한
position = 인턴
nationality = Korea
```

#### 가변 매개변수

상황에 따라 매개변수의 수가 달라지는 함수는 매개변수(Arbitrary Argument List)를 이용하면 된다!

```
>>> def 함수이름(*매개변수): # 매개변수 앞에 *를 붙이면 해당 매개변수는 가변으로 지정된다!
	 	코드블록
```

**```*```를 이용하여 정의된 가변 매개변수는 튜플이다!**

#### 호출자에게 반환하기!

함수가 호출자에게 값을 반환할 때에는 return문이 이용된다. return문은 대체로 다음 3가지 방법으로 사용된다!

1. return문에 결과 데이터를 담아 실행하기 => 함수가 즉시 종료되고 호출자에게 결과가 전달

2. return문에 아무 결과도 넣지 않고 실행하기 => 함수가 즉시 종료!

3. return문 생략하기 => 함수의 모든 코드가 실행되면 종료!

*ex) return문에 결과 데이터를 담아 실행하기*

```
>>> def multiply(a, b):
	 	return a+b # return문은 함수의 실행을 종료시키고 자신에게 넘겨진 데이터를 호출자에게 전달한다!
	 	
>>> result = multiply(2, 3)
>>> resutl
6
``` 	

- 한 함수 안에 return문을 여러 개 두는 것이 문법적인 문제를 일으키는 것은 아니지만, 가급적이면 return문은 함수 코드블록의 마지막에 하나만 실행하도록 하는 것이 좋다!

*ex) return문에 아무 결과도 넣지 않고 실행하기*

```
>>> def ogamdo(num):
	 	for i in range(1, num+1):
	 		print('제 {0}의 이해'.format(i))
	 		if i == 5:
	 			return # 반환할 데이터 없이 실행하는 return문은 '반환'의 의미보다는 '함수종료'의 의미로 사용된다!
```

```
>>> ogamdo(3)
제 1의 이해
제 2의 이해
제 3의 이해
>>> ogamdo(5)
제 1의 이해
제 2의 이해
제 3의 이해
제 4의 이해
제 5의 이해
>>> ogamdo(8) # 8을 입력하면 for반복문은 8번 반복을 수행하려고 준비하겠지만 실행되는 return문 때문에 다섯 번 수행하면 함수가 종료되고 만다!
제 1의 이해
제 2의 이해
```

#### 함수 밖의 변수, 함수 안의 변수

```
>>> def scope_test():
 	 	a = 1 # 함수를 정의하는 시점에서는 a가 메모리에 생성되지 않았다. 함수를 호출하면 그제서야 함수의 코드가 실행되면서 a가 메모리에 생성된다!
 	 	print('a:{0}'.format(a))
 	 	
>>> a = 0 # 함수 밖에서 a를 정의하고 0으로 초기화한다!
>>> scope_test() # scope_test()가 호출되면 함수 내부에서 a를 정의하고 1로 초기화한다!
a:1
>>> print('a:{0}'.format(a)) # 하지만 함수 밖에서 정의한 a를 출력해보면 여전히 0을 갖고 있음을 확인할 수 있다!
a:0
```

```
>>> def scope_test():
 	 	global a # global 키워드는 지정한 변수의 유효 범위가 전역임을 알리고, 지역 변수의 생성을 막는다. 이 a는 scope_test() 함수 안에서 전역 변수로 사용된다!
 	 	a = 1 
 	 	print('a:{0}'.format(a))
 	 	
>>> a = 0
>>> scope_test() # scope_test()는 0으로 초기화된 a에 접근해 1로 값을 변경한다!
a:1
>>> print('a:{0}'.format(a)) # a를 출력해보면 scope_test() 함수 안에서 변경한 값 1이 들어있음을 확인 할 수 있다!
a:1 	
```

### 자기 스스로를 호출하는 함수: 재귀 함수

재귀 함수(Recursive Function)는 자기 스스로를 호출하는 함수를 말한다! 함수가 자기 자신을 부르는 것을 재귀 호출(Recursive Call)이라고 한다!

- 함수 자신이 호출자이자 피호출자가 되는것이다

```
>>> def some_func(count):
 	 	if count > 0:
 	 		some_func(count-1)
 		print(count)
```

- 재귀 함수는 편리하지만 호출 비용이 크다!

컴퓨터가 더 많은 일을 하게 만들어서 성능이 떨어지는 소프트웨어를 만들게 된다. 좋은 성능이 요구되는 코드에서는 재귀 함수를 반복문으로 대체해서 사용하는 것이 좋다.

### 함수를 변수에 담아 사용하기

파이썬에서는 함수를 변수에 담아 사용할 수 있다!

```
>>> def print_something(a):
  	 	print(a)
  	 	
>>> p = print_something # ()없이 함수의 이름만을 변수에 저장한다!
>>> p(123) # 변수의 이름 뒤에 ()를 붙여 함수처럼 호출한다!
123
>>> p('abc')
abc
```

### 함수안의 함수: 중첩 함수

함수 안에 정의된 함수를 중첩함수(Nested Fuction)라고 한다. 이 중첩 함수는 자신이 소속된 함수의 매개변수에 접근 할 수 있다.

```
>>> import math
>>> def stddev(*args):
  	 	def mean():	# 중첩 함수 ...
  	 		return sum(args)/len(args) # ... 중첩 함수
  	 		
  	 	def variance(m): # 중첩 함수 ...
  	 		total = 0 
  	 		for arg in args:
  	 			total += (arg - m ) ** 2
 			return total/len(args)-1) # ... 중첩 함수 			
	v = variance(mean())
	return math.sqrt(v)
	
>>> stddev(2.3, 1.7, 1.4, 0.7, 1.9)
0.6	
```

- mean()과 variance()는 중첩 함수의 특징을 활용하여, stddev()의 매개변수인 args에 접근해서 평균과 분산을 각각 계산한다!

## 모듈과 패키지

모듈(Module)은 대체적으로 '독자적인 기능을 갖는 구성 요소'를 의미한다!

- 파이썬에서는 각각의 소스파일을 일걸어 '모듈'이라고 한다.

### 두 개의 소스 파일로 만드는 하나의 프로그램 예제

*ex) calculator.py*

```
def plus(a, b):
    return a+b

def minus(a, b):
    return a-b

def multiply(a, b):
    return a*b;

def divide(a, b):
    return a/b
```

*ex) calc_tester.py*

```
import calculator # 불러올 모듈의 이름 calculator.py에서 '.py'는 생략한다.

print(calculator.plus(10, 5))
print(calculator.minus(10, 5)) # 모듈이름.함수()의 꼴로 clculator모듈의 함수를 호출한다.
print(calculator.multiply(10, 5))
print(calculator.divide(10, 5))
```

*ex) 실행 결과*

```
> calc_tester.py
15
5
50
2.0
```

함수들은 모두 calculator.py 모듈에 정의되어 있다. calc_tester.py 모듈에서 import문을 이용해 calculator.py 모듈을 불러들였기 때문에 이들 함수를 사용할 수 있었다. 

- 모듈을 분리함으로써 코드를 재사용할 수 있는 장점이 있다.

#### import에 대해

import를 사용하는 방법의 2가지

1.

```
import 모듈 # 모듈의 실제 파일 명은 "모듈.py"
```

2.

```
from 모듈 import 변수 또는 함수
```

#### 모듈을 찾아서

import문을 만나면 파이썬은 다음과 같은 순서로 모듈 파일을 찾아 나선다!

1. 파이썬 인터프리터 내장 모듈

2. sys.path에 정의되어 있는 디렉토리

sys.path에 정의되어 있는 디렉토리는 크게 3가지로 나눌 수 있다.

1. 파이썬 모듈이 실행되고 있는 현재 디렉토리

2. PYTHONPATH 환경변수에 정의되어 있는 디렉토리

3. 파이썬과 함께 설치된 기본 라이브러리

#### 메인 모듈과 하위 모듈

*"도대체 메인(main) 함수는 어디에 있는 거지?"*

- 파이썬에서는 이른바'최상위 수준(Top Level)'에서 실행되는 스크립트가 있을 뿐, 메인 함수가 따로 없다. 최상위 수준 실행은 별 다른게 아니라 명령 프롬프트 창이나 탐색기를 이용하여 파이썬 모듈을 실행하는 것이다.

**파이썬에서는 "어떻게 만드느냐"가 아닌 "어떻게 실행하느냐"에 따라 메인 모듈이 결정된다.**

### 패키지

파이썬에서는 모듈을 모아놓는 디렉토리를 패키지(Package)라고 한다. 영어로 패키지는 '꾸러미'라는 뜻을 가지고 있으니 파이썬에서는 '모듈 꾸러미' 정도로 생각하면 된다.

```
from my_package import calculator # 'from 패키지 import 모듈'의 골로 모듈을 불러온다! 

print(calculator.plus(10, 5))
print(calculator.minus(10, 5))
print(calculator.multiply(10, 5))
print(calculator.divide(10, 5))
```

#### ```__init__.py```의 이해

패키지란, '```__init__.py```파일을 갖고 있는 디렉토리'임을 뜻한다.

- ```__init__.py```파일은 대개 비워두는 것이 보통이다. 이 파일을 손대는 경우는 ```__all__```이라는 변수를 조정할때 정도이다. 

- ```__all__```은 패키지로부터 반입할 모듈의 목록을 정의하기 위해서 사용한다.

#### ```site-packages```에 대해

site-packags는 파이썬의 기본 라이브러리 패키지 외에 추가적인 패키지를 설치하는 디렉토리이다.

만든 패키지나 모듈을 site-packages 디렉토리에 위치시키면 어느 경로에서든 접근해 반입할 수 있다.

## 클래스

### 객체 지향 프로그래밍

#### 객체와 클래스

객체 지향 프로그래밍에서의 객체는 다음과 같이 정의된다.

**객체(Object) = 속성(Attribute) + 기능(Method)**

속성은 사물의 특징을 말한다. 

자동차로 예를 들면, 몸체의 색, 바퀴의 크기, 엔진의 배기량 등이 자동차의 속성이라 할 수 있다. 기능은 어떤 것의 특징적인 동작을 말한다.

다시 자동차로 예를 들면, 전진, 후진, 좌회전, 우회전등이 자동차의 기능이라고 할 수 있다!

- 속성을 '변수', 기능을 '함수'로 바꿔 '객체 = 변수 + 함수'라고 할 수 있다.

```
class Car: # Car 클래스의 정의 시작을 알린다
	def __init__(self):
		self.color = 0xFF0000 # Car 클래스 안에 차의 색, 바퀴 크기, 배기량을 나타내는 변수를 정의한다.
		self.wheel_size = 16
		self.displacement = 2000
		
	def forward(self): # 전진
		pass
		
	def backward(self): # 후진
		pass
		
	def turn_left(self): # 좌회전
		pass
		
	def turn_right(self): # 우회전 # Car 클래스 안에 전진, 후진, 좌회전, 우회전 함수를 정의
		pass
```

- 클래스는 자료형이고, 객체는 변수이다!

- 객체 대신에 인스턴스(Instance)라는 용어를 사용하기도 한다. 인스턴스는 실체, 사례라는 뜻으로 클래스가 설계도라면, 객체는 그 설계를 바탕으로 실체화 한 것이라는 뜻에서 유래한다.

#### 객체 지향 프로그래밍을 해야하는 이유!

한번 만들어서 세상에 내놓으면 고칠 일이 별로 없는 하드웨어와는 달리 소프트웨어는 세상에 내놓는 순간부터 챙겨줘야 할 것이 매우 많아진다. 이때 소프트웨어의 결합도가 높으면 코드를 고칠 때마다 부작용이 발생할 가능성이 높아진다. 결합도가 낮은 소프트웨어는 어느 한 부분을 수정하더라도 부작용에 대한 걱정을 줄일 수 있다. 

같은 목적과 기능을 위해 객체로 묶인 코드 요소(변수, 함수)들은 객체 내부에서만 강한 응집력을 발휘하고 객체 외부에 주는 영향은 줄이게 된다.

- 코드가 객체 위주로 이루어질 수 있도록 지향하는 프로그래머의 노력은 코드의 결합도를 낮추는 결과는 낳게 된다. 객체 지향 프로그래밍의 장점은 여기에 있다.

#### 클래스의 정의

클래스는 class 키워드를 이용하여 정의한다.

```
class 클래스이름:
	코드블록
```

- 파이썬에서는 콜론으로 끝나는 문장의 다음 줄에는 코드 블록이 위치할 것을 요구하는데, 클래스의 코드블록은 변수와 메소드(Method)로 이루어진다. 여기서 메소드는 클래스에 속해있는 함수를 말한다.

클래스 안에 정의되어 있는 변수와 메소드는 클래스의 멤버라고도 한다. 메소드는. 이미 용어 자체로 함수와 달리 클래스에 소속되어 있음을 알 수 있지만 변수의 경우에는 일반 변수와 클래스의 멤버 변수를 구분하기 어려우므로 '데이터 속성(Data Attribute)'이라는 용어가 사용된다.

```
class Car:
    def __init__(self):
        self.color = 0xFF0000    # 바디의 색
        self.wheel_size = 16     # 바퀴의 크기
        self.displacement = 2000 # 엔진 배기량

    def forward(self): # 전진
        pass

    def backward(self): # 후진
        pass

    def turn_left(self): # 좌회전
        pass

    def turn_right(self): # 우회전
        pass

if __name__ == '__main__':        
    my_car = Car() # 앞에서 정의한 Car클래스의 객체 my_car를 생성한다.

    print('0x{:02X}'.format(my_car.color)) # my_car의 정보를 출력
    print(my_car.wheel_size)
    print(my_car.displacement)

    my_car.forward() # my_car의 메소드를 호출
    my_car.backward()
    my_car.turn_left()
    my_car.turn_right()
```

*ex) 실행 결과*

```
> Car.py
0xFF0000
16
2000
```

#### ```__init__()``` 메소드를 이용한 초기화

클래스의 생성자가 호출되면 내부적으로 또 다른 두 개의 메소드가 호출된다. 하나는 ```__new__()```이고 또 다른 하나는 우리가 알고 있는 ```__init__()```이다. 이들은 마법(Magic)메소드 또는 특별(Special)메소드라고 불리운다.

**데이터 속성을 ```__init__()```메소드가 아닌 클래스에 직접 정의한다면 어떤 일이 일어날까?**

```
class ClassVar: # text_list는 ClassVar클래스의 정의 시점에 함께 메모리에 할당된다.
	text_list = []
	
obj = ClassVar() # obj객체가 생성되기 전부터 text_list는 메모리에 적재되어 있다.
```

*ex) 왜 ```__init__()```메소드를 사용해야하는가?*
 
```
class ClassVar:
    text_list = []

    def add(self, text):
        self.text_list.append(text)
    
    def print_list(self):
        print(self.text_list)

if __name__ == '__main__':        
    a = ClassVar()
    a.add('a')
    a.print_list() # ['a'] 출력을 기대
    
    b = ClassVar()
    b.add('b')
    b.print_list() # ['b'] 출력을 기대
```

*ex) 실행 결과*

```
> ClassVar.py
['a'] # 객체 a를 통해 'a'를 입력하고 a의 text_list 내용을 출력.
['a','b']	# 객체 b를 통해 'b'를 입력하고 b의 text_list 내용을 출력했다. 하지만 객체 'b'에서는 입력하지 않은 'a'가 들어 있다. 이것은 클래스 속성으로 정의된 text_list변수를 ClassVar의 모든 인스턴스가 공유하게 되어 생긴 문제이다!
```

- 인스턴스가 생성될 때에만 ```__init__()```메소드가 실행되므로 이 메소드 안에 변수 정의/초기화 코드를 넣어 놓으면 모든 인스턴스가 변수를 공유하게 되는 불상사는 피할 수 있다.

```
class InstanceVar:
    def __init__(self):
        self.text_list = []

    def add(self, text):
        self.text_list.append(text)
    
    def print_list(self):
        print(self.text_list)

if __name__ == '__main__':        
    a = InstanceVar()
    a.add('a')
    a.print_list() # ['a'] 출력을 기대
    
    b = InstanceVar()
    b.add('b')
    b.print_list() # ['b'] 출력을 기대
```

*ex) 실행 결과*

```
> InstanceVar.py
['a']
['b'] # __init__()메소드 안에서 정의한 text_list는 각 객체마다 고유한 인스턴스로 사용하므로 ClassVar.py에서와 같은 부작용이 사라졌다!!!
```

- ```__init__()``` 메소드의 이름은 '초기화하다'는 뜻의 initailize를 줄여서 붙여진 것이다.

#### self에 대해

self는 '자아'또는 '자신'이라는 뜻이다. 파이썬의 메소드에 사용되는 self는 메소드가 소속되어 있는 객체이다. 

```
class ContactInfo:
	def __init__(self, name, email):
		self.name = name
		self.email = email
		
	kyeonghan = ContactInfo('윤경한', 'zizou0812@gmail.com')
```

- ContactInfo 외부에서는 kyeonghan 이라는 이름으로 객체를 다룰 수 있다. 내부에서는 kyeonghan처럼 객체를 지칭할 수 있는 이름이 없다. 그래서 self를 도입한 것이다!

#### 정적 메소드와 클래스 메소드

**인스턴스 메소드는 인스턴스(객체)에 속한 메소드를 말한다**

인스턴스 메소드가 "인스턴스에 속한다"라는 표현은 "인스턴스를 통해 호출가능하다"라는 뜻이다. 그렇다면 클래스에 속한(클래스를 통해 호출 가능한) 메소드도 있을까? 있다. 정적 메소드(Static Method)와 클래스 메소드(Class Method)가 바로 그런 메소드 이다.

*ex) 정적메소드의 예*

```
class Calculator:
	
	@staticmethod
	def plus(a, b): # 당연히 정적 메소드도 매개변수를 받는다. self는 제외!
		return a+b
```

*ex) 사칙연산 함수를 활용하는 정적메소드 예제*

```
class Calculator:

    @staticmethod # 클래스 안에 정의되었지만 self를 매개변수로 받지 않는다.
    def plus(a, b):
        return a+b

    @staticmethod
    def minus(a, b):
        return a-b

    @staticmethod
    def multiply(a, b):
        return a*b

    @staticmethod        
    def divide(a, b):
        return a/b
        
if __name__ == '__main__':        
    print("{0} + {1} = {2}".format(7, 4, Calculator.plus(7, 4))) # 정적 메소드는 인스턴스 대신 클래스 이름을 통해 메소드에 접근한다. "클래스이름.메소드()"의 형태!
    print("{0} - {1} = {2}".format(7, 4, Calculator.minus(7, 4)))
    print("{0} * {1} = {2}".format(7, 4, Calculator.multiply(7, 4)))
    print("{0} / {1} = {2}".format(7, 4, Calculator.divide(7, 4)))
```

*ex) 실행 결과*

```
> Calculator.py
7 + 4 = 11
7 + 4 = 3
7 + 4 = 28
7 + 4 = 1.75
```

- 정적 메소드는 self 매개변수를 전달받을 방법이 없으므로(self 매개변수는 인스턴스 메소드에게만 파이썬이 전달해준다) 객체/인스턴스의 변수에 접근 할 수 없다.

- 따라서, 정적 메소드는 객체의 데이터 속성과는 관계가 없는 코드로 구현되는 것이 일반적이다.

*ex) 클래스 메소드의 예*

```
class 클래스이름:
	# ...  
	
	@classmethod # 클래스 메소드를 정의하기 위해서는 1. @classmethod 데코레이터를 앞에 붙여준다. 
	def 메소드이름(cls): # 2. 메소드의 매개변수를 하나 이상 정의한다.
		pass
```

*ex) cls 매개변수를 통해 클래스 속성에 접근하는 방법 예제*

```
class InstanceCounter:
    count = 0
    def __init__(self): # 인스턴스가 만들어질 때마다 __init__()메소드가 실행된다. 인스턴스의 수를 세기에는 이곳이 적절하다!
        InstanceCounter.count += 1
    
    @classmethod
    def print_instance_count(cls): # print_instance_count() 메소드는 InstanceCounter의 클래스 속성인 count를 출력한다.
        print(cls.count)

if __name__ == '__main__':        
    a = InstanceCounter()
    InstanceCounter.print_instance_count()
    
    b = InstanceCounter()
    InstanceCounter.print_instance_count()
    
    c = InstanceCounter()
    c.print_instance_count()
```

*ex) 실행 결과*

```
> InstanceCounter.py
1
2
3
```

#### 클래스 내부에게만 열려있는 프라이빗 멤버

클래스의 안에서만 접근이 가능한 멤버를 일컬어 '프라이빗(Private)'멤버라고 한다. 반대로 안과 밖 모두에서 접근이 가능한 멤버는 '퍼블릭(Public)'멤버라고 한다. 

파이썬은 다른 프로그래밍 언어들과는 달리 작명법(Naming)으로 둘을 구분한다!

프라이빗 멤버의 명명 규칙은 다음과 같다!

1. 두 개의 밑줄 __이 접두사여야 한다. 예) ```_number```

2. 접미사는 밑줄이 한 개까지만 허용된다. 예) ```_number_```
	
	- 접미사의 밑줄이 두 개 이상이면 퍼블릭 멤버로 간주한다. 예) ```__number__```

#### 상속

클래스끼리 데이터를 물려주는 것을 일컬어 '상속(Inheritance)'이라고 한다.

객체 지향 프로그래밍에서는 물려 받는 클래스(파생 클래스(Derived Class) 또는 자식 클래스라고 한다)가 유산을 물려줄 클래스(기반 클래스(Base Class)또는 부모 클래스라고 한다)를 지정한다. 

*ex) 상속 개념*

```	
class 기반 클래스:
	# 멤버 정의
	
class 파생 클래스(기반 클래스)
	# 아무 멤버를 정의하지 않아도 기반 클래스의 모든 것을 물려받아 갖게 된다.
	# 단, 프라이빗 멤버(_로 시작하는 이름을 갖는 멤버)는 제외
```

#### super()

super()는 부모 클래스의 객체 역할을 하는 프록시(Proxy)를 반환하는 내장 함수이다!

- 사실상, super()함수의 반환값을 상위 클래스의 객체로 간주하고 코딩을 해도 된다.

super()를 사용함으로써, 기반 클래스가 다른 클래스로 교체되거나 수정되어도 파생 클래스가 받는 영향을 최소화 할 수 있다.

#### 다중 상속

파이썬에서는 파생 클래스를 정의할때 기반 클래스의 이름을 콤마(,)로 구분해서 쭉 적어주면 다중 상속이 이루어진다. 

*ex) 다중 상속의 예*

```
class A:
	pass
	
class B:
	pass
	
class C:
	pass
	
class D(A, B, C): # 클래스 D는 A, B, C로부터 상속받는다.
	pass
```

#### 오버라이딩

오버 라이딩(Overriding)은 영어로 짓밟다. (결정 등을) 무효로 하다. ~에 우선하다 등의 뜻을 갖고 있다. OOP에서 오버라이딩의 뜻은 "기반(부모) 클래스로부터 상속받은 메소드를 다시 정의하다"이다. 

*ex) 오버라이딩의 예*

```
>>> class A:
     	def method(self):
     		print("A")
     		
>>> class B(A):
    	def method(self):
    		print("B")
    		
>>> class C(A):
    	def method(self):
    		print("C")
    		
>>> A().method()
A
>>> B().method()
B
>>> C().method()
C
```

- 위의 코드에서 클래스 B와 C는 A를 상속하고 있기 때문에 가만히 있어도 method()를 물려받을 수 있었다. 하지만 그렇게 하지 않았다. 자신만의 method()를 새로 정의했다. 이것이 **오버라이딩**이다!

### 데코레이터: 함수를 꾸미는 객체

#### 데코레이터는 ```__call__()``` 메소드를 구현하는 클래스

```__call__()``` 메소드는 객체를 함수 호출 방식으로 사용하게 만드는 마법 메소드이다!

*ex) ```__call__()``` 예*

```
class MyDecorator:
	def __init__(self, f): # __init__() 메소드의 매개변수를 통해 함수를 받아들이고 데이터 속성에 저장해둔다.
		print("Initializing MyDecorator...")
		self.func = f
		
	def __call__(self):
		print("Begin :{0}".format( self.func.__name__))
		
		self.func() # __call__() 메소드가 호출되면서 생성자에서 저장해둔 함수(데이터 속성)를 호출한다!
		
		print("End :{0}".format(self.func.__name__))
```

#### 데코레이터를 생성하는 방법 1: 생성자

앞서 정의한 MyDecorator 클래스의 경우는 다음과 같이 데코레이터의 인스턴스를 만들어 사용한다.

```
def print_hello():
	print("Hello")
	
print_hello = MyDecorator(print_hello)
```

*ex) 데코레이터의 예*

```
class MyDecorator:
    def __init__(self, f):
        print("Initializing MyDecorator...")
        self.func = f # MyDecorator의 func 데이터 속성이 print_hello를 받아둔다.

    def __call__(self):
        print ("Begin :{0}".format( self.func.__name__))
        self.func()
        print ("End :{0}".format(self.func.__name__))

def print_hello():
    print("Hello.")

print_hello = MyDecorator(print_hello) # MyDecorator의 인스턴스가 만들어지며 __init__()메소드가 호출된다. print_hello 식별자는 앞에서 정의한 함수가 아닌 MyDecorator의 객체이다.
    
print_hello() # __call__()메소드 덕에 MyDecorator 객체를 호출하듯 사용 할 수 있다.
```

*ex) 실행 결과*

```
> decorator.py
Initializing MyDecorator ...
Begin :print_hello
Hello.
End :print_hello
```

#### 데코레이터를 사용하는 방법 2: @ 기호

데코레이터(장식)이라는 이름답게 사용하려면 @데코레이터의 꼴로 사용하는 것이 바람직하다. 앞에서는 생성자를 호출해서 데코레이터의 인스턴스를 만들었지만, @ 기호로 시작하는 데코레이터 전용 문법을 이용하면 함수에 꽃장식을 꽂아놓듯 간단하게 데코레이터의 인스턴스를 만들 수 있다.

*ex) @ 데코레이터 예*

```
class MyDecorator:
    def __init__(self, f):
        print("Initializing MyDecorator...")
        self.func = f

    def __call__(self):
        print ("Begin :{0}".format( self.func.__name__))
        self.func()
        print ("End :{0}".format(self.func.__name__))

@MyDecorator        
def print_hello():
    print("Hello.")

print_hello()
```

*ex) 실행 결과*

```
> decorator2.py
Initializing MyDecorator ...
Begin :print_hello
Hello.
End :print_hello
```

### for문으로 순회를 할 수 있는 객체 만들기

#### 이터레이터와 순회 가능한 객체

파이썬에서 for문을 실행할 때 가장먼저 하는 일은 순회하려는 객체의 ```__iter__()```메소드를 호출하는 것이다. ```__iter__()```메소드는 이터레이터(Iterator)라고 하는 특별한 객체를 for문에게 반환한다.

이터레이터는 ```__next__()```메소드를 구현하는 객체를 말하는데, for문은 매 반복을 수행할 때마다 바로 이 ```__next__()```메소드를 호출하여 다음 요소를 얻어낸다.

*ex) 이터레이터 예*

```
class MyDecorator:
    def __init__(self, f):
        print("Initializing MyDecorator...")
        self.func = f

    def __call__(self):
        print ("Begin :{0}".format( self.func.__name__))
        self.func()
        print ("End :{0}".format(self.func.__name__))

@MyDecorator        
def print_hello():
    print("Hello.")

print_hello()
```

*ex) 실행 결과*

```
0
1
2
3
4
```

#### 제네레이터

제네레이터(Generator)는 이터레이터처럼 동작하는 함수이다. 하지만 이터레이터보다 훨씬 더 간편하게 구현가능하다.

클래스를 정의하지 않아도 되고 ```__init__()```메소드나 ```__next__()```메소드를 구현 할 필요도 없다. 그저 함수 안에서 yield문을 이용하여 값을 반환하면 된다.

- yeild문은 상당히 독특하다. return문처럼 함수를 실행하다가 값을 반환하지만, return문과는 달리 함수를 종료시키지는 않고 중단시켜 놓기만 한다. 

*ex) 제네레이터 예*

```
def YourRange(start, end):
    current = start
    while current < end:
        yield current
        current += 1
    return

for i in YourRange(0, 5):
    print(i)
```

*ex) 실행 결과*

```
0
1
2
3
4
```

#### 상속의 조건: 추상 기반 클래스

"미운 오리 새끼"에서 아기 오리가 엄마 오리에게 미움을 받았던 이유는 단 하나.

외모이다. 미운 아기 오리는 사실 오리가 아니라 백조였다. 엄마 오리는 아무리 봐도 오리라고는 할 수 없는 아기 백조를 내치고 다른 아기 오리들만을 챙겼다.

프로그래머도 종종 엄마 오리와같은 입장이 될 때가 있다. 부모 클래스를 정의할 때 자식 클래스가 갖춰야 하는 모습을 규약으로 정의해 두고 이 규약을 따르지 않는 자식은 자식으로 인정하지 않는것이다. 추상 기반 클래스(Abstract Base Class)는 자식 클래스가 갖춰야 할 특징(메소드)을 강제하는 기능을 한다. 만약 추상 기반 클래스가 요구하는 메소드를 자식 클래스가 구현하지 않는다면, 자식 클래스의 인스턴스를 생성하고자 할 때 파이썬은 TypeError 예외를 일으킨다!    
 
```
from abc import ABCMeta
from abc import abstractmethod

class AbstractDuck(metaclass=ABCMeta):
	@abstractmethod
	def Quack(self):
		pass
```

- 파이썬에서는 모든 것이 객체이다. 심지어 클래스도 객체이다. 그러니 이 객체의 자료형인 클래스가 존재해야 한다. 메타 클래스는 '클래스에 대한 정보를 갖고 있는 클래스'를 말한다. 클래스를 정의할 때 metaclass에 별도의 메타 클래스를 지정하지 않으면 type 클래스가 기본적으로 사용된다.

## 오류를 어떻게 다뤄야 할까?

### 예외

파이썬에서 예외(Exception)는 문법적으로는 문제가 없는 코드를 실행하는 중에 발생하는 오류를 말한다.

#### try ~ except로 예외 처리하기

파이썬의 예외 처리는 try ~ except구문을 이용한다.

- try 절 안에는 문제가 없을 경우, 정상적인 경우에 실행할 코드블록을 배치한다.

- except 절에는 문제가 생겼을 때 뒤처리를 하는 코드 블록을 배치한다.

```
try: 
	# 문제가 없을 경우 실행할 코드
except:
	# 문제가 생겼을 때 실행할 코드
```

#### 여러 개의 except절 사용하기

프로그램이 하는 일이 많아지고 코드의 양이 늘어나면 처리해야 할 예외도 늘어난다. 늘어난 예외의 종류에 따른 예외처리를 구현하려면 하나 이상의 except절을 사용해야 한다. 

```
try:
	# 문제가 없을 경우 실행할 코드
except 예외형식1:
	# 문제가 생겼을 때 실행할 코드
except 에외형식2:
	# 문제가 생겼을 때 실행할 코드
```

#### try절을 무사히 실행하면 만날 수 있는 else

try와 함께 사용하는 else는 if문에서 사용하는 else와는 다르다. 이 else절은 try절에 있는 코드블록 실행중에 아무런 예외가 일어나지 않으면 실행된다. 

- 말하자면, try에 대한 else가 아닌 'except절에 대한 else'인 것이다.

```
try:
	# 실행할 코드블록
except: 
	# 예외 처리 코드블록
else:
	# except절을 만나지 않았을 경우 실행하는 코드블록
```

*ex) else 예*

```
my_list = [1, 2, 3]

try:
    print("첨자를 입력하세요:")
    index = int(input())
    print("my_list[{0}]: {1}".format(index, my_list[index]))
except Exception as err:
    print("예외가 발생했습니다 ({0})".format(err))
else:
    print("리스트의 요소 출력에 성공했습니다.")
```

*ex) 실행 결과*

```
> try_except_else.py
첨자를 입력하세요:
1
my_list[1]: 2
리스트의 요소 출력에 성공했습니다.

> try_except_else.py
첨자를 입력하세요:
10
예외가 발생했습니다 (list index out of range)
```

#### 어떤 일이 있어도 반드시 실행되는 finally

finally는 else와 비슷하면서도 매우 다르다. else는 except절이 실행되면 실행되지 않고, except절이 실행되지 않으면 실행됐었다. finally는 예외가 발생했든 아무 일이 없든 간에 '무조건'실행된다.

#### Exception 클래스

파이썬은 오류 상황에 대한 정보를 담는 예외 형식을 다양하게 제공한다. 그 예외 형식들의 맨 위에는 BaseException 클래스가 있다. 파이썬의 모든 예외 형식은 BaseException 클래스로부터 상속받는다.

- BaseException이 예외 클래스 족보의 시조이긴 하지만, 실질적인 시조로 간주되는 것은 그 밑에 있는 Exception클래스이다. 파이썬 코드를 작성하면서 사용되는 예외 형식은 거의 모두 Exception 클래스로부터 상속을 받는다.

#### 우리도 예외 좀 일으켜보자

우리가 작성한 코드도 파이썬의 함수나 연산자처럼 예외를 일으킬 수 있다. 예외 객체를 매개변수로 넘겨 raise문을 실행하면 된다. 

*ex) raise 예*

```
text = input()
if text.isdigit() == False:
	raise Exception("입력받은 문자열이 숫자로 구성되어 있지 않습니다."):
```

raise문을 통해 발생시킨 예외는 except문으로 받아 처리하지 않으면 자신을 받아주는 곳이 나올 때 까지 상위 코드로 나아간다. 

- 함수에서 일어난 예외를 함수 안에서 처리하지 않으면 그 예외는 함수의 호출자에게로 던져진다. 그 호출자도 처리를 안하고 그 호출자의 호출자도 처리를 안하다 보면 앞에서 본 것처럼 파이썬 인터프리터가 받나낸다.

*ex) 함수 안에서 예외를 일으키고 이것을 호출자에서 받아 처리하는 예*

```
def some_function():
    print("1~10 사이의 수를 입력하세요:")
    num = int(input())
    if num < 1 or num > 10:
        raise Exception("유효하지 않은 숫자입니다.: {0}".format(num))
    else:
        print("입력한 수는 {0}입니다.".format(num))

try:
    some_function()
except Exception as err: # 함수 안에서 일어난 예외가 except문으로 처리되지 않으면 함수 밖으로 다시 던져진다.
    print("예외가 발생했습니다. {0}".format(err))
```

*ex) 실행 결과*

```
> raise_in_function.py
1~10 사이의 수를 입력하세요:
5
입력한 수는 5입니다.

> raise_in_function.py
1~10 사이의 수를 입력하세요:
12
예외가 발생했습니다. 유효하지 않은 숫자입니다.: 12
```

#### 내가 만든 예외 형식

필요한 예외 형식(사용자 정의 예외 형식)을 직접 만들어 사용하려면 Exception 클래스를 상속하는 클래스를 정의하면 된다.

```
class MyException(Exception):
	pass
```

*ex) 직접 정의한 예외 형식 예*

```
class InvalidIntException(Exception):
    def __init__(self, arg):
        super().__init__('정수가 아닙니다.: {0}'.format(arg))
 
def convert_to_integer(text):
    if text.isdigit(): # 부호(+, -) 처리 못함.
        return int(text)
    else:
        raise InvalidIntException(text)

if __name__ == '__main__':
    try:
        print('숫자를 입력하세요:')
        text = input()
        number = convert_to_integer(text)        
    except InvalidIntException as err:
        print('예외가 발생했습니다 ({0})'.format(err))
    else:
        print('정수 형식으로 변환되었습니다 : {0}({1}'.format(number, type(number)))
```

*ex) 실행 결과*

```
> InvalidIntException.py
숫자를 입력하세요:
123
정수 형식으로 변환되었습니다 : 123(<class 'int'>

> InvalidIntException.py
숫자를 입력하세요:
abc
예외가 발생했습니다. (정수가 아닙니다.: abc)
```
