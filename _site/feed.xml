<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yoonkh blog</title>
    <description>back-end Developer
</description>
    <link>http://yoonkh.github.io/</link>
    <atom:link href="http://yoonkh.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 07 Dec 2017 11:23:11 +0900</pubDate>
    <lastBuildDate>Thu, 07 Dec 2017 11:23:11 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>RESTful API 작성 팁</title>
        <description>&lt;h1 id=&quot;restfulapi---&quot;&gt;restfulAPI 문서 작성하는 방법&lt;/h1&gt;

&lt;p&gt;API가 세상을 집어삼키고 있다는 말이 사실이라면, API를 이해하기 쉽고 사용하기도 쉽게 만드는 일이 굉장히 중요해 진다. API 문서를 일종의 요리법이라고 생각해본다면, 잘 작성된 요리법을 따라 요리사가 멋진 음식을 만들 듯이, 간결하면서 유익하며 읽기에도 쉬운 API문서가 있어야만 다른 개발자들이 API를 사용하여 멋진 무언가를 만들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 코드를 작성하기 전에 스스로에게 도움이 되기&lt;/h2&gt;

&lt;p&gt;API를 잘 설계해 두었다면 문서화하기도 쉬울 것이다. 일관성을 유지해야한다. 일관된 명명 규칙을 사용하고 기존의 표준을 따른다면, 한번만 문서화를 해도 된다. HTTP 상태 코드를 예로 들면, 의미를 왜곡시키지말고, 새로운 상태 코드를 만들지도 않아야 한다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;역시 200은 정상(OK)이라는 의미이고, 404는 찾지 못했다(Not Found)라는 의미이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTP 메소드도 마찬가지다. 새로 만들 땐 POST, 삭제는 DELETE를 사용해야 한다. 이들은 이미 정립된 규약이다. 단 하나의 예외가 있다면 PUT과 PATCH이다. 이 메소드들은 아직 문서가 불분명하다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 사용자 관점에서 문서 작성하기&lt;/h2&gt;

&lt;p&gt;사용자들은 여러분이 작업할 때 생각하는 방식으로 API에 접근한다는 점을 기억해야 한다. 예를 들어, 여러분이 결제 처리기를 제공한다면, 사용자들은 요금과 환불, 소비자, 신용카드 등을 떠올릴 것이다. 그렇다면 API문서 역시도 이런 과정들을 그룹화 해야 한다. 깃헙은 훌륭한 RESTfulAPI 문서의 모범을 제공한다.&lt;/p&gt;

&lt;h2 id=&quot;uri-----&quot;&gt;3. URI를 전면에 내세우거나 중심에 두지 말아야한다&lt;/h2&gt;

&lt;p&gt;문서에서 URI를 가장 명확하게 만드는 방법은 사용자에게 API 로직과 HTTP 클라이언트 사이의 연결 관계를 이해시키는 것이다. 많은 사용자들이 URI를 하드코딩하기 때문에, 만약에 여러분이 하이퍼링크가 포함된 콘트롤을 사용하다가 변경한다면 API를 사용하는 클라이언트들도 망가질 것이다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4. 글쓰기 도구로 작성하기&lt;/h2&gt;

&lt;p&gt;가능한 한 글쓰기에 적합한 형태로 작성해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;5. 예제 코드는 자동으로 생성하고, 설명과 잘 연결되어야 한다&lt;/h2&gt;

&lt;h2 id=&quot;section-4&quot;&gt;6. 미래를 대비해야 한다&lt;/h2&gt;

&lt;p&gt;리처드슨의 성숙도 모델을 통해 여러분의 API가 어느 단계에 와 있는 지 알 수 있다. 문서화 도구가 허용하는 범위 이상으로 코드를 RESTful하게 하고 싶다면(혹은 그럴 계획이 있다면), 문서화 도구가 발목을 잡을지도 모른다.&lt;/p&gt;

</description>
        <pubDate>Fri, 01 Dec 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/restfulapi/2017/12/01/restful.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/restfulapi/2017/12/01/restful.html</guid>
        
        <category>RESTfulAPI</category>
        
        
        <category>RESTfulAPI</category>
        
      </item>
    
      <item>
        <title>Jump to Python - 정규표현식과 XML</title>
        <description>&lt;h2 id=&quot;xml&quot;&gt;정규표현식과 XML&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;정규 표현식 살펴보기&lt;/h3&gt;

&lt;p&gt;정규 표현식(Regular Expressions)은 복잡한 문자열을 처리할 때 사용하는 기법으로, 파이썬만의 고유 문법이 아니라 문자열을 처리하는 모든 곳에서 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;정규 표현식 시작하기&lt;/h3&gt;

&lt;h3 id=&quot;section-2&quot;&gt;정규 표현식의 기초, 메타 문자&lt;/h3&gt;

&lt;p&gt;정규 표현식에서 사용하는 메타 문자(meta characters)에는 다음과 같은 것들이 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;. ^ $ * + ? { } [ ] \ | ( )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;문자 클래스 [ ]&lt;/h4&gt;

&lt;p&gt;우리가 가장 먼저 살펴 볼 메타 문자는 바로 문자 클래스(character class)인 [ ]이다. 문자 클래스로 만들어진 정규식은 “[와 ] 사이의 문자들과 매치”라는 의미를 갖는다.&lt;/p&gt;

&lt;h4 id=&quot;dot&quot;&gt;Dot(.)&lt;/h4&gt;

&lt;p&gt;정규 표현식의 Dot(.) 메타 문자는 줄바꿈 문자인 &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt;를 제외한 모든 문자와 매치됨을 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;반복 (*)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ca*t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 정규식에는 반복을 의미한는 * 메타문자가 사용되었다. 여기서 사용된 *의 의미는 *바로 앞에 있는 문자 a가 0부터 무한대로 반복될 수 있다는 의미이다.&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;반복 (+)&lt;/h4&gt;

&lt;p&gt;반복을 나타내는 또 다른 메타 문자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;가 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;는 최소 1번 이상 반복될 때 사용한다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;가 반복 횟수 0부터라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;는 반복 횟수 1부터인 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ca+t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 정규식의 의미는 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;“c + a(1번 이상 반복) + t”&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;mn-&quot;&gt;반복 ({m,n}, ?)&lt;/h4&gt;

&lt;p&gt;{ } 메타 문자를 이용하면 반복 횟수를 고정시킬 수 있다. {m, n} 정규식을 사용하면 반복 횟수가 m부터 n까지인 것을 매치할 수 있다. 또한 m 또는 n을 생략할 수도 있다. 만약 {3,} 처럼 사용하면 반복 횟수가 3 이상인 경우이고 {,3} 처럼 사용하면 반복 횟수가 3 이하인 것을 의미한다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※ &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;와 동일하며 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;와 동일하다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;m&quot;&gt;1. {m}&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ca{2}t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;“c + a(반드시 2번 반복) + t”&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;m-n&quot;&gt;2. {m, n}&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ca{2,5}t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;“c + a(2~5회 반복) + t”&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;re-&quot;&gt;파이썬에서 정규 표현식을 지원하는 re 모듈&lt;/h3&gt;

&lt;p&gt;파이썬은 정규 표현식을 지원하기 위해 re(regular expression의 약어) 모듈을 제공한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; p = re.compile('ab*')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;re.compile 을 이용하여 정규표현식(위 예에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ab*&lt;/code&gt;)을 컴파일하고 컴파일된 패턴객체(re.compile의 결과로 리턴되는 객체 p)를 이용하여 그 이후의 작업을 수행할 것이다.&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;정규식을 이용한 문자열 검색&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Method&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;목적&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;match()&lt;/td&gt;
      &lt;td&gt;문자열의 처음부터 정규식과 매치되는지 조사한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;search()&lt;/td&gt;
      &lt;td&gt;문자열 전체를 검색하여 정규식과 매치되는지 조사한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;findall()&lt;/td&gt;
      &lt;td&gt;정규식과 매치되는 모든 문자열(substring)을 리스트로 리턴한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;finditer()&lt;/td&gt;
      &lt;td&gt;정규식과 매치되는 모든 문자열(substring)을 iterator 객체로 리턴한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;match--&quot;&gt;match 객체의 메서드&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;method&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;목적&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;group()&lt;/td&gt;
      &lt;td&gt;매치된 문자열을 리턴한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;start()&lt;/td&gt;
      &lt;td&gt;매치된 문자열의 시작 위치를 리턴한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;end()&lt;/td&gt;
      &lt;td&gt;매치된 문자열의 끝 위치를 리턴한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;span()&lt;/td&gt;
      &lt;td&gt;매치된 문자열의 (시작, 끝)에 해당하는 튜플을 리턴한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-7&quot;&gt;컴파일 옵션&lt;/h2&gt;

&lt;p&gt;정규식을 컴파일할 때 다음과 같은 옵션을 사용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DOTALL(S) - . 이 줄바꿈 문자를 포함하여 모든 문자와 매치할 수 있도록 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IGNORECASE(I) - 대소문자에 관계없이 매치할 수 있도록 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MULTILINE(M) - 여러줄과 매치할 수 있도록 한다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 메타문자의 사용과 관계가 있는 옵션이다)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;VERBOSE(X) - verbose 모드를 사용할 수 있도록 한다. (정규식을 보기 편하게 만들수 있고 주석등을 사용할 수 있게된다.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;옵션을 사용할 때는 re.DOTALL처럼 전체 옵션명을 써도 되고 re.S처럼 약어를 써도 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;강력한 정규 표현식의 세계로&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;메타 문자&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; 등의 메타문자는 매치가 진행될 때 현재 매치되고 있는 문자열의 위치가 변경된다. (보통 소모된다고 표현한다.) 하지만 이와 달리 문자열을 소모시키지 않는 메타 문자들도 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 메타문자는 “or”의 의미와 동일하다. &lt;code class=&quot;highlighter-rouge&quot;&gt;A|B&lt;/code&gt; 라는 정규식이 있다면 이것은 A 또는 B라는 의미가 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 메타문자는 문자열의 맨 처음과 일치함을 의미한다. 이전에 알아보았던 컴파일 옵션 &lt;code class=&quot;highlighter-rouge&quot;&gt;re.MULTILINE&lt;/code&gt; 을 사용할 경우에는 여러줄의 문자열에서는 각 라인의 처음과 일치하게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 메타문자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 메타문자의 반대의 경우이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;는 문자열의 끝과 매치함을 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\A&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\A&lt;/code&gt;는 문자열의 처음과 매치됨을 의미한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\Z&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\Z&lt;/code&gt;는 문자열의 끝과 매치됨을 의미한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;는 단어 구분자(Word boundary)이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\B&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\B&lt;/code&gt; 메타문자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt; 메타문자의 반대의 경우이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;그룹핑&lt;/h2&gt;

&lt;p&gt;ABC라는 문자열이 계속해서 반복되는지 조사하는 정규식을 작성하고 싶다고 하자. 어떻게 해야 할까? 지금까지 공부한 내용으로는 위 정규식을 작성할 수 없다. 이럴 때 필요한 것이 바로 그룹핑(Grouping) 이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 경우는 다음처럼 그룹핑을 이용하여 작성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(ABC)+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;그룹을 만들어 주는 메타문자는 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = re.compile('(ABC)+')
&amp;gt;&amp;gt;&amp;gt; m = p.search('ABCABCABC OK?')
&amp;gt;&amp;gt;&amp;gt; print(m)
&amp;lt;_sre.SRE_Match object at 0x01F7B320&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(m.group())
ABCABCABC
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다음의 예를 보자!!!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = re.compile(r&quot;\w+\s+\d+[-]\d+[-]\d+&quot;)
&amp;gt;&amp;gt;&amp;gt; m = p.search(&quot;park 010-1234-1234&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\w+\s+\d+[-]\d+[-]\d+&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;이름 + &quot; &quot; + 전화번호&lt;/code&gt; 형태의 문자열을 찾는 정규표현식이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;그룹핑된 문자열 재참조하기&lt;/h3&gt;

&lt;p&gt;정규식 내에 그룹이 무척 많아진다고 가정해 보자. 예를 들어 정규식 내에 그룹이 10개 이상만 되어도 매우 혼란스러울 것이다. 거기에 더해 정규식이 수정되면서 그룹이 추가, 삭제되면 그 그룹을 인덱스로 참조했던 프로그램들도 모두 변경해 주어야 하는 위험도 갖게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;약 그룹을 인덱스가 아닌 이름(Named Groups)으로 참조할 수 있다면 어떨까? 그렇다면 이런 문제들에서 해방되지 않을까?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이러한 이유로 정규식은 그룹을 만들 때 그룹명을 지정할 수 있게 했다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
  (?P&amp;lt;name&amp;gt;\w+)\s+((\d+)[-]\d+[-]\d+)
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-12&quot;&gt;전방탐색&lt;/h2&gt;

&lt;p&gt;정규식에 막 입문한 사람들이 가장 어려워하는 것이 바로 전방 탐색(Lookahead Assertions) 확장 구문이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = re.compile(&quot;.+:&quot;)
&amp;gt;&amp;gt;&amp;gt; m = p.search(&quot;http://google.com&quot;)
&amp;gt;&amp;gt;&amp;gt; print(m.group())
http:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;정규식 &lt;code class=&quot;highlighter-rouge&quot;&gt;.+:&lt;/code&gt; 과 일치하는 문자열로 “http:”가 리턴되었다. 하지만 “http:” 라는 검색 결과에서 “:”을 제외하고 출력하려면 어떻게 해야 할까? 위 예는 그나마 간단하지만 훨씬 복잡한 정규식이어서 그룹핑은 추가로 할 수 없다는 조건까지 더해진다면 어떻게 해야 할까?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이럴 때 사용할 수 있는 것이 바로 전방 탐색이다. 전방 탐색에는 긍정(Positive)과 부정(Negative)의 2종류가 있고 다음과 같이 표현된다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;긍정형 전방 탐색(&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=...)&lt;/code&gt;) - &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; 에 해당되는 정규식과 매치되어야 하며 조건이 통과되어도 문자열이 소모되지 않는다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;부정형 전방 탐색(&lt;code class=&quot;highlighter-rouge&quot;&gt;(?!...)&lt;/code&gt;) - &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;에 해당되는 정규식과 매치되지 않아야 하며 조건이 통과되어도 문자열이 소모되지 않는다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;긍정형 전방 탐색&lt;/h3&gt;

&lt;p&gt;긍정형 전방 탐색을 이용하면 http:의 결과를 http로 바꿀 수 있다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = re.compile(&quot;.+(?=:)&quot;)
&amp;gt;&amp;gt;&amp;gt; m = p.search(&quot;http://google.com&quot;)
&amp;gt;&amp;gt;&amp;gt; print(m.group())
http
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정규식 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;에 해당하는 부분이 긍정형 전방탐색 기법이 적용되어 &lt;code class=&quot;highlighter-rouge&quot;&gt;(?=:)&lt;/code&gt; 으로 변경되었다. 이렇게 되면 기존 정규식과 검색에서는 동일한 효과를 발휘하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;에 해당되는 문자열이 정규식 엔진에 의해 소모되지 않아(검색에는 포함되지만 검색 결과에는 제외됨) 검색 결과에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;이 제거된 후 리턴되는 효과가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-14&quot;&gt;부정형 전방 탐색&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.*[.](?!bat$).*$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;확장자가 bat가 아닌 경우에만 통과된다는 의미이다. bat라는 문자열이 있는지 조사하는 과정에서 문자열이 소모되지 않으므로 bat가 아니라고 판단되면 그 이후 정규식 매칭이 진행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;문자열 바꾸기&lt;/h2&gt;

&lt;p&gt;sub 메서드를 이용하면 정규식과 매치되는 부분을 다른 문자로 쉽게 바꿀 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = re.compile('(blue|white|red)')
&amp;gt;&amp;gt;&amp;gt; p.sub('colour', 'blue socks and red shoes')
'colour socks and colour shoes'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;sub 메서드의 첫 번째 입력 인수는 “바꿀 문자열(replacement)”이 되고, 두 번째 입력 인수는 “대상 문자열”이 된다. 위 예에서 볼 수 있듯이 blue 또는 white 또는 red라는 문자열이 colour라는 문자열로 바뀌는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sub------&quot;&gt;sub 메서드 사용 시 참조 구문 사용하기&lt;/h4&gt;

&lt;p&gt;sub 메서드를 사용할 때 참조 구문을 사용할 수 있다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = re.compile(r&quot;(?P&amp;lt;name&amp;gt;\w+)\s+(?P&amp;lt;phone&amp;gt;(\d+)[-]\d+[-]\d+)&quot;)
&amp;gt;&amp;gt;&amp;gt; print(p.sub(&quot;\g&amp;lt;phone&amp;gt; \g&amp;lt;name&amp;gt;&quot;, &quot;park 010-1234-1234&quot;))
010-1234-1234 park
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 예는 &lt;code class=&quot;highlighter-rouge&quot;&gt;이름 + 전화번호&lt;/code&gt;의 문자열을 &lt;code class=&quot;highlighter-rouge&quot;&gt;전화번호 + 이름&lt;/code&gt;으로 바꾸는 예이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt;의 바꿀 문자열 부분에 &lt;code class=&quot;highlighter-rouge&quot;&gt;\g&amp;lt;그룹명&amp;gt;&lt;/code&gt;을 이용하면 정규식의 그룹명을 참조할 수 있게된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sub-----&quot;&gt;sub 메서드의 입력 인수로 함수 넣기&lt;/h4&gt;

&lt;p&gt;sub 메서드의 첫 번째 입력 인수로 함수를 넣을 수도 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def hexrepl(match):
...     &quot;Return the hex string for a decimal number&quot;
...     value = int(match.group())
...     return hex(value)
...
&amp;gt;&amp;gt;&amp;gt; p = re.compile(r'\d+')
&amp;gt;&amp;gt;&amp;gt; p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')
'Call 0xffd2 for printing, 0xc000 for user code.'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump6.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump6.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Jump to Python - 파이썬 프로그래밍, 어떻게 시작해야할까?</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;내가 프로그램을 만들 수 있을까?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;“문법도 어느 정도 알겠고, 책 내용도 대부분 이해된다. 하지만 이러한 지식을 바탕으로 내가 도대체 어떤 프로그램을 만들 수 있을까?”&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이럴 때는 “어떤 프로그램을 짜야지”라는 생각보다는 다른 사람들이 만든 프로그램 파일을 자세히 들여다보고 분석하는 데서 시작하는 것이 좋다!!!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;프로그램을 만들려면 가장 먼저 &quot;입력&quot;과 &quot;출력&quot;을 생각하라.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;연습!&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;함수 이름은? GuGu로 짓자&lt;/li&gt;
  &lt;li&gt;입력받는 값은? 2&lt;/li&gt;
  &lt;li&gt;출력하는 값은? 2단(2, 4, 6, 8, …, 18)&lt;/li&gt;
  &lt;li&gt;결과는 어떤 형태로 저장하지? 연속된 자료형이니까 리스트!&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;에디터를 열고 다음과 같이 입력한다. GuGu라는 함수에 2를 입력값으로 주면 result라는 변수에 결과값을 넣으라는 뜻이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result = GuGu(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;이제 결과값을 어떤 형태로 받을 것인지 고민해 보자. 2단이니까 2, 4, 6, … 18까지 갈 것이다. 이런 종류의 데이터는 리스트 자료형이 딱이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자, 일단 이름을 GuGu로 지은 함수를 다음과 같이 만들어 보자.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def GuGu(n):
    print(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위와 같은 함수를 만들고 GuGu(2)처럼 실행하면 2를 출력하게 된다. 즉, 입력값으로 2가 잘 들어오는지 확인하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;이제 결과값을 담을 리스트를 하나 생성하자. 앞에서 작성한 print(n)은 입력이 잘 되는지를 확인하기 위한 것이었으므로 지워도 좋다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def GuGu(n):
    result = []
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;다음으로 result에 2, 4, 6,… 18을 어떻게 넣어야 할지 생각해 보자. 필자는 다음과 같이 리스트에 요소를 추가하는 append 내장 함수를 사용하기로 결정했다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def GuGu(n):
    result = []
    result.append(n*1)
    result.append(n*2)
    result.append(n*3)
    result.append(n*4)
    result.append(n*5)
    result.append(n*6)
    result.append(n*7)
    result.append(n*8)
    result.append(n*9)
    return result

print(GuGu(2))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;결과값: [2, 4, 6, 8, 10, 12, 14, 16, 18]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;정말 무식한 방법이지만 입력값 2를 주었을 때 원하는 결과값을 얻을 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;그런데 위의 함수는 반복이 너무 많다. 가만히 보면 result.append(n*□)의 □위치에 1부터 9까지 숫자만 다르게 들어가 있다는 것을 알 수 있다. 똑같은 일을 반복할 때는 “반복문”을 사용한다고 했다. 그렇다면 1부터 9까지 출력해 주는 반복문을 만들면 되지 않을까?&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; i = 1
&amp;gt;&amp;gt;&amp;gt; while i &amp;lt; 10:
...     print(i)
...     i = i + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값:
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이상의 생각들을 바탕으로 완성한 GuGu 함수는 다음과 같다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def GuGu(n):
    result = []
    i = 1
    while i &amp;lt; 10:
        result.append(n * i)
        i = i + 1
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;test&quot;&gt;TEST&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(GuGu(2))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;결과값: [2, 4, 6, 8, 10, 12, 14, 16, 18]&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;결과는 대만족이다!!!&lt;/h1&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3과 5의 배수 합치기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10 미만의 자연수에서 3과 5의 배수를 구하면 3, 5, 6, 9이다. 이들의 총합은 23이다.
1000 미만의 자연수에서 3의 배수와 5의 배수의 총합을 구하라.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result = 0
for n in range(1, 1000):
    if n % 3 == 0 or n % 5 == 0: 
        result += n
print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이 문제에는 한가지 함정이 있는데 3으로도 5로도 나누어지는 15와 같은 수를 이중으로 더해서는 안 된다는 점이다. 따라서 15와 같이 3의 배수도 되고 5의 배수도 되는 값이 이중으로 더해지지 않기 위해 or 연산자를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;게시판 페이징하기&lt;/h2&gt;

&lt;p&gt;A 씨는 게시판 프로그램을 작성하고 있다. 그런데 게시물의 총 건수와 한 페이지에 보여줄 게시물 수를 입력으로 주었을 때 총 페이지수를 출력하는 프로그램이 필요하다고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A씨가 필요한 프로그램을 만들기 위해 입력값과 결과값이 어떻게 나와야 하는지 먼저 살펴봐야한다. 게시물의 총 건수가 5이고 한 페이지에서 보여 줄 게시물 수가 10이면 총 페이지수는 당연히 1이 된다. 만약 게시물의 총 건수가 15이고 한 페이지에서 보여 줄 게시물 수가 10이라면 총 페이지수는 2가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;다음과 같이 총 건수(m)를 한 페이지에 보여줄 게시물 수(n)로 나누고 1을 더하면 총 페이지수를 얻을 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;총 페이지수 = 총 건수 / 한 페이지당 보여줄 건수 + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이러한 공식을 적용했을 경우 총 페이지수가 표의 값처럼 구해지는지 확인해 보자(m을 n으로 나눌 때 소수점 아래 자리를 버리기 위해서 / 대신 // 연산자를 사용하였다).&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def getTotalPage(m, n):
    return m // n + 1

print(getTotalPage(5, 10))    # 1 출력
print(getTotalPage(15, 10))   # 2 출력
print(getTotalPage(25, 10))   # 3 출력
print(getTotalPage(30, 10))   # 4 출력
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;실패 케이스는 총 게시물 수와 한 페이지에 보여줄 게시물 수를 나눈 나머지 값이 0이 될 때 발생함을 유추할 수 있을 것이다. 이 실패 케이스를 해결하려면 다음과 같이 코드를 변경해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def getTotalPage(m, n):
    if m % n == 0:
        return m // n
    else:
        return m // n + 1

print(getTotalPage(5, 10))
print(getTotalPage(15, 10))
print(getTotalPage(25, 10))
print(getTotalPage(30, 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;간단한 메모장 만들기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# C:/Python/memo.py
import sys

option = sys.argv[1]
memo = sys.argv[2]

print(option)
print(memo)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;memo.py를 작성했다면 다음과 같은 명령을 수행해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Python&amp;gt;python memo.py -a &quot;Life is too short&quot;
-a
Life is too short
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이제 입력으로 받은 메모를 파일에 쓰도록 코드를 변경해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# c:/Python/memo.py
import sys

option = sys.argv[1]

if option == '-a':
    memo = sys.argv[2]
    f = open('memo.txt', 'a')
    f.write(memo)
    f.write('\n')
    f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이제 다음과 같은 명령을 수행해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Python&amp;gt;python memo.py -a &quot;Life is too short&quot;  
C:\Python&amp;gt;python memo.py -a &quot;You need python&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;그리고 파일에 정상적으로 메모가 기입되었는지 다음과 같이 확인해 보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Python&amp;gt;type memo.txt
Life is too short
You need python
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이번에는 작성한 메모를 출력하는 부분을 만들 차례이다. 메모 출력은 다음과 같이 동작하도록 만들어 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python memo.py -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이제 메모 출력을 위해서 다음과 같이 코드를 변경해 보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# c:/Python/memo.py
import sys

option = sys.argv[1]

if option == '-a':
    memo = sys.argv[2]
    f = open('memo.txt', 'a')
    f.write(memo)
    f.write('\n')
    f.close()
elif option == '-v':
    f = open('memo.txt')
    memo = f.read()
    f.close()
    print(memo)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;코드를 수정한 후 다음과 같은 명령을 수행해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Python&amp;gt;python memo.py -v
Life is too short
You need python
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-6&quot;&gt;탭을 4개의 공백으로 바꾸기&lt;/h2&gt;

&lt;p&gt;문서 파일을 읽어서 그 문서 파일 내에 있는 탭(tab)을 공백(space) 4개로 바꾸어주는 스크립트&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;우선 다음과 같이 tabto4.py 파일을 작성해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# c:/Python/tabto4.py
import sys

src = sys.argv[1]
dst = sys.argv[2]

print(src)
print(dst)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;다음과 같이 수행했을 때 입력값들이 정상적으로 출력되는지 확인해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Python&amp;gt;python tabto4.py a.txt b.txt
a.txt
b.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;입력으로 전달한 a.txt와 b.txt가 정상적으로 출력되는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;테스트를 위한 원본 파일(탭을 포함하는 파일)인 a.txt를 다음과 같이 작성한다. 각 단어들은 탭(\t) 문자로 분리되도록 입력해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Life    is  too short
You need    python
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이제 탭 문자를 포함한 a.txt 파일을 읽어서 탭을 공백 4개로 변환할 수 있도록 코드를 변경해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# c:/Python/tabto4.py
import sys

src = sys.argv[1]
dst = sys.argv[2]

f = open(src)
tab_content = f.read()
f.close()

space_content = tab_content.replace(&quot;\t&quot;, &quot; &quot;*4)
print(space_content)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;tabto4.py를 위와 같이 변경한 후 다음과 같은 명령을 수행해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Python&amp;gt;python tabto4.py a.txt b.txt
Life    is    too    short
You    need    python
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이제 변경된 내용을 b.txt 파일에 저장할 수 있도록 다음과 같이 프로그램을 변경해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# c:/Python/tabto4.py
import sys

src = sys.argv[1]
dst = sys.argv[2]

f = open(src)
tab_content = f.read()
f.close()

space_content = tab_content.replace(&quot;\t&quot;, &quot; &quot;*4)

f = open(dst, 'w')
f.write(space_content)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;프로그램을 실행하기 위해 다음과 같은 명령을 수행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Python&amp;gt;python tabto4.py a.txt b.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;하위 디렉토리 검색하기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;우선 다음과 같이 sub_dir_search.py 파일을 작성해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# C:/Python/sub_dir_search.py

def search(dirname):
    print (dirname)

search(&quot;c:/&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이제 이 디렉터리에 있는 파일들을 검색할 수 있도록 소스를 변경해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# C:/Python/sub_dir_search.py
import os

def search(dirname):
    filenames = os.listdir(dirname)
    for filename in filenames:
        full_filename = os.path.join(dirname, filename)
        print (full_filename)

search(&quot;c:/&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이제 C:/ 디렉터리에 있는 파일들 중 확장자가 .py인 파일들만을 출력하도록 코드를 변경해 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# C:/Python/sub_dir_search.py
import os

def search(dirname):
    filenames = os.listdir(dirname)
    for filename in filenames:
        full_filename = os.path.join(dirname, filename)
        ext = os.path.splitext(full_filename)[-1]
        if ext == '.py': 
            print(full_filename)

search(&quot;c:/&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;하지만 우리가 원하는 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;C:/&lt;/code&gt; 디렉터리 바로 밑에 있는 파일 뿐만 아니라 그 하위 디렉터리(sub directory)를 포함한 모든 파이썬 파일들을 검색하는 것이다. 하위 디렉터리도 검색이 가능하게 하기 위해서는 다음과 같이 코드를 변경해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# C:/Python/sub_dir_search.py
import os

def search(dirname):
    try:
        filenames = os.listdir(dirname)
        for filename in filenames:
            full_filename = os.path.join(dirname, filename)
            if os.path.isdir(full_filename):
                search(full_filename)
            else:
                ext = os.path.splitext(full_filename)[-1]
                if ext == '.py': 
                    print(full_filename)
    except PermissionError:
        pass

search(&quot;c:/&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;try … except PermissionError로 함수 전체를 감싼 이유는 os.listdir 수행 시 권한이 없는 디렉터리에 접근하더라도 프로그램이 오류로 종료되지 않고 그냥 수행되도록 하기 위해서이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump5.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump5.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Jump to Python - 파이썬 날개 달기</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;클래스&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;클래스는 도대체 왜 필요한가?&lt;/h3&gt;

&lt;p&gt;가장 많이 사용하는 프로그래밍 언어 중 하나인 C 언어에는 클래스가 없다. 이 말은 굳이 클래스 없이도 프로그램을 충분히 만들 수 있다는 말과도 같다. 파이썬으로 잘 만들어진 프로그램들을 살펴보아도 클래스를 이용하지 않고 작성된 것들이 상당히 많다. 클래스는 지금까지 공부한 함수나 자료형처럼 프로그램 작성을 위해 꼭 필요한 요소는 아니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;계산기를 사용해 봤을 것이다. 계산기에 3이라는 숫자를 입력하고 + 기호를 입력한 후 4를 입력하면 결과값으로 7을 보여준다. 다시 한 번 + 기호를 입력한 후 3을 입력하면 기존 결과값 7에 3을 더해 10을 보여준다. 즉, 계산기는 이전에 계산된 결과값을 항상 메모리 어딘가에 저장하고 있어야 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;다음은 계산기의 “더하기” 기능을 구현한 파이선 코드이다&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```
  result = 0&lt;/p&gt;

    &lt;p&gt;def adder(num):
      global result
      result += num
      return result&lt;/p&gt;

    &lt;p&gt;print(adder(3))
  print(adder(4))
  ```&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이전에 계산된 결과값을 유지하기 위해서 	result라는 전역 변수(global)를 사용했다. 실행하면 예상한 대로 다음과 같은 결과값이 출력된다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
  3
  7
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 만약 한 프로그램에서 2개의 계산기가 필요한 상황이 발생하면 어떻게 해야 할까? 각각의 계산기는 각각의 결과값을 유지해야 하기 때문에 위와 같이 adder 함수 하나만으로는결과값을 따로 유지할 수 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result1 = 0
result2 = 0

def adder1(num):
    global result1
    result1 += num
    return result1

def adder2(num):
    global result2
    result2 += num
    return result2

print(adder1(3))
print(adder1(4))
print(adder2(3))
print(adder2(7))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;똑같은 일을 하는 adder1과 adder2라는 함수가 만들어졌고 각각의 함수에서 계산된 결과값을 유지하면서 저장하기 위한 전역 변수 result1, result2가 필요하게 되었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;결과값은 다음과 같이 의도한 대로 출력된다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
  3
  7
  3
  10
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;클래스와 객체&lt;/h2&gt;

&lt;p&gt;과자를 만드는 과자틀과 만들어진 과자들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;과자틀 -&amp;gt; 클래스(class)&lt;/li&gt;
  &lt;li&gt;과자틀에 의해서 만들어진 과자들 -&amp;gt; 객체(object)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클래스는 과자틀과 비슷하다&lt;/p&gt;

&lt;p&gt;클래스(class)란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고(과자 틀), 객체(object)란 클래스에 의해서 만들어진 피조물(과자틀에 의해서 만들어진 과자)을 뜻한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클래스에 의해서 만들어진 객체에는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 과자틀에 의해서 만들어진 과자에 구멍을 뚫거나 조금 베어먹더라도 다른 과자들에는 아무 영향이 없는것과 마찬가지로 동일한 클래스에의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Cookie:
&amp;gt;&amp;gt;&amp;gt;  	pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 클래스는 아무런 기능도 갖고 있지 않은 껍질뿐인 클래스이다. 하지만 이렇게 껍질뿐인 클래스도 객체를 생성하는 기능은 가지고 있다. “과자 틀”로 “과자”를 만드는 것처럼 말이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;사칙연산 클래스 만들기&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;클래스를 어떻게 만들지 먼저 구상하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사칙연산을 가능하게 하는 FourCal이라는 클래스가 다음처럼 동작한다고 가정해 보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클래스는 무작정 만들기 보다는 클래스에 의해서 만들어진 객체를 중심으로 어떤 식으로 동작하게 할 것인지 미리 구상을 한 후에 생각했던 것들을 하나씩 해결하면서 완성해 나가는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;클래스 구조 만들기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FourCal:
...     pass
... 
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;현재 상태에서 FourCal 클래스는 아무런 변수나 메서드도 포함하지 않지만 우리가 원하는 객체 a를 만들 수 있는 기능은 가지고 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = FourCal()
&amp;gt;&amp;gt;&amp;gt; type(a)
&amp;lt;class '__main__.FourCal'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위와 같이 a = FourCal()로 a라는 객체를 먼저 만들고 그 다음에 type(a)로 a라는 객체가 어떤 타입인지 알아보았다. 역시 객체 a가 FourCal 클래스의 인스턴스임을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;객체에 숫자 지정할 수 있게 만들기&lt;/h3&gt;

&lt;p&gt;하지만 생성된 객체 a는 아직 아무런 기능도 하지 못한다. 이제 더하기, 나누기, 곱하기, 빼기등의 기능을 하는 객체를 만들어야 한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a.setdata(4, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;연산을 수행할 대상(4, 2)을 객체에 지정할 수 있게 만들어 보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이전에 만들었던 FourCal 클래스에서 pass라는 문장을 삭제하고 class 내부에 setdata라는 함수를 만들었다. 클래스 안에 구현된 함수는 다른말로 &lt;strong&gt;메서드(Method)&lt;/strong&gt;라고 부른다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;setdata 메서드를 다시 보면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def setdata(self, first, second):   # ① 메서드의 입력 인수
    self.first = first              # ② 메서드의 수행문
    self.second = second            # ② 메서드의 수행문
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;① setdata 메서드의 입력 인수&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setdata 메서드는 입력 인수로 self, first, second라는 3개의 입력값을 받는다. 그런데 일반적인 함수와는 달리 메서드의 첫 번째 입력 인수 self는 특별한 의미를 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = FourCal()
&amp;gt;&amp;gt;&amp;gt; a.setdata(4, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위에서 보는 것처럼 a라는 객체를 만든 다음에 a.setdata(4, 2)처럼 호출하면 FourCal 클래스의 setdata 메서드가 호출되고 setdata 메서드의 첫 번째 인수 self에는 자동으로 a라는 객체가 대입된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;② setdata 메서드의 수행문&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;setdata 메서드는 수행할 문장이 2개 있다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.first = first
self.second = second
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 수행문이 뜻하는 바는 무엇일까? 입력 인수로 받은 first는 4이고 second는 2라는 것은 앞에서 이미 알았다. 그렇다면 위의 문장은 다음과 같이 바뀔 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.first = 4
self.second = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;여기서 중요한 것은 바로 self이다. self는 a.setdata(4, 2)처럼 호출했을 때 자동으로 들어오는 객체 a라고 했다. 그렇다면 self.first의 의미는 무엇이겠는가? 당연히 a.first가 될 것이다. 또한 self.second는 당연히 a.second가 될 것이다.&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;따라서 위의 두 문장을 풀어서 쓰면 다음과 같이 된다.&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.first = 4
a.second = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위와 같이 바뀐 문장이 실행되어 결국 a객체에는 first와 second라는 객체변수가 생성된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체변수는 다음과 같이 만들어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;객체.객체변수 = 값
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;객체변수는 객체에 정의된 변수를 의미하며 객체간 서로 공유되지 않는 특징을 갖는다!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;더하기 기능 만들기&lt;/h3&gt;

&lt;p&gt;2개의 숫자값을 설정해 주었으니 2개의 숫자를 더하는 기능을 추가해 보자!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;더하기 기능을 갖춘 클래스를 만들어야 한다!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def sum(self):
...         result = self.first + self.second
...         return result
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;새롭게 추가된 것은 sum이라는 메서드이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def sum(self):
    result = self.first + self.second
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;sum 메서드의 입력 인수는 self이고 리턴값은 result이다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;리턴 값인 result를 계산하는 부분은 다음과 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
  result = self.first + self.second
 &lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a.sum()&lt;/code&gt; 과 같이 a 객체에 의해 sum 메서드가 수행되면 sum 메서드의 self에는 객체 a가 자동으로 입력되므로 위의 내용은 아래와 같이 해석된다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
  result = a.first + a.second
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;곱하기, 빼기, 나누기 기능 만들기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def sum(self):
...         result = self.first + self.second
...         return result
...     def mul(self):
...         result = self.first * self.second
...         return result
...     def sub(self):
...         result = self.first - self.second
...         return result
...     def div(self):
...         result = self.first / self.second
...         return result
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;mul, sub, div 모두 sum 메서드에서 배운 것과 동일한 방법이다!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = FourCal()
&amp;gt;&amp;gt;&amp;gt; b = FourCal()
&amp;gt;&amp;gt;&amp;gt; a.setdata(4, 2)
&amp;gt;&amp;gt;&amp;gt; b.setdata(3, 7)
&amp;gt;&amp;gt;&amp;gt; a.sum()
6
&amp;gt;&amp;gt;&amp;gt; a.mul()
8
&amp;gt;&amp;gt;&amp;gt; a.sub()
2
&amp;gt;&amp;gt;&amp;gt; a.div()
2
&amp;gt;&amp;gt;&amp;gt; b.sum()
10
&amp;gt;&amp;gt;&amp;gt; b.mul()
21
&amp;gt;&amp;gt;&amp;gt; b.sub()
-4
&amp;gt;&amp;gt;&amp;gt; b.div()
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;constructor&quot;&gt;생성자 (Constructor)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = FourCal()
&amp;gt;&amp;gt;&amp;gt; a.sum()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 6, in sum
AttributeError: 'FourCal' object has no attribute 'first'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FourCal 클래스의 인스턴스 a에 setdata메서드를 수행하지 않고 sum 메서드를 수행하면 “AttributeError: ‘FourCal’ object has no attribute ‘first’” 라는 오류가 발생하게 된다. setdata 메서드를 수행해야 객체 a의 객체변수 first와 second에 값이 할당되기 때문이다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이렇게 객체에 초기값을 설정해야 할 필요가 있을때는 setdata와 같은 메서드를 호출하여 초기값을 설정하기 보다는 생성자를 구현하는 것이 안전한 방법이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;생성자(Constructor)란 객체가 생성될 때 자동으로 호출되는 메서드를 의미한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;파이썬 메서드명으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;__init__&lt;/code&gt; 을 사용하면 이 메서드는 생성자가 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FourCal클래스에 생성자를 추가해 보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FourCal:
...     def __init__(self, first, second):
...         self.first = first
...         self.second = second
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def sum(self):
...         result = self.first + self.second
...         return result
...     def mul(self):
...         result = self.first * self.second
...         return result
...     def sub(self):
...         result = self.first - self.second
...         return result
...     def div(self):
...         result = self.first / self.second
...         return result
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__init__&lt;/code&gt; 메서드는 setdata메서드와 이름만 틀리고 모든게 동일하다. 단, 메서드 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;__init__&lt;/code&gt;으로 했기 때문에 생성자로 인식되어 객체가 생성되는 시점에 자동으로 호출되는 차이가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;클래스의 상속&lt;/h2&gt;

&lt;p&gt;상속(Inheritance)이란 “물려받다”라는 뜻으로, “재산을 상속받다”라고 할 때의 상속과 같은 의미이다. 클래스에도 이런 개념을 적용할 수가 있다. 어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만드는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클래스를 상속하기 위해서는 다음처럼 클래스명 뒤 괄호 안에 상속할 클래스명을 넣어 주면 된다&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class 클래스명(상속할 클래스명)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-11&quot;&gt;메서드 오버라이딩&lt;/h4&gt;

&lt;p&gt;부모 클래스(상속한 클래스)에 있는 메서드를 동일한 이름으로 다시 만드는 것을 메서드 오버라이딩(Overriding, 덮어쓰기)이라고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메서드를 오버라이딩하면 부모 클래스의 메서드 대신 오버라이딩한 메서드가 호출된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-12&quot;&gt;모듈&lt;/h2&gt;

&lt;p&gt;모듈이란 함수나 변수 또는 클래스 들을 모아 놓은 파일이다. 모듈은 다른 파이썬 프로그램에서 불러와 사용할수 있게끔 만들어진 파이썬 파일이라고도 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;모듈 만들고 불러 보기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mod1.py
def sum(a, b):
    return a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위와 같이 sum 함수만 있는 파일 mod1.py를 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Python&lt;/code&gt; 디렉터리에 저장하면, 그 파일이 바로 모듈이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;import의 사용 방법은 다음과 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import 모듈이름
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-14&quot;&gt;클래스나 변수 등을 포함한 모듈&lt;/h2&gt;

&lt;p&gt;지금까지 살펴본 모듈은 함수만 포함했지만 클래스나 변수 등을 포함할 수도 있다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mod2.py 
PI = 3.141592

class Math: 
    def solv(self, r): 
        return PI * (r ** 2) 

def sum(a, b): 
    return a+b 

if __name__ == &quot;__main__&quot;: 
    print(PI)
    a = Math() 
    print(a.solv(2)) 
    print(sum(PI , 4.4))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이 파일은 원의 넓이를 계산하는 Math 클래스와 두 값을 더하는 sum 함수 그리고 원주율 값에 해당되는 PI 변수처럼 클래스, 함수, 변수 등을 모두 포함하고 있다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;대화형 인터프리터를 열고 다음과 같이 따라해보면,&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```
  C:\Python&amp;gt;python&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;blockquote&gt;
          &lt;p&gt;import mod2&lt;/p&gt;

          &lt;p&gt;```&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__name__ == &quot;__main__&quot;&lt;/code&gt;이 거짓이 되므로 아무런 값도 출력되지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;예외 처리&lt;/h2&gt;

&lt;p&gt;때때로 오류를 무시하고 싶을 때도 있고 별도로 처리하고 싶을 때도 있다. 이에 파이썬은 try, except를 이용해서 오류를 처리할 수 있게 해준다.&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;오류는 어떤 때 발생하는가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;디렉터리 안에 없는 파일을 열려고 시도했을 때 발생하는 오류이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; f = open(&quot;나없는파일&quot;, 'r')
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
FileNotFoundError: [Errno 2] No such file or directory: '나없는파일'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예에서 볼 수 있듯이 없는 파일을 열려고 시도하면 “FileNotFoundError”라는 이름의 오류가 발생하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 4 / 0
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
ZeroDivisionError: division by zero
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;4를 0으로 나누려니까 “ZeroDivisionError”라는 이름의 오류가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;오류 예외 처리 기법&lt;/h2&gt;

&lt;h4 id=&quot;try-except&quot;&gt;try, except문&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 오류 처리를 위한 try, except문의 기본 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try:
    ...
except [발생 오류[as 오류 메시지 변수]]:
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;try 블록 수행 중 오류가 발생하면 except 블록이 수행된다. 하지만 try블록에서 오류가 발생하지 않는다면 except 블록은 수행되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;try--else&quot;&gt;try .. else&lt;/h4&gt;

&lt;p&gt;try문은 else절을 지원한다. else절은 예외가 발생하지 않은 경우에 실행되며 반드시 except절 바로 다음에 위치해야 한다.&lt;/p&gt;

&lt;h4 id=&quot;try--finally&quot;&gt;try .. finally&lt;/h4&gt;

&lt;p&gt;try문에는 finally절을 사용할 수 있다. finally절은 try문 수행 도중 예외 발생 여부에 상관없이 항상 수행된다. 보통 finally절은 사용한 리소스를 close해야 할 경우에 많이 사용된다.&lt;/p&gt;

&lt;h4 id=&quot;section-18&quot;&gt;여러개의 오류처리하기&lt;/h4&gt;

&lt;p&gt;try문 내에서 여러개의 오류를 처리하기 위해서는 다음과 같은 구문을 이용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try:
    ...
except 발생 오류1:
   ... 
except 발생 오류2:
   ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-19&quot;&gt;오류 회피하기&lt;/h2&gt;

&lt;p&gt;프로그래밍을 하다 보면 특정 오류가 발생할 경우 그냥 통과시켜야 할 때가 있을 수 있다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try:
    f = open(&quot;나없는파일&quot;, 'r')
except FileNotFoundError:
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;try문 내에서 FileNotFoundError가 발생할 경우 pass를 사용하여 오류를 그냥 회피하도록 한 것이다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-20&quot;&gt;오류 일부러 발생시키기&lt;/h2&gt;

&lt;p&gt;이상하게 들리겠지만 프로그래밍을 하다 보면 종종 오류를 일부러 발생시켜야 할 경우도 생긴다. 파이썬은 raise라는 명령어를 이용해 오류를 강제로 발생시킬 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예를 들어 Bird라는 클래스를 상속받는 자식 클래스는 반드시 fly라는 함수를 구현하도록 만들고 싶은 경우(강제로 그렇게 하고 싶은 경우)가 있을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Bird:
    def fly(self):
        raise NotImplementedError
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 예제는 Bird 클래스를 상속받는 자식 클래스는 반드시 fly라는 함수를 구현해야 한다는 의지를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-21&quot;&gt;오류 만들기&lt;/h2&gt;

&lt;p&gt;프로그램 수행 도중 특수한 경우에만 예외처리를 하기 위해서 종종 오류를 만들어서 사용하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;section-22&quot;&gt;내장 함수&lt;/h2&gt;

&lt;p&gt;무엇인가 새로운 프로그램을 만들기 전에는 이미 만들어진 것들, 그중에서도 특히 파이썬 배포본에 함께 들어 있는 파이썬 라이브러리들을 살펴보는 것이 매우 중요하다.&lt;/p&gt;

&lt;h3 id=&quot;abs&quot;&gt;abs&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;abs(x)는 어떤 숫자를 입력으로 받았을 때, 그 숫자의 절대값을 돌려주는 함수이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; abs(3)
3
&amp;gt;&amp;gt;&amp;gt; abs(-3)
3
&amp;gt;&amp;gt;&amp;gt; abs(-1.2)
1.2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;all&quot;&gt;all&lt;/h3&gt;

&lt;p&gt;all(x)은 반복 가능한(iterable) 자료형 x를 입력 인수로 받으며, 이 x가 모두 참이면 True, 거짓이 하나라도 있 으면 False를 리턴한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; all([1, 2, 3])
True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;any&quot;&gt;any&lt;/h3&gt;

&lt;p&gt;any(x)는 x 중 하나라도 참이 있을 경우 True를 리턴하고, x가 모두 거짓일 경우에만 False를 리턴한다. all(x)의 반대 경우라고 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;chr&quot;&gt;chr&lt;/h3&gt;

&lt;p&gt;chr(i)는 아스키(ASCII) 코드값을 입력으로 받아 그 코드에 해당하는 문자를 출력하는 함수이다.&lt;/p&gt;

&lt;h3 id=&quot;dir&quot;&gt;dir&lt;/h3&gt;

&lt;p&gt;dir은 객체가 자체적으로 가지고 있는 변수나 함수를 보여 준다.&lt;/p&gt;

&lt;h3 id=&quot;divmod&quot;&gt;divmod&lt;/h3&gt;

&lt;p&gt;divmod(a, b)는 2개의 숫자를 입력으로 받는다. 그리고 a를 b로 나눈 몫과 나머지를 튜플 형태로 리턴하는 함수이다.&lt;/p&gt;

&lt;h3 id=&quot;enumerate&quot;&gt;enumerate&lt;/h3&gt;

&lt;p&gt;enumerate는 “열거하다”라는 뜻이다. 이 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 리턴한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for문처럼 반복되는 구간에서 객체가 현재 어느 위치에 있는지 알려주는 인덱스 값이 필요할때 enumerate 함수를 사용하면 매우 유용하다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;eval&quot;&gt;eval&lt;/h3&gt;

&lt;p&gt;eval(expression)은 실행 가능한 문자열(1+2, ‘hi’ + ‘a’ 같은 것)을 입력으로 받아 문자열을 실행한 결과값을 리턴하는 함수이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보통 eval은 입력받은 문자열로 파이썬 함수나 클래스를 동적으로 실행하고 싶은 경우에 사용된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter&lt;/h3&gt;

&lt;p&gt;filter란 무엇인가를 걸러낸다는 뜻으로, filter 함수도 동일한 의미를 가진다. filter 함수는 첫 번째 인수로 함수 이름을, 두 번째 인수로 그 함수에 차례로 들어갈 반복 가능한 자료형을 받는다. 그리고 두 번째 인수인 반복 가능한 자료형 요소들이 첫 번째 인수인 함수에 입력되었을 때 리턴값이 참인 것만 묶어서(걸러내서) 돌려준다.&lt;/p&gt;

&lt;h3 id=&quot;hex&quot;&gt;hex&lt;/h3&gt;

&lt;p&gt;hex(x)는 정수값을 입력받아 16진수(hexadecimal)로 변환하여 리턴하는 함수이다.&lt;/p&gt;

&lt;h3 id=&quot;id&quot;&gt;id&lt;/h3&gt;

&lt;p&gt;id(object)는 객체를 입력받아 객체의 고유 주소값(레퍼런스)을 리턴하는 함수이다.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;input&lt;/h3&gt;

&lt;p&gt;input([prompt])은 사용자 입력을 받는 함수이다. 입력 인수로 문자열을 주면 그 문자열은 프롬프트가 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = input()
hi
&amp;gt;&amp;gt;&amp;gt; a
'hi'
&amp;gt;&amp;gt;&amp;gt; b = input(&quot;Enter: &quot;)
Enter: hi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;int&quot;&gt;int&lt;/h3&gt;

&lt;p&gt;int(x)는 문자열 형태의 숫자나 소수점이 있는 숫자 등을 정수 형태로 리턴하는 함수로, 정수를 입력으로 받으면 그대로 리턴한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; int('3')
3
&amp;gt;&amp;gt;&amp;gt; int(3.4)
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;isinstance&quot;&gt;isinstance&lt;/h3&gt;

&lt;p&gt;isinstance(object, class)는 첫 번째 인수로 인스턴스, 두 번째 인수로 클래스 이름을 받는다. 입력으로 받은 인스턴스가 그 클래스의 인스턴스인지를 판단하여 참이면 True, 거짓이면 False를 리턴한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Person: pass
...
&amp;gt;&amp;gt;&amp;gt; a = Person()
&amp;gt;&amp;gt;&amp;gt; isinstance(a, Person)
True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lambda&quot;&gt;lambda&lt;/h3&gt;

&lt;p&gt;lambda는 함수를 생성할 때 사용하는 예약어로, def와 동일한 역할을 한다. 보통 함수를 한줄로 간결하게 만들 때 사용한다. 우리말로는 “람다”라고 읽고 def를 사용해야 할 정도로 복잡하지 않거나 def를 사용할 수 없는 곳에 주로 쓰인다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lambda 인수1, 인수2, ... : 인수를 이용한 표현식
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sum = lambda a, b: a+b
&amp;gt;&amp;gt;&amp;gt; sum(3,4)
7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;lambda를 이용한 sum 함수는 인수로 a, b를 받아 서로 더한 값을 돌려준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;len&quot;&gt;len&lt;/h3&gt;

&lt;p&gt;len(s)은 입력값 s의 길이(요소의 전체 개수)를 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; len(&quot;python&quot;)
6
&amp;gt;&amp;gt;&amp;gt; len([1,2,3])
3
&amp;gt;&amp;gt;&amp;gt; len((1, 'a'))
2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;list&quot;&gt;list&lt;/h3&gt;

&lt;p&gt;list(s)는 반복 가능한 자료형 s를 입력받아 리스트로 만들어 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(&quot;python&quot;)
['p', 'y', 't', 'h', 'o', 'n']
&amp;gt;&amp;gt;&amp;gt; list((1,2,3))
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;map&quot;&gt;map&lt;/h3&gt;

&lt;p&gt;map(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다. map은 입력받은 자료형의 각 요소가 함수 f에 의해 수행된 결과를 묶어서 리턴하는 함수이다.&lt;/p&gt;

&lt;h3 id=&quot;max&quot;&gt;max&lt;/h3&gt;

&lt;p&gt;max(iterable)는 인수로 반복 가능한 자료형을 입력받아 그 최대값을 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; max([1, 2, 3])
3
&amp;gt;&amp;gt;&amp;gt; max(&quot;python&quot;)
'y'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;min&quot;&gt;min&lt;/h3&gt;

&lt;p&gt;min(iterable)은 max 함수와 반대로, 인수로 반복 가능한 자료형을 입력받아 그 최소값을 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; min([1, 2, 3])
1
&amp;gt;&amp;gt;&amp;gt; min(&quot;python&quot;)
'h'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;oct&quot;&gt;oct&lt;/h3&gt;

&lt;p&gt;oct(x)는 정수 형태의 숫자를 8진수 문자열로 바꾸어 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; oct(34)
'0o42'
&amp;gt;&amp;gt;&amp;gt; oct(12345)
'0o30071'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;open&quot;&gt;open&lt;/h3&gt;

&lt;p&gt;open(filename, [mode])은 “파일 이름”과 “읽기 방법”을 입력받아 파일 객체를 리턴하는 함수이다. 읽기 방법(mode)이 생략되면 기본값인 읽기 전용 모드(r)로 파일 객체를 만들어 리턴한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;mode&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;쓰기 모드로 파일 열기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;읽기 모드로 파일 열기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;추가 모드로 파일 열기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;바이너리 모드로 파일 열기&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;ord&quot;&gt;ord&lt;/h3&gt;

&lt;p&gt;ord(c)는 문자의 아스키 코드값을 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ord('a')
97
&amp;gt;&amp;gt;&amp;gt; ord('0')
48
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;pow&quot;&gt;pow&lt;/h3&gt;

&lt;p&gt;pow(x, y)는 x의 y 제곱한 결과값을 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; pow(2, 4)
16
&amp;gt;&amp;gt;&amp;gt; pow(3, 3)
27
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;range&quot;&gt;range&lt;/h3&gt;

&lt;p&gt;range([start,] stop [,step])는 for문과 함께 자주 사용되는 함수이다. 이 함수는 입력받은 숫자에 해당되는 범위의 값을 반복 가능한 객체로 만들어 리턴한다.&lt;/p&gt;

&lt;h4 id=&quot;section-23&quot;&gt;인수가 하나일 경우&lt;/h4&gt;

&lt;p&gt;시작 숫자를 지정해 주지 않으면 range 함수는 0부터 시작한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(range(5))
[0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-24&quot;&gt;인수가 2개일 경우&lt;/h4&gt;

&lt;p&gt;입력으로 주어지는 2개의 인수는 시작 숫자와 끝 숫자를 나타낸다. 단, 끝 숫자는 해당 범위에 포함되지 않는다는 것에 주의해야 한다!!!!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(range(5, 10))
[5, 6, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-25&quot;&gt;인수가 3개일 경우&lt;/h4&gt;

&lt;p&gt;세 번째 인수는 숫자 사이의 거리를 말한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(range(1, 10, 2))
[1, 3, 5, 7, 9]
&amp;gt;&amp;gt;&amp;gt; list(range(0, -10, -1))
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sorted&quot;&gt;sorted&lt;/h3&gt;

&lt;p&gt;sorted(iterable) 함수는 입력값을 정렬한 후 그 결과를 리스트로 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sorted([3, 1, 2])
[1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; sorted(['a', 'c', 'b'])
['a', 'b', 'c']
&amp;gt;&amp;gt;&amp;gt; sorted(&quot;zero&quot;)
['e', 'o', 'r', 'z']
&amp;gt;&amp;gt;&amp;gt; sorted((3, 2, 1))
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;리스트 자료형에도 sort라는 함수가 있다. 하지만 리스트 자료형의 sort 함수는 리스트 객체 그 자체를 정렬만 할 뿐 정렬된 결과를 리턴하지는 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;str&quot;&gt;str&lt;/h3&gt;

&lt;p&gt;str(object)은 문자열 형태로 객체를 변환하여 리턴하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; str(3)
'3'
&amp;gt;&amp;gt;&amp;gt; str('hi')
'hi'
&amp;gt;&amp;gt;&amp;gt; str('hi'.upper())
'HI'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tuple&quot;&gt;tuple&lt;/h3&gt;

&lt;p&gt;tuple(iterable)은 반복 가능한 자료형을 입력받아 튜플 형태로 바꾸어 리턴하는 함수이다. 만약 튜플이 입력으로 들어오면 그대로 리턴한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; tuple(&quot;abc&quot;)
('a', 'b', 'c')
&amp;gt;&amp;gt;&amp;gt; tuple([1, 2, 3])
(1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; tuple((1, 2, 3))
(1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;type&quot;&gt;type&lt;/h3&gt;

&lt;p&gt;type(object)은 입력값의 자료형이 무엇인지 알려주는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; type(&quot;abc&quot;)
&amp;lt;class 'str'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type([ ])
&amp;lt;class 'list'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(open(&quot;test&quot;, 'w'))
&amp;lt;class '_io.TextIOWrapper'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;zip&quot;&gt;zip&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zip(iterable*)&lt;/code&gt;은 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(zip([1, 2, 3], [4, 5, 6]))
[(1, 4), (2, 5), (3, 6)]
&amp;gt;&amp;gt;&amp;gt; list(zip([1, 2, 3], [4, 5, 6], [7, 8, 9]))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
&amp;gt;&amp;gt;&amp;gt; list(zip(&quot;abc&quot;, &quot;def&quot;))
[('a', 'd'), ('b', 'e'), ('c', 'f')]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-26&quot;&gt;외장 함수&lt;/h2&gt;

&lt;h3 id=&quot;sys&quot;&gt;sys&lt;/h3&gt;

&lt;p&gt;sys 모듈은 파이썬 인터프리터가 제공하는 변수들과 함수들을 직접 제어할 수 있게 해주는 모듈이다.&lt;/p&gt;

&lt;h4 id=&quot;sysargv&quot;&gt;명령 행에서 인수 전달하기 - sys.argv&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:/User/home&amp;gt;python test.py abc pey guido
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;도스 창에서 위의 예처럼 test.py 뒤에 또 다른 값들을 함께 넣어 주면 sys.argv라는 리스트에그 값들이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sysexit&quot;&gt;강제로 스크립트 종료하기 - sys.exit&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sys.exit()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;syspath&quot;&gt;자신이 만든 모듈 불러와 사용하기 - sys.path&lt;/h4&gt;

&lt;h3 id=&quot;pickle&quot;&gt;pickle&lt;/h3&gt;

&lt;p&gt;pickle은 객체의 형태를 그대로 유지하면서 파일에 저장하고 불러올 수 있게 하는 모듈이다&lt;/p&gt;

&lt;h2 id=&quot;os-&quot;&gt;OS 모듈&lt;/h2&gt;

&lt;p&gt;OS 모듈은 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈이다.&lt;/p&gt;

&lt;h4 id=&quot;osenviron&quot;&gt;내 시스템의 환경 변수값을 알고 싶을 때 - os.environ&lt;/h4&gt;

&lt;p&gt;시스템은 제각기 다른 환경 변수값을 가지고 있는데, os.environ은 현재 시스템의 환경 변수 값들을 보여 준다&lt;/p&gt;

&lt;h4 id=&quot;oschdir&quot;&gt;디렉터리 위치 변경하기 - os.chdir&lt;/h4&gt;

&lt;h4 id=&quot;osgetcwd&quot;&gt;디렉터리 위치 리턴받기 - os.getcwd&lt;/h4&gt;

&lt;h4 id=&quot;ossystem&quot;&gt;시스템 명령어 호출하기 - os.system&lt;/h4&gt;

&lt;h4 id=&quot;ospopen&quot;&gt;실행한 시스템 명령어의 결과값 리턴받기 - os.popen&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;os.popen은 시스템 명령어를 실행시킨 결과값을 읽기 모드 형태의 파일 객체로 리턴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; f = os.popen(&quot;dir&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;shutilcopysrc-dst&quot;&gt;파일 복사하기 - shutil.copy(src, dst)&lt;/h4&gt;

&lt;h3 id=&quot;glob&quot;&gt;glob&lt;/h3&gt;

&lt;p&gt;가끔 파일을 읽고 쓰는 기능이 있는 프로그램을 만들다 보면 특정 디렉터리에 있는 파일 이름 모두를 알아야 할 때가 있다. 이럴 때 사용하는 모듈이 바로 glob이다.&lt;/p&gt;

&lt;h4 id=&quot;globpathname&quot;&gt;디렉터리에 있는 파일들을 리스트로 만들기 - glob(pathname)&lt;/h4&gt;

&lt;p&gt;glob 모듈은 디렉터리 내의 파일들을 읽어서 리턴한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; 등의 메타 문자를 써서 원하는 파일만 읽어 들일 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;tempfile&quot;&gt;tempfile&lt;/h3&gt;

&lt;p&gt;파일을 임시로 만들어서 사용할 때 유용한 모듈이 바로 tempfile이다. tempfile.mktemp()는 중복되지 않는 임시 파일의 이름을 무작위로 만들어서 리턴한다.&lt;/p&gt;

&lt;h3 id=&quot;time&quot;&gt;time&lt;/h3&gt;

&lt;h4 id=&quot;timetime&quot;&gt;time.time&lt;/h4&gt;

&lt;p&gt;time.time()은 UTC(Universal Time Coordinated 협정 세계 표준시)를 이용하여 현재 시간을 실수 형태로 리턴하는 함수이다. 1970년 1월 1일 0시 0분 0초를 기준으로 지난 시간을 초 단위로 리턴한다.&lt;/p&gt;

&lt;h4 id=&quot;timelocaltime&quot;&gt;time.localtime&lt;/h4&gt;

&lt;p&gt;time.localtime은 time.time()에 의해서 반환된 실수값을 이용해서 연도, 월, 일, 시, 분, 초,.. 의 형태로 바꾸어 주는 함수이다.&lt;/p&gt;

&lt;h4 id=&quot;timeasctime&quot;&gt;time.asctime&lt;/h4&gt;

&lt;p&gt;time.localtime에 의해서 반환된 튜플 형태의 값을 인수로 받아서 날짜와 시간을 알아보기 쉬운 형태로 리턴하는 함수이다.&lt;/p&gt;

&lt;h4 id=&quot;timectime&quot;&gt;time.ctime&lt;/h4&gt;

&lt;p&gt;time.asctime(time.localtime(time.time()))은 time.ctime()을 이용해 간편하게 표시할 수 있다&lt;/p&gt;

&lt;h4 id=&quot;timestrftime&quot;&gt;time.strftime&lt;/h4&gt;

&lt;p&gt;strftime 함수는 시간에 관계된 것을 세밀하게 표현할 수 있는 여러 가지 포맷 코드를 제공한다.&lt;/p&gt;

&lt;h4 id=&quot;timesleep&quot;&gt;time.sleep&lt;/h4&gt;

&lt;p&gt;time.sleep 함수는 주로 루프 안에서 많이 사용된다. 이 함수를 사용하면 일정한 시간 간격을 두고 루프를 실행할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;calendar&quot;&gt;calendar&lt;/h3&gt;

&lt;p&gt;calendar는 파이썬에서 달력을 볼 수 있게 해주는 모듈이다.&lt;/p&gt;

&lt;h3 id=&quot;random&quot;&gt;random&lt;/h3&gt;

&lt;p&gt;random은 난수(규칙이 없는 임의의 수)를 발생시키는 모듈이다&lt;/p&gt;

&lt;h3 id=&quot;webbrowser&quot;&gt;webbrowser&lt;/h3&gt;

&lt;p&gt;webbrowser는 자신의 시스템에서 사용하는 기본 웹 브라우저가 자동으로 실행되게 하는 모듈이다.&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump4.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump4.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Jump to Python - 프로그램의 입력과 출력</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;함수&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;함수를 사용하는 이유는 무엇일까?&lt;/h2&gt;

&lt;p&gt;프로그래밍을 하다 보면 똑같은 내용을 반복해서 작성하고 있는 자신을 발견할 때가 종종 있다. 이때가 바로 함수가 필요한 때이다. 즉, 반복되는 부분이 있을 경우 “반복적으로 사용되는 가치 있는 부분”을 한 뭉치로 묶어서 “어떤 입력값을 주었을 때 어떤 결과값을 돌려준다”라는식의 함수로 작성해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;파이썬 함수의 구조&lt;/h2&gt;

&lt;p&gt;파이썬 함수의 구조는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def 함수명(입력 인수):
	&amp;lt;수행할 문장1&amp;gt;
	&amp;lt;수행할 문장2&amp;gt;
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;def는 함수를 만들 때 사용하는 예약어이며, 함수명은 함수를 만드는 사람이 임의로 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def sum(a, b):
... 	return a+b
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 함수는 이렇게 해석할 수 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이 함수의 이름(함수명)은 sum이고 입력 인수로 2개의 값을 받으며 결과값은 2개의 입력값을 더한 값이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;입력값과 결과값에 따른 함수의 형태&lt;/h2&gt;

&lt;p&gt;함수는 들어온 입력값을 받아 어떤 처리를 하여 적절한 결과값을 돌려준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;입력값–&amp;gt;함수–&amp;gt;리턴값&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;일반적인 함수&lt;/h4&gt;

&lt;p&gt;입력값이 있고 결과값이 있는 함수가 일반적인 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def 함수이름(입력인수):
	&amp;lt;수행할 문장&amp;gt;
	...
	return 결과값
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;입력값이 없는 함수&lt;/h4&gt;

&lt;p&gt;입력값이 없는 함수가 존재할까? 당연히 존재한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def say():
... 	return 'Hi'
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;say라는 이름의 함수를 만들었다. 그런데 입력 인수 부분을 나타내는 함수명 뒤의 괄호 안이 비어있다. 이 함수는 어떻게 사용하는걸까?&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = say()
&amp;gt;&amp;gt;&amp;gt; print(a)
Hi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 함수를 쓰기 ㄹ위해서는 say()처럼 괄호 안에 아무런 값도 넣지 않아야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;결과값이 없는 함수&lt;/h4&gt;

&lt;p&gt;결과값이 없는 함수 역시 존재한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def sum(a, b):
... 	print(&quot;%d, %d의 합은 %d입니다.&quot; % (a, b, a+b))
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;결과값이 없는 함수는 호출해도 돌려주는 값이 없기 때문에 다음과 같이 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sum(3, 4)
3, 4의 합은 7입니다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예제에서 결과값은 당연히 없다. 결과값은 오직 return 명령어로만 돌려받을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = sum(3, 4)
&amp;gt;&amp;gt;&amp;gt; print(a)
None
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;a의 값은 None이다. None이란 거짓을 나타내는 자료형이라고 언급한 적이 있다. sum 함수처럼 결과값이 없을 때 a = sum(3, 4)처럼 쓰게 되면 함수 sum은 리턴값으로 a 변수에 None을 돌려준다. 이것을 가지고 결과값이 있다고 생각하면 안된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;입력값도 결과값도 없는 함수&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def say():
... 	print('Hi')
...
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;입력 인수를 받는 곳도 없고 return문도 없으니 입력값도 결과값도 없는 함수이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수를 사용하는 방법은 단 한가지이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; say()
Hi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;즉, 입력값도 결과값도 없는 함수는 다음과 같이 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;함수명()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;입력값이 몇 개가 될지 모를 때는 어떻게 해야 할까?&lt;/h4&gt;

&lt;p&gt;입력값이 여러 개일 때 그 입력값들을 모두 더해 주는 함수를 생각해보자. 하지만 몇개가 입력될지 모를 때는 어떻게해야할까? 파이썬은 이런 문제를 해결하기 위해 다음과 같은 방법을 제공한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def 함수이름(*입력변수):
	&amp;lt;수행할 문장&amp;gt;
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-9&quot;&gt;여러 개의 입력값을 받는 함수 만들기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;sum_many(1, 2)이면 3을, sum_many(1,2,3)이면 6을, sum_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)이면 55를 돌려주는 함수를 만들어 보자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def sum_many(*args): 
...     sum = 0 
...     for i in args: 
...         sum = sum + i 
...     return sum 
... 
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위에서 만든 sum_many라는 함수는 입력값이 몇 개든 상관이 없다. &lt;code class=&quot;highlighter-rouge&quot;&gt;*args&lt;/code&gt;처럼 입력 변수명 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;을 붙이면 입력값들을 전부 모아서 튜플로 만들어 주기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 sum_many(1, 2, 3)처럼 이 함수를 쓰면 args는 (1, 2, 3)이 되고, sum_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)처럼 쓰면 args는 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)이 된다. 여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;*args&lt;/code&gt;라는 것은 임의로정한 변수명이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;*pey&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;*python&lt;/code&gt;처럼 아무 이름이나 써도 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실제로 이 함수를 직접 입력해보자&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result = sum_many(1,2,3)
&amp;gt;&amp;gt;&amp;gt; print(result)
6
&amp;gt;&amp;gt;&amp;gt; result = sum_many(1,2,3,4,5,6,7,8,9,10)
&amp;gt;&amp;gt;&amp;gt; print(result)
55
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;sum_many(1,2,3)으로 함수를 호출하면 6을 리턴하고, sum_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)을 대입하면 55를 리턴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;함수의 결과값은 언제나 하나이다&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def sum_and_mul(a, b):
... 	return a+b, a*b
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_and_mul&lt;/code&gt; 함수는 2개의 입력 인수를 받아 더한 값과 곱한 값을 돌려주는 함수이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수를 다음과 같이 호출하면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result = sum_and_mul(3,4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;결과값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;a+b&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;a*b&lt;/code&gt; 2개인데 결과값을 받아들이는 변수는 result 하나만 쓰였으니 오류가 발생하지 않을까? 당연한 의문이다. 하지만 오류는 발생하지 않는다. 그 이유는 함수의 결과값은 2개가 아니라 언제나 1개라는 데 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 result 변수는 다음과 같은 값을 갖게 된다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result = (7, 12)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;즉, 결과값으로 (7, 12)라는 튜플 값을 갖게 되는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 이 하나의 튜플값을 2개의 결과값처럼 받고 싶다면 다음과 같이 함수를 호출하면 된다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sum, mul = sum_and_mul(3, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이렇게 호출하면 sum, mul=(7,12)가 되어 sum은 7이 되고 mul은 12가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;입력 인수에 초깃값 미리 설정하기&lt;/h2&gt;

&lt;p&gt;다음은 인수에 초깃값을 미리 설정해 주는 경우이다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def say_myself(name, old, man=True): 
    print(&quot;나의 이름은 %s 입니다.&quot; % name) 
    print(&quot;나이는 %d살입니다.&quot; % old) 
    if man: 
        print(&quot;남자입니다.&quot;)
    else: 
        print(&quot;여자입니다.&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 함수를 보면 입력 인수가 name, old, man=True 이렇게 3개다. 그런데 낯선 것이 나왔다. man=True처럼 입력 인수에 미리 값을 넣어 준 것이다. 이것이 바로 함수의 인수 초깃값을 설정하는 방법이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-12&quot;&gt;함수 입력 인수에 초깃값을 설정할 때 주의할 사항&lt;/h2&gt;

&lt;p&gt;만약 위에서 본 say_myself 함수를 다음과 같이 만들면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def say_myself(name, man=True, old): 
    print(&quot;나의 이름은 %s 입니다.&quot; % name) 
    print(&quot;나이는 %d살입니다.&quot; % old) 
    if man: 
        print(&quot;남자입니다.&quot;) 
    else: 
        print(&quot;여자입니다.&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이전 함수와 바뀐 부분은 초깃값을 설정한 인수의 위치이다. 결론적으로는 이것은 함수를 실핼할 때 오류가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;함수 안에서 선언된 변수의 효력 범위&lt;/h2&gt;

&lt;p&gt;함수 안에서 사용할 변수의 이름을 함수 밖에서도 동일하게 사용한다면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vartest.py
a = 1
def vartest(a):
    a = a +1

vartest(a)
print(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;당연히 vartest 함수에서 변수 a의 값에 1을 더했으니까 2가 출력되어야 할 것 같지만 프로그램 소스를 작성해서 실행시켜 보면 결과값은 1이 나온다. 그 이유는 함수 안에서 새로 만들어진 변수는 함수 안에서만 사용되는 “함수만의 변수”이기 때문이다. 즉, def vartest(a)에서 입력 인수를 뜻하는 변수 a는 함수 안에서만 사용되는 변수이지 함수 밖의 변수 a가 아니라는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-14&quot;&gt;함수 안에서 함수 밖의 변수를 변경하는 방법&lt;/h2&gt;

&lt;h4 id=&quot;return-&quot;&gt;1. return 이용하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vartest_return.py
a = 1 
def vartest(a): 
    a = a +1 
    return a

a = vartest(a) 
print(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;vartest 함수는 입력으로 들어온 값에 1을 더한값을 돌려준다. 따라서 a = vartest(a)라고 대입하면 a가 vartest 함수의 결과값으로 바뀐다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;global--&quot;&gt;2. global 명령어 사용하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vartest_global.py
a = 1 
def vartest(): 
    global a 
    a = a+1

vartest() 
print(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;두 번째 방법은 global이라는 명령어를 이용하는 방법이다. 위의 예에서 볼 수 있듯이 vartest 함수 안의 global a라는 문장은 함수 안에서 함수 밖의 a 변수를 직접 사용하겠다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;사용자 입력과 출력&lt;/h2&gt;

&lt;p&gt;우리들이 사용하는 대부분의 완성된 프로그램은 사용자의 입력에 따라 그에 맞는 출력을 내보낸다. 대표적인 예로, 게시판에 글을 작성한 후 “확인”버튼을 눌러야만(입력) 우리가 작성한 글이 게시판에 올라가는(출력)것을 들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사용자 입력 » 처리(프로그램, 함수 등) » 출력&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-16&quot;&gt;사용자 입력&lt;/h2&gt;

&lt;h4 id=&quot;input-&quot;&gt;input의 사용&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = input()
Life if too short, you need python
&amp;gt;&amp;gt;&amp;gt; a
'Life is too short, you need python'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;input은 입력되는 모든 것을 문자열로 취급한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-17&quot;&gt;프롬프트를 띄워서 사용자 입력 받기&lt;/h3&gt;

&lt;p&gt;사용자에게 입력을 받을 때 “숫자를 입력하세요”라든지 “이름을 입력하세요”라는 안내 문구 또는 질문이 나오도록 하고 싶을 때가 있다. 그럴 때는 input()의 괄호 안에 질문을 입력하여 프롬프트를 띄워주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;input(&quot;질문 내용&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;print--&quot;&gt;print 자세히 알기&lt;/h2&gt;

&lt;h4 id=&quot;section-18&quot;&gt;큰따옴표(“)로 둘러싸인 문자열은 + 연산과 동일하다&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(&quot;life&quot; &quot;is&quot; &quot;too short&quot;) # ①
lifeistoo short
&amp;gt;&amp;gt;&amp;gt; print(&quot;life&quot;+&quot;is&quot;+&quot;too short&quot;) # ②
lifeistoo short
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예에서 1 과 2 는 완전히 동일한 결과값을 출력한다. 즉, 따옴표로 둘러싸인 문자열을연속해서 쓰면 + 연산을 한 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-19&quot;&gt;문자열 띄어쓰기는 콤마로 한다&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(&quot;life&quot;, &quot;is&quot;, &quot;too short&quot;)
life is too short
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-20&quot;&gt;한 줄에 결과값 출력하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for i in range(10):
...     print(i, end=' ')
...
0 1 2 3 4 5 6 7 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한 줄에 결과값을 계속 이어서 출력하려면 입력 인수 end를 이용해 끝 문자를 지정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-21&quot;&gt;파일 읽고 쓰기&lt;/h2&gt;

&lt;h3 id=&quot;section-22&quot;&gt;파일 생성하기&lt;/h3&gt;

&lt;p&gt;다음 소스 코드를 에디터로 작성해서 저장한 후 실행해 보자. 프로그램을 실행한 디렉터리에 새로운 파일이 하나 생성된 것을 확인할 수 있을 것이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f = open(&quot;새파일.txt&quot;, 'w')
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파일을 생성하기 위해 우리는 open이라는 파이썬 내장 함수를 사용했다. open 함수는 다음과 같이 “파일 이름”과 “파일 열기 모드”를 입력값으로 받고 결과값으로 파일 객체를 돌려준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;파일 객체 = open(파일 이름, 파일 열기 모드)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;파일열기모드&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;읽기모드 - 파일을 읽기만 할 때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;쓰기모드 - 파일에 내용을 쓸 때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;추가모드 - 파일의 마지막에 새로운 내용을 추가 시킬 때 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;파일을 쓰기 모드로 열게 되면 해당 파일이 이미 존재할 경우 원래 있던 내용이 모두 사라지고, 해당 파일이 존재하지 않으면 새로운 파일이 생성된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-23&quot;&gt;파일을 쓰기 모드로 열어 출력값 적기&lt;/h2&gt;

&lt;p&gt;이번에는 에디터를 열고 프로그램의 출력값을 파일에 직접 써 보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# writedata.py
f = open(&quot;C:/Python/새파일.txt&quot;, 'w')
for i in range(1, 11):
    data = &quot;%d번째 줄입니다.\n&quot; % i
    f.write(data)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 프로그램을 다음 프로그램과 비교해 보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i in range(1, 11):
    data = &quot;%d번째 줄입니다.\n&quot; % i
    print(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;두 프로그램의 다른 점은 data를 출력하는 방법이다. 두 번째 방법은 우리가 계속 사용해 왔던 모니터 화면에 출력하는 방법이고, 첫 번째 방법은 모니터 화면 대신 파일에 결과값을 적는 방법이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-24&quot;&gt;프로그램의 외부에 저장된 파일을 읽는 여러가지 방법&lt;/h2&gt;

&lt;h3 id=&quot;readline-&quot;&gt;readline()함수 이용하기&lt;/h3&gt;

&lt;p&gt;첫 번째 방법은 readline() 함수를 이용하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# readline.py
f = open(&quot;C:/Python/새파일.txt&quot;, 'r')
line = f.readline()
print(line)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 예는 f.open(“새파일.txt”, ‘r’)로 파일을 읽기 모드로 연 후 readline()을 이용해서 파일의 첫 번째 줄을 읽어 출력하는 경우이다. 이전에 만들었던 새파일.txt를 수정하거나 지우지 않았다면 위 프로그램을 실행시켰을 때 새파일.txt의 가장 첫 번째 줄이 화면에 출력될 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1번째 줄입니다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;readlines--&quot;&gt;readlines() 함수 이용하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f = open(&quot;C:/Python/새파일.txt&quot;, 'r')
lines = f.readlines()
for line in lines:
    print(line)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;read--&quot;&gt;read() 함수 이용하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f = open(&quot;C:/Python/새파일.txt&quot;, 'r')
data = f.read()
print(data)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;f.read()는 파일의 내용 전체를 문자열로 리턴한다. 따라서 위 예의 data는 파일의 전체 내용이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-25&quot;&gt;파일에 새로운 내용 추가하기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# adddata.py
f = open(&quot;C:/Python/새파일.txt&quot;,'a')
for i in range(11, 20):
    data = &quot;%d번째 줄입니다.\n&quot; % i
    f.write(data)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위 예는 새파일.txt라는 파일을 추가 모드(‘a’)로 열고 write를 이용해서 결과값을 기존 파일에 추가해 적는 예이다. 여기서 추가 모드로 파일을 열었기 때문에 새파일.txt라는 파일이 원래 가지고 있던 내용 바로 다음부터 결과값을 적기 시작한다.&lt;/p&gt;

&lt;h2 id=&quot;with--&quot;&gt;with문과 함께 사용하기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f = open(&quot;foo.txt&quot;, 'w')
f.write(&quot;Life is too short, you need python&quot;)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파일을 열면 위와 같이 항상 close해 주는 것이 좋다. 하지만 이렇게 파일을 열고 닫는 것을 자동으로 처리할 수 있다면 편리하지 않을까?&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with open(&quot;foo.txt&quot;, &quot;w&quot;) as f:
    f.write(&quot;Life is too short, you need python&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬의 with문이 바로 이런 역할을 해준다. 위의 예는 with문을 이용해서 위 예제를 다시 작성한 모습이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump3.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump3.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Jump to Python - 프로그램의 구조를 쌓는다(제어문)</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;프로그램의 구조를 쌓는 제어문&lt;/h2&gt;

&lt;p&gt;제어문에는 if, while, for등의 제어문이 있다!&lt;/p&gt;

&lt;h2 id=&quot;if-&quot;&gt;if 문&lt;/h2&gt;

&lt;p&gt;프로그래밍에서 조건을 판단하여 해당 조건에 맞는 상황을 수행하는 데 쓰이는 것이 바로 if문이다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; money = 1
&amp;gt;&amp;gt;&amp;gt; if money:
... 	print(&quot;택시를 타고 가라&quot;)
... else:
... 	print(&quot;걸어 가라&quot;)
...
택시를 타고 가라
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;money에 입력된 1은 참이다. 따라서 if문 다음의 문장이 수행되어 ‘택시를 타고 가라’가 출력 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;if---&quot;&gt;if 문의 기본 구조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 if와 else를 이용한 조건문의 기본 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if 조건문:
	수행할 문장1
	수행할 문장2
	...
else:
	수행할 문장A
	수행할 문장B
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;조건문을 테스트해서 참이면 if문 바로 다음의 문장(if 블록)들을 수행하고, 조건문이 거짓이면 else문 다음의 문장(else 블록)들을 수행하게 된다. 그러므로 else문은 if문 없이 독립적으로 사용할 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;들여쓰기&lt;/h3&gt;

&lt;p&gt;if문을 만들 때는 if조건문: 바로 아래 문장부터 if문에 속하는 모든 문장에 들여쓰기를 해주어야 한다. 다음과 같이 조건문이 참일 경우 “수행할 문장1”을 들여쓰기 했고, “수행할 문장2”와 “수행할 문장3”도 들여쓰기를 해주었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if 조건문:
	수행할 문장1
	수행할 문장2
	수행할 문장3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다음과 같이 작성하면 오류가 발생한다. “수행할 문장2”를 들여쓰기 하지 않았기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if 조건문:
	수행할 문장1
수행할 문장2
	수행할 문장3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;조건문이란 무엇인가?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;if 조건문&lt;/strong&gt;에서 “조건문”이란 참과 거짓을 판단하는 문장을 말한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;자료형&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;참&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;거짓&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;숫자&lt;/td&gt;
      &lt;td&gt;0이 아닌 숫자&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;문자열&lt;/td&gt;
      &lt;td&gt;“abc”&lt;/td&gt;
      &lt;td&gt;””&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;리스트&lt;/td&gt;
      &lt;td&gt;[1,2,3]&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;튜플&lt;/td&gt;
      &lt;td&gt;(1,2,3)&lt;/td&gt;
      &lt;td&gt;()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;딕셔너리&lt;/td&gt;
      &lt;td&gt;{“a”:”b”}&lt;/td&gt;
      &lt;td&gt;{}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-3&quot;&gt;비교 연산자&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;비교 연산자&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;x&amp;lt;y&lt;/td&gt;
      &lt;td&gt;x가 y보다 작다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x&amp;gt;y&lt;/td&gt;
      &lt;td&gt;x가 y보다 크다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x==y&lt;/td&gt;
      &lt;td&gt;x와 y가 같다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x != y&lt;/td&gt;
      &lt;td&gt;x와 y가 같지 않다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x &amp;gt;= y&lt;/td&gt;
      &lt;td&gt;x가 y보다 크거나 같다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x &amp;lt;= y&lt;/td&gt;
      &lt;td&gt;x가 y보다 작거나 같다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;and-or-not&quot;&gt;and, or, not&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;조건을 판단하기 위해 사용하는 다른 연산자로는 and, or, not가 있다. 각각의 연산자는 다음처럼 동작한다&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;연산자&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;x or y&lt;/td&gt;
      &lt;td&gt;x와 y 둘중에 하나만 참이면 참이다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x and y&lt;/td&gt;
      &lt;td&gt;x와 y모두 참이어야 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;not x&lt;/td&gt;
      &lt;td&gt;x가 거짓이면 참이다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; money = 2000
&amp;gt;&amp;gt;&amp;gt; card = 1
&amp;gt;&amp;gt;&amp;gt; if money &amp;gt;= 3000 or card:
... 	print(&quot;택시를 타고 가라&quot;)
... else:
... 	print(&quot;걸어가라&quot;)
...
택시를 타고 가라
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;money는 2000이지만 card가 1이기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;money &amp;gt;= 3000 or card&lt;/code&gt;이라는 조건문이 참이 된다. 따라서 if문 다음의 “택시를 타고 가라” 문장이 수행된다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;x-in-s-x-not-in-s&quot;&gt;x in s, x not in s&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;not in&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;x in 리스트&lt;/td&gt;
      &lt;td&gt;x not in 리스트&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x in 튜플&lt;/td&gt;
      &lt;td&gt;x not in 튜플&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x in 문자열&lt;/td&gt;
      &lt;td&gt;x not in 문자열&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; pocket = ['paper', 'cellphone', 'money']
&amp;gt;&amp;gt;&amp;gt; if 'money' in pocket:
...     print(&quot;택시를 타고 가라&quot;)
... else:
...     print(&quot;걸어가라&quot;)
...
택시를 타고 가라
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;[‘paper’, ‘cellphone’, ‘money’]라는 리스트 안에 ‘money’가 있으므로 ‘money’ in pocket은 참이 된다. 따라서 if문 다음의 문장이 수행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;elif&quot;&gt;다양한 조건을 판단하는 elif&lt;/h2&gt;

&lt;p&gt;-if와 else만으로는 다양한 조건을 판단하기 어렵다. 다음과 같은 예를 보더라도 if와 else만으로는 조건을 판단하는 데 어려움을 겪게 된다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“주머니에 돈이 있으면 택시를 타고, 주머니에 돈은 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어 가라”&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 주머니에 돈이 있는지를 판단해야 하고 주머니에 돈이 없으면 다시 카드가 있는지 판단해야 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;if와 else만으로 위의 문장을 표현하려면 다음과 같이 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;blockquote&gt;
          &lt;p&gt;pocket = [‘paper’, ‘handphone’]
card = 1
if ‘money’ in pocket:
  …     print(“택시를 타고가라”)
  … else:
  …     if card:
  …         print(“택시를 타고가라”)
  …     else:
  …         print(“걸어가라”)
  …
  택시를 타고가라&lt;/p&gt;

          &lt;p&gt;```&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;위의 예제는 산만한 느낌이지만 elif를 사용하면 다음과 같이 수정가능하다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;blockquote&gt;
          &lt;p&gt;pocket = [‘paper’, ‘cellphone’]
card = 1
if ‘money’ in pocket:
  …      print(“택시를 타고가라”)
  … elif card: 
  …      print(“택시를 타고가라”)
  … else:
  …      print(“걸어가라”)
  …
  택시를 타고가라
  ```&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;while&quot;&gt;while문&lt;/h2&gt;

&lt;h3 id=&quot;while--&quot;&gt;while문의 기본 구조&lt;/h3&gt;

&lt;p&gt;반복해서 문장을 수행해야 할 경우 while문을 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 while문의 기본구조이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while &amp;lt;조건문&amp;gt;:
    &amp;lt;수행할 문장1&amp;gt;
    &amp;lt;수행할 문장2&amp;gt;
    &amp;lt;수행할 문장3&amp;gt;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;while문은 조건문이 참인 동안에 while문 아래에 속하는 문장들이 반복해서 수행된다!&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;“열 번 찍어 안 넘어 가는 나무 없다”라는 속담을 파이썬 프로그램으로 만든다면 다음과 같이 될 것이다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;blockquote&gt;
          &lt;p&gt;treeHit = 0
while treeHit &amp;lt; 10:
  …     treeHit = treeHit +1
  …     print(“나무를 %d번 찍었습니다.” % treeHit)
  …     if treeHit == 10:
  …         print(“나무 넘어갑니다.”)
  …
  나무를 1번 찍었습니다.
  나무를 2번 찍었습니다.
  나무를 3번 찍었습니다.
  나무를 4번 찍었습니다.
  나무를 5번 찍었습니다.
  나무를 6번 찍었습니다.
  나무를 7번 찍었습니다.
  나무를 8번 찍었습니다.
  나무를 9번 찍었습니다.
  나무를 10번 찍었습니다.
  나무 넘어갑니다.
  ```&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;while---1&quot;&gt;while문 직접 만들기&lt;/h2&gt;

&lt;p&gt;다음은 여러가지 선택지 중 하나를 선택해서 입력받는 예제이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; prompt = &quot;&quot;&quot;
... 1. Add
... 2. Del
... 3. List
... 4. Quit
...
... Enter number: &quot;&quot;&quot;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이어서 number라는 변수에 0을 먼저 대입한다. 이렇게 변수를 먼저 설정해 놓지 않으면 다음에 나올 while문의 조건문인 number != 4에서 변수가 존재하지 않는다는 에러가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number = 0
&amp;gt;&amp;gt;&amp;gt; while number != 4:
...     print(prompt)
...     number = int(input())
...

1. Add
2. Del
3. List
4. Quit

Enter number:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;while문을 보면 number가 4가 아닌 동안 prompt를 출력하고 사용자로부터 번호를 입력받는다. 다음의 결과 화면처럼 사용자가 4라는 값을 입력하지 않으면 계속해서 prompt를 출력한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;(※ 여기서 number = int(input())는 사용자의 숫자 입력을 받아들이는 것이라고만 알아두자)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```
  Enter number:
  1&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Add&lt;/li&gt;
      &lt;li&gt;Del&lt;/li&gt;
      &lt;li&gt;List&lt;/li&gt;
      &lt;li&gt;Quit
  ```&lt;/li&gt;
    &lt;/ol&gt;

    &lt;ul&gt;
      &lt;li&gt;4를 입력하면 조건문이 거짓이 되어 while문을 빠져나가게 된다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```
  Enter number:
  4&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;blockquote&gt;

          &lt;p&gt;```&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;while---2&quot;&gt;while문 강제로 빠져나가기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;while문은 조건문이 참인 동안 계속해서 while문 안의 내용을 반복적으로 수행한다. 하지만 강제로 while문을 빠져나가고 싶을 때가 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;예를 들어 커피 자판기를 생각해 봤을 때, 자판기 안에 커피가 충분히 있을 때에는 동전을 넣으면 커피가 나온다. 그런데 자판기가 제대로 작동하려면 커피가 얼마나 남았는지 항상 검사해야 한다! 만약 커피가 떨어졌다면 판매를 중단하고 “판매 중지”라는 문구를 사용자에게 보여주어야 한다. 이렇게 판매를 강제로 멈추게 하는 것이 바로 break문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; coffee = 10
&amp;gt;&amp;gt;&amp;gt; money = 300
&amp;gt;&amp;gt;&amp;gt; while money:
...     print(&quot;돈을 받았으니 커피를 줍니다.&quot;)
...     coffee = coffee -1
...     print(&quot;남은 커피의 양은 %d개입니다.&quot; % coffee)
...     if not coffee:
...         print(&quot;커피가 다 떨어졌습니다. 판매를 중지합니다.&quot;)
...         break
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;while문의 내용을 한 번 수행할 때마다 coffee = coffee - 1에 의해서 coffee의 개수가 1개씩 줄어든다. 만약 coffee가 0이 되면 if not coffee:라는 문장에서 not coffee가 참이 되므로 if문 다음의 문장인 “커피가 다 떨어졌습니다. 판매를 중지합니다.”가 수행되고 break문이 호출되어 while문을 빠져나가게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;조건에 맞지 않는 경우 맨 처음으로 돌아가기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;while문 안의 문장을 수행할 때 입력된 조건을 검사해서 조건에 맞지 않으면 while문을 빠져나간다. 그런데 프로그래밍을 하다 보면 while문을 빠져나가지 않고 while문의 맨 처음(조건문)으로 다시 돌아가게 만들고 싶은 경우가 생기게 된다. 이때 사용하는 것이 바로 continue문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 0
&amp;gt;&amp;gt;&amp;gt; while a &amp;lt; 10:
...     a = a+1
...     if a % 2 == 0: continue
...     print(a)
...
1
3
5
7
9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예는 1부터 10까지의 숫자 중 홀수만을 출력하는 예이다. a가 10보다 작은 동안 a는 1만큼씩 계속 증가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;무한 루프&lt;/h2&gt;

&lt;p&gt;무한 루프란 무한히 반복한다는 의미이다. 우리가 사용하는 일반적인 프로그램 중에서 무한 루프의 개념을 사용하지 않는 프로그램은 거의 없다. 그만큼 자주 사용된다는 뜻이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 무한 루프문의 기본적인 형태이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while True: 
    수행할 문장1 
    수행할 문장2
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;for&quot;&gt;for문&lt;/h2&gt;

&lt;h3 id=&quot;for--&quot;&gt;for문의 기본 구조&lt;/h3&gt;

&lt;p&gt;for문의 기본적인 구조는 다음과 같다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for 변수 in 리스트(또는 튜플, 문자열):
    수행할 문장1
    수행할 문장2
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;리스트나 튜플, 문자열의 첫 번째 요소부터 마지막 요소까지 차례로 변수에 대입되어 “수행할 문장1”, “수행할 문장2” 등이 수행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;전형적인 for문&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; test_list = ['one', 'two', 'three'] 
&amp;gt;&amp;gt;&amp;gt; for i in test_list: 
...     print(i)
... 
one 
two 
three
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;다양한 for문의 사용&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [(1,2), (3,4), (5,6)]
&amp;gt;&amp;gt;&amp;gt; for (first, last) in a:
...     print(first + last)
...
3
7
11
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예는 a 리스트의 요소값이 튜플이기 때문에 각각의 요소들이 자동으로 (first, last)라는 변수에 대입된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;for-continue&quot;&gt;for문과 continue&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;while문에서 살펴보았던 continue를 for문에서도 사용할 수 있다. 즉, for문 안의 문장을 수행하는 도중에 continue문을 만나면 for문의 처음으로 돌아가게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;for----range&quot;&gt;for와 함께 자주 사용하는 range함수&lt;/h2&gt;

&lt;p&gt;for문은 숫자 리스트를 자동으로 만들어 주는 range라는 함수와 함께 사용되는 경우가 많다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = range(10)
&amp;gt;&amp;gt;&amp;gt; a
range(0, 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;range(10)은 0부터 10 미만의 숫자를 포함하는 range 객체를 만들어 준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;for-range---&quot;&gt;for와 range를 이용한 구구단의 예&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for i in range(2,10): 
...     for j in range(1, 10): 
...         print(i*j, end=&quot; &quot;) 
...     print('') 
... 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;for-&quot;&gt;리스트 안에 for문 포함하기&lt;/h2&gt;

&lt;p&gt;리스트 안에 for문을 포함하는 리스트 내포(List comprehension)를 이용하면 좀 더 편리하고 직관적인 프로그램을 만들 수 있다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3,4]
&amp;gt;&amp;gt;&amp;gt; result = []
&amp;gt;&amp;gt;&amp;gt; for num in a:
...     result.append(num*3)
...
&amp;gt;&amp;gt;&amp;gt; print(result)
[3, 6, 9, 12]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 예제는 a라는 리스트의 각 항목에 3을 곱한 결과를 result라는 리스트에 담는 예제다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result = [num * 3 for num in a]
&amp;gt;&amp;gt;&amp;gt; print(result)
[3, 6, 9, 12]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;리스트 내포를 이용하면 위와 같이 간단히 해결할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump2.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump2.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Jump to Python - 파이썬 프로그래밍의 기초(자료형)</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;숫자형&lt;/h2&gt;

&lt;p&gt;숫자형(Number)이란 숫자 형태로 이루어진 자료형이다!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;사용 예&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;정수&lt;/td&gt;
      &lt;td&gt;123, -345, 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;실수&lt;/td&gt;
      &lt;td&gt;123.45, -1234.5, 3.4e10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8진수&lt;/td&gt;
      &lt;td&gt;0o34, 0o25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16진수&lt;/td&gt;
      &lt;td&gt;0x2A, 0xFF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-1&quot;&gt;숫자형은 어떻게 만들고 사용할까?&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;정수형&lt;/h4&gt;

&lt;p&gt;정수형(integer)란 말 그대로 정수를 뜻하는 자료형을 말한다. 다음은 양의 정수와 음의 정수, 숫자0을 변수 a에 대입하는 예이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 123
&amp;gt;&amp;gt;&amp;gt; a = -178
&amp;gt;&amp;gt;&amp;gt; a = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;실수형&lt;/h4&gt;

&lt;p&gt;파이썬에서 실수형(Floating-point)은 소수점이 포함된 숫자를 말한다. 다음 예는 실수를 변수 a에 대입하는 예이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 1.2
&amp;gt;&amp;gt;&amp;gt; a = -3.45
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 방식은 우리가 일반적으로 볼 수 있는 실수형의 소수점 표현 방식이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 4.24E10
&amp;gt;&amp;gt;&amp;gt; a = 4.24e-10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 방식은 “컴퓨터식 지수 표현 방식”으로 파이썬에서는 4.24e10 또는 4.24E10처럼 표현한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;8진수와 16진수&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;8진수(Octal)를 만들기 위해서는 숫자가 0o 또는 0O(숫자 0 + 알파벳 소문자 o또는 대문자 O)로 시작하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 0o177
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;16진수를 만들기 위해서는 0x로 시작하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 0x8ff
&amp;gt;&amp;gt;&amp;gt; b = 0xABC
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;숫자형을 활용하기 위한 연산자&lt;/h2&gt;

&lt;h4 id=&quot;section-6&quot;&gt;사칙연산&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 3
&amp;gt;&amp;gt;&amp;gt; b = 4
&amp;gt;&amp;gt;&amp;gt; a + b
7
&amp;gt;&amp;gt;&amp;gt; a * b
12
&amp;gt;&amp;gt;&amp;gt; a / b
0.75
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x-y--&quot;&gt;x의 y제곱을 나타내는 	&lt;code class=&quot;highlighter-rouge&quot;&gt;**&lt;/code&gt;연산자&lt;/h4&gt;

&lt;p&gt;이 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;x ** y&lt;/code&gt;처럼 사용되었을 때 x의 y제곱(xy)값을 리턴한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 3
&amp;gt;&amp;gt;&amp;gt; b = 4
&amp;gt;&amp;gt;&amp;gt; a ** b
81
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;나눗셈 후 나머지를 반환하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;연산자&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;는 나눗셈의 나머지 값을 반환하는 연산자이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 7 % 3
1
&amp;gt;&amp;gt;&amp;gt; 3 % 7
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;나눗셈 후 소수점 아랫자리는 버리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt;연산자&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt; 연산자를 이용할때의 주의할점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음처럼 음수에 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt;연산자를 적용하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; -7 / 4
&amp;gt;&amp;gt;&amp;gt; -1.75
&amp;gt;&amp;gt;&amp;gt; -7 // 4
&amp;gt;&amp;gt;&amp;gt; -2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt;연산자는 나눗셈의 결과에서 무조건 소수점을 버리는것이 아니라 나눗셈의 결과값보다 작은 정수 중, 가장 큰 정수를 리턴한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;문자열 자료형&lt;/h2&gt;

&lt;p&gt;문자열(String)이란 문자, 단어 등으로 구성된 문자들의 집합을 의미한다. 예를 들어 다음과 같은 것들이 문자열이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;Life is too short, You need Python&quot;
&quot;a&quot;
&quot;123&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-10&quot;&gt;문자열은 어떻게 만들고 사용할까?&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;큰따옴표로 양쪽 둘러싸기&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;Hello World&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;작은따옴표로 양쪽 둘러싸기&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'Python is fun'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;큰따옴표 3개를 연속으로 써서 양쪽 둘러싸기&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;&quot;Lifr is too short, You need python&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;작은따옴표 3개를 연속으로 써서 양쪽 둘러싸기&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'''Life is too short, You need python'''
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-11&quot;&gt;문자열 안에 짝은 따옴표나 큰따옴표를 포함시키고 싶을 때&lt;/h4&gt;

&lt;p&gt;1) 문자열에 작은따옴표(&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;)포함시키기&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Python's favorite food is perl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위와 같은 문자열을 food라는 변수에 저장하고 싶다고 가정하자. 문자열 중 Python’s에 작은따옴표(‘)가 포함되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이럴때는 다음과 같이 문자열을 큰따옴표(“)로 둘러싸야 한다. 큰따옴표 안에 들어 있는 작은 따옴표는 문자열을 나타내기 위한 기호로 인식되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; food = &quot;Python's favorite food is perl&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;프롬프트에 food를 입력해서 결과를 확인하면, 변수에 저장된 문자열이 그대로 출력된다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; food
&quot;Python's favorite food is perl&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다음과 같이 큰따옴표(“)가 아닌 작은따옴표(‘)로 문자열을 둘러싼 후 다시 실행해보면, ‘Python’이 문자열로 인식되어 오류가 발생한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; food = 'Python's favorite food is perl'
File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1
food = 'Python's favorite food is perl'
^
SyntaxError: invalid syntax
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2) 문자열에 큰따옴표(&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;)포함시키기&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;Python is very easy.&quot; he says.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위와 같이 큰따옴표가 포함된 문자열이라면 다음과 같이 작은 따옴표로 둘러싸면 된다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; say = '&quot;Python is very easy.&quot; he says.'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;작은따옴표안에 사용된 큰따옴표는 문자열을 만드는 기호로 인식되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3) &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;(백슬래시)를 이용해서 작은따옴표(&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;)와 큰따옴표(&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;)를 문자열에 포함시키기&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; food = 'Python\'s favorite food is perl'
&amp;gt;&amp;gt;&amp;gt; say = &quot;\Python is very easy.\&quot; he says.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;(백슬래시) 뒤의 작은따옴표나 큰따옴표는 문자열을 둘러싸는 기호의 의미가 아니라 문자(‘),(“)그 자체를 뜻하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-12&quot;&gt;여러 줄인 문자열을 변수에 대입하고 싶을 때&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Life is too short
You need python
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;1) 줄을 바꾸기 위한 이스케이프 코드 &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; 삽입하기&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; multiline = &quot;Life is too short\nYou need python&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2) 연속된 작은따옴표 3개(&lt;code class=&quot;highlighter-rouge&quot;&gt;'''&lt;/code&gt;)또는 큰따옴표 3개(&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&quot;&lt;/code&gt;)이용&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; multiline='''
... Life is too short
... You need python
... '''
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;print(multiline)을 입력해서 출력되는 값&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(multiline)
Life is too short
You need python
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;여러줄인 경우 이스케이프 코드를 쓰는 것보다 따옴표를 연속해서 쓰는 것이 훨씬 깔끔하다&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;문자열 연산하기&lt;/h2&gt;

&lt;h4 id=&quot;section-14&quot;&gt;1) 문자열 더해서 연결하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; head = &quot;Python&quot;
&amp;gt;&amp;gt;&amp;gt; tail = &quot; is fun!&quot;
&amp;gt;&amp;gt;&amp;gt; head + tail
'Python is fun!'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;head와 tail 변수가 +에 의해 합쳐지게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-15&quot;&gt;2) 문자열 곱하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;python&quot;
&amp;gt;&amp;gt;&amp;gt; a * 2
'pythonpython'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;는 문자열의 반복을 뜻하는 의미로 사용되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-16&quot;&gt;문자열 인덱싱과 슬라이싱&lt;/h2&gt;

&lt;p&gt;인덱싱(Indexing)이란 무엇인가를 “가리킨다”는 의미이고, 슬라이싱(Slicing)은 무엇인가를 “잘라낸다”는 의미이다.&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;문자열 인덱싱이란?&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short, You need Python&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드에서 변수 a에 저장한 문자열의 각 문자마다 번호를 매겨보면 다음과 같다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Life is too short, You need Python
0         1         2         3 
0123456789012345678901234567890123
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short, You need Python&quot;
&amp;gt;&amp;gt;&amp;gt; a[3]
'e'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;a[3]이 뜻하는 것은 a라는 문자열의 네 번째 문자인 e를 말한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;“파이썬은 0부터 숫자를 센다.”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;고로 위의 문자열을 파이썬은 다음과 같이 바라본다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a[0]:'L', a[1]:'i', a[2]:'f', a[3]:'e', a[4]:' ', ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a[번호]&lt;/code&gt;는 문자열 내 특정한 값을 뽑아내는 역할을 한다. 이러한 것을 인덱싱이라고 한다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-18&quot;&gt;문자열 인덱싱 활용하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short, You need Python&quot;
&amp;gt;&amp;gt;&amp;gt; a[0]
'L'
&amp;gt;&amp;gt;&amp;gt; a[12]
's'
&amp;gt;&amp;gt;&amp;gt; a[-1]
'n'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;뒤에서부터 첫 번째 문자를 표시할 때도 0부터 세어 “a[-0]이라고 해야 하지 않을까?”라는 의문이 들 수도 있지만 0 과 -0은 똑같은 것이기 때문에 a[-0]은 a[0]과 똑같은 값을 보여준다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[-0]
'L'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-19&quot;&gt;문자열 슬라이싱이란?&lt;/h3&gt;

&lt;p&gt;“Life is too short, You need Python”이라는 문자열에서 단순히 한 문자열만을 뽑아내는 것이 아니라 ‘Life’또는 ‘You’같은 단어들만 뽑아내려면 다음과 같이 하면된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short, You need Python&quot;
&amp;gt;&amp;gt;&amp;gt; b = a[0] + a[1] + a[2] + a[3]
&amp;gt;&amp;gt;&amp;gt; b
'Life'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;하지만 이것은 슬라이싱 기법으로 다음고 같이 더 간단하게 처리 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short, You need Python&quot;
&amp;gt;&amp;gt;&amp;gt; a[0:4]
'Life'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-20&quot;&gt;문자열을 슬라이싱하는 방법&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[0:5]
'Life'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예는 a[0] + a[1] + a[2] + a[3] + a[4]와 동일하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;슬라이싱할 때 항상 시작 번호가 ‘0’일 필요는 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[0:2]
'Li'
&amp;gt;&amp;gt;&amp;gt; a[5:7]
'is'
&amp;gt;&amp;gt;&amp;gt; a[12:17]
'short'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;a[시작 번호:끝 번호]에서 끝 번호 부분을 생략하면 시작번호부터 그 문자열의 끝까지 뽑아낸다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[19:]
'You need Python'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;a[시작 번호:끝 번호]에서 시작 번호와 끝 번호를 생략하면 문자열의 처음부터 끝까지를 뽑아낸다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[:]
'Life is too short, You need Python'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;슬라이싱에서도 인덱싱과 마찬가지로 마이너스(-) 기호를 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[19:-7]
'You need'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 소스 코드에서 a[19:-7]이 뜻하는 것은 a[19]에서부터 a[-8]까지를 말한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-21&quot;&gt;슬라이싱으로 문자열 나누기&lt;/h3&gt;

&lt;p&gt;다음은 자주 사용하게 되는 슬라이싱 기법 중 하나이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;20010331Rainy&quot;
&amp;gt;&amp;gt;&amp;gt; date = a[:8]
&amp;gt;&amp;gt;&amp;gt; weather = a[8:]
&amp;gt;&amp;gt;&amp;gt; date
'20010331'
&amp;gt;&amp;gt;&amp;gt; weather
'Rainy'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예에서는 “20010331Rainy”라는 문자열을 날짜를 나타내는 부분인 ‘20010331’과 날씨를 나타내는 부분인’Rainy’로 나누는 방법을 보여준다!!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-22&quot;&gt;문자열 포매팅&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;“현재 온도는 18도 입니다”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;“현재 온도는 20도 입니다”&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 두 문자열은 모두 같은데 20이라는 숫자와 18이라는 숫자만 다르다. 이렇게 문자열 내의 특정한 값을 바꿔야 할 경우가 있을 때 이것을 가능하게 해주는 것이 바로 문자열 포매팅 기법이다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-23&quot;&gt;문자열 포매팅 따라하기&lt;/h3&gt;

&lt;h4 id=&quot;section-24&quot;&gt;1) 숫자 바로 대입&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &quot;I eat %d apples.&quot; % 3
'I eat 3 apples.'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예제에서는 문자열 내에 3이라는 정수를 삽입하는 방법을 보여준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-25&quot;&gt;2) 문자열 바로 대입&lt;/h4&gt;

&lt;p&gt;문자열 내에 꼭 숫자만 넣으라는 법은 없다! 숫자 대신 문자열도 가능하다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'I eat %s apples.&quot; % &quot;five&quot;
'I eat five apples.'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;숫자를 넣기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;%d&lt;/code&gt;를 사용한다&lt;/li&gt;
  &lt;li&gt;문자열을 넣기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;를 사용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(문자열을 대입할 때는 큰따옴표나 작은 따옴표를 반드시 사용해야 한다)&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-26&quot;&gt;3) 숫자 값을 나타내는 변수로 대입&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number = 3 
&amp;gt;&amp;gt;&amp;gt; &quot;I eat %d apples.&quot; % number
'I eat 3 apples.'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;숫자를 바로 대입하나 숫자 값을 나타내는 변수를 대입하나 결과는 같다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-27&quot;&gt;문자열 포맷 코드&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;코드&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;%s&lt;/td&gt;
      &lt;td&gt;문자열(String)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%c&lt;/td&gt;
      &lt;td&gt;문자 1개(character)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%d&lt;/td&gt;
      &lt;td&gt;정수(Integer)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%f&lt;/td&gt;
      &lt;td&gt;부동소수(floating-point)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%o&lt;/td&gt;
      &lt;td&gt;8진수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%x&lt;/td&gt;
      &lt;td&gt;16진수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%%&lt;/td&gt;
      &lt;td&gt;Literal%(문자&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;자체)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-28&quot;&gt;포맷 코드와 숫자 함께 사용하기&lt;/h3&gt;

&lt;h4 id=&quot;section-29&quot;&gt;1) 정렬과 공백&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &quot;%10s&quot; % &quot;hi&quot;
'			hi'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;“%10s”의 의미는 전체 길이가 10개인 문자열 공간에서 hi를 오른쪽으로 정렬하고 그 앞의 나머지는 공백으로 남겨두라는 의미이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-30&quot;&gt;2) 소수점 표현하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &quot;%0.4f&quot; % 3.42134234
'3.4213'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;3.42134234를 소수점 네 번째 자리까지만 나타내고 싶은 경우에는 위와 같이 사용한다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-31&quot;&gt;문자열 관련 함수들&lt;/h2&gt;

&lt;p&gt;문자열 자료형은 자체적으로 가지고 있는 함수들이 있다. 이 함수들은 다른말로 문자열 내장함수라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;count&quot;&gt;문자 개수 세기(count)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;hobby&quot;
&amp;gt;&amp;gt;&amp;gt; a.count('b')
2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 중 b의 개수를 반환한다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;find&quot;&gt;위치 알려주기1(find)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Python is best choice&quot;
&amp;gt;&amp;gt;&amp;gt; a.find('b')
10
&amp;gt;&amp;gt;&amp;gt; a.find('k')
-1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 중 문자 b가 처음으로 나온 위치를 반환한다. 만약 찾는 문자나 문자열이 존재하지 않는다면 -1을 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(*파이썬은 숫자를 0부터 세기 때문에 b의 위치는 11이 아닌 10이 된다)&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;index&quot;&gt;위치 알려주기2(index)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short&quot;
&amp;gt;&amp;gt;&amp;gt; a.index('t')
8
&amp;gt;&amp;gt;&amp;gt; a.index('k')
Traceback (most recent call last):
File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
ValueError: substring not found
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 중 문자 t가 맨 처음으로 나온 위치를 반환한다. 만약 찾는 문자나 문자열이 존재하지 않는다면 오류를 발생시킨다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;join&quot;&gt;문자열 삽입(join)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;,&quot;
&amp;gt;&amp;gt;&amp;gt; a.join('abcd')
'a,b,c,d'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;abcd라는 문자열의 각각의 문자 사이에 변수 a의 값인’,’를 삽입한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;upper&quot;&gt;소문자를 대문자로 바꾸기(upper)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;hi&quot;
&amp;gt;&amp;gt;&amp;gt; a.upper()
'HI'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;upper()함수는 소문자를 대문자로 바꾸어 준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lower&quot;&gt;대문자를 소문자로 바꾸기(lower)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;HI&quot;
&amp;gt;&amp;gt;&amp;gt; a.lower()
'hi'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;lower() 함수는 대문자를 소문자로 바꾸어 준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lstrip&quot;&gt;왼쪽 공백 지우기(lstrip)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot; hi &quot;
&amp;gt;&amp;gt;&amp;gt; a.lstrip()
'hi '
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rstrip&quot;&gt;오른쪽 공백 지우기(rstrip)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot; hi &quot;
&amp;gt;&amp;gt;&amp;gt; a.rstrip()
' hi'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;strip&quot;&gt;양쪽 공백 지우기(strip)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot; hi &quot;
&amp;gt;&amp;gt;&amp;gt; a.strip()
'hi'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;replace&quot;&gt;문자열 바꾸기(replace)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short&quot;
&amp;gt;&amp;gt;&amp;gt; a.replace(&quot;Life&quot;, &quot;Your leg&quot;)
'Your leg is too short'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 내의 특정한 값을 다른 값으로 치환해준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;split&quot;&gt;문자열 나누기(split)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;Life is too short&quot;
&amp;gt;&amp;gt;&amp;gt; a.split()
['Life', 'is', 'too', 'short']
&amp;gt;&amp;gt;&amp;gt; a = &quot;a:b:c:d&quot;
&amp;gt;&amp;gt;&amp;gt; a.split(':')
['a', 'b', 'c', 'd']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-32&quot;&gt;리스트 자료형&lt;/h2&gt;

&lt;h3 id=&quot;section-33&quot;&gt;리스트는 어떻게 만들고 사용할까?&lt;/h3&gt;

&lt;p&gt;리스트를 만들 때에는 대괄호([])로 감싸 주고 각 요소값들은 쉼표(,)로 구분해 준다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; odd = [1, 3, 5, 7, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;여러가지 리스트의 형태&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [ ]
&amp;gt;&amp;gt;&amp;gt; b = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; c = ['Life', 'is', 'too', 'short']
&amp;gt;&amp;gt;&amp;gt; d = [1, 2, 'Life', 'is']
&amp;gt;&amp;gt;&amp;gt; e = [1, 2, ['Life', 'is']]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;리스트는 a처럼 아무것도 포함하지 않는, 비어있는 리스트([])일 수도 있고 b처럼 숫자를 요소값으로 가질 수도 있고 c처럼 문자열을 요소값으로 가질 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(*비어 있는 리스트는 a = list()로 생성할 수도 있다)&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-34&quot;&gt;리스트의 인덱싱과 슬라이싱&lt;/h2&gt;

&lt;p&gt;리스트도 문자열처럼 인덱싱과 슬라이싱이 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;section-35&quot;&gt;리스트의 인덱싱&lt;/h4&gt;

&lt;p&gt;리스트 역시 문자열처럼 인덱싱을 적용 할 수 있다. 먼저 a 변수에 [1,2,3]이라는 값을 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; a
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;a[0]은 리스트 a의 첫번째 요소값을 말한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[0]
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;아래의 예는 리스트의 첫번째 요소인 a[0]과 세번째 요소인 a[2]의 값을 더한것이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[0] + a[2]
4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이것은 1 + 3으로 해석되고 4라는 값을 출력한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-36&quot;&gt;리스트의 슬라이싱&lt;/h4&gt;

&lt;p&gt;문자열과 마찬가지로 리스트에서도 슬라이싱 기법을 적용할 수 있다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;슬라이싱은 “나눈다”라는 뜻이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; a[0:2]
[1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-37&quot;&gt;리스트 연산자&lt;/h2&gt;

&lt;p&gt;리스트 역시 + 기호를 이용해서 더할 수 있고, *기호를 이용해서 반복할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;section-38&quot;&gt;1) 리스트 더하기(+)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; b = [4, 5, 6]
&amp;gt;&amp;gt;&amp;gt; a + b
[1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-39&quot;&gt;2) 리스트 반복하기(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; a * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-40&quot;&gt;리스트의 수정, 변경과 삭제&lt;/h2&gt;

&lt;h3 id=&quot;section-41&quot;&gt;1. 리스트에서 하나의 값 수정하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; a[2] = 4
&amp;gt;&amp;gt;&amp;gt; a
[1, 2, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-42&quot;&gt;2. 리스트에서 연속된 범위의 값 수정하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[1:2]
[2]
&amp;gt;&amp;gt;&amp;gt; a[1:2] = ['a', 'b', 'c']
&amp;gt;&amp;gt;&amp;gt; a
[1, 'a', 'b', 'c', 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;a[1:2]를 [‘a’, ‘b’, ‘c’]로 바꾸었으므로 a리스트에서 2라는 값 대신에 [‘a’, ‘b’, ‘c’]라는 값이 대입된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;주의할점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 전제를 a[1:2]가 아니라 a[1] = [‘a’, ‘b’, ‘c’]로 한다면 a의 출력값은 [1, [‘a’, ‘b’, ‘c’], 4]가 된다!!&lt;/p&gt;

&lt;h3 id=&quot;section-43&quot;&gt;3. [ ]사용해 리스트 요소 삭제하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a[1:3] = []
&amp;gt;&amp;gt;&amp;gt; a
[1, 'c', 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;del-----&quot;&gt;4. del 함수 사용해 리스트 요소 삭제하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a 
[1, 'c', 4]
&amp;gt;&amp;gt;&amp;gt; del a[1]
&amp;gt;&amp;gt;&amp;gt; a
[1, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-44&quot;&gt;리스트 관련 함수들&lt;/h2&gt;

&lt;h3 id=&quot;append&quot;&gt;리스트에 요소 추가(append)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; a.append(4)
&amp;gt;&amp;gt;&amp;gt; a
[1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sort&quot;&gt;리스트 정렬(sort)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 4, 3, 2]
&amp;gt;&amp;gt;&amp;gt; a.sort()
&amp;gt;&amp;gt;&amp;gt; a
[1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reverse&quot;&gt;리스트 뒤집기(reverse)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = ['a', 'c', 'b']
&amp;gt;&amp;gt;&amp;gt; a.reverse()
&amp;gt;&amp;gt;&amp;gt; a
['b', 'c', 'a']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;index-1&quot;&gt;위치 반환(index)&lt;/h3&gt;

&lt;p&gt;index(x)함수는 리스트에 x라는 값이 있으면 x의 위치값을 리턴한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]
&amp;gt;&amp;gt;&amp;gt; a.index(3)
2
&amp;gt;&amp;gt;&amp;gt; a.index(1)
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;insert&quot;&gt;리스트에 요소 삽입(insert)&lt;/h3&gt;

&lt;p&gt;insert(a, b)는 리스트의 a번째 위치에 b를 삽입하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; a.insert(0, 4)
[4, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;remove&quot;&gt;리스트 요소 제거(remove)&lt;/h3&gt;

&lt;p&gt;remove(x)는 리스트에서 첫번째로 나오는 x를 삭제하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; a.remove(3)
[1, 2, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;pop&quot;&gt;리스트 요소 끄집어내기(pop)&lt;/h3&gt;

&lt;p&gt;pop()은 리스트의 맨 마지막 요소를 돌려주고 그 요소는 삭제하는 함수이다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]
&amp;gt;&amp;gt;&amp;gt; a.pop()
3
&amp;gt;&amp;gt;&amp;gt; a
[1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x--count&quot;&gt;리스트에 포함된 요소 x의 개수 세기(count)&lt;/h3&gt;

&lt;p&gt;count(x)는 리스트 내에 x가 몇개 있는지 조사하여 그 개수를 돌려준다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3,1]
&amp;gt;&amp;gt;&amp;gt; a.count(1)
2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;1이라는 값이 리스트 a에 2개 들어있으므로 2를 반환한다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;extend&quot;&gt;리스트 확장(extend)&lt;/h3&gt;

&lt;p&gt;extend(x)에서 x에는 리스트만 올 수 있으며 원래의 a 리스트에 x 리스트를 더하게 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]
&amp;gt;&amp;gt;&amp;gt; a.extend([4,5])
&amp;gt;&amp;gt;&amp;gt; a
[1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; b = [6, 7]
&amp;gt;&amp;gt;&amp;gt; a.extend(b)
&amp;gt;&amp;gt;&amp;gt; a
[1, 2, 3, 4, 5, 6, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-45&quot;&gt;튜플 자료형&lt;/h2&gt;

&lt;h3 id=&quot;section-46&quot;&gt;튜플은 어떻게 만들까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;리스트는 [과 ]으로 둘러싸지만 튜플은 (과 )으로 둘러싼다&lt;/li&gt;
  &lt;li&gt;리스트는 그 값의 생성, 삭제, 수정이 가능하지만 튜플은 그 값을 바꿀 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t1 = ()
&amp;gt;&amp;gt;&amp;gt; t2 = (1,)
&amp;gt;&amp;gt;&amp;gt; t3 = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; t4 = 1, 2, 3
&amp;gt;&amp;gt;&amp;gt; t5 = ('a', 'b', ('ab', 'cd'))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-47&quot;&gt;튜플의 요소값을 지우거나 변경하려고 하면 어떻게 될까?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;튜플의 값을 리스트값을 지우거나 변경하는 것처럼 하면 오류가 발생한다!!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-48&quot;&gt;튜플의 인덱싱과 슬라이싱, 더하기(+)와 곱하기(*)&lt;/h2&gt;

&lt;h3 id=&quot;section-49&quot;&gt;1. 인덱싱하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t1 = (1, 2, 'a', 'b')
&amp;gt;&amp;gt;&amp;gt; t1[0]
1
&amp;gt;&amp;gt;&amp;gt; t1[3]
'b'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열, 리스트와 마찬가지로 t1[0], t1[3]처럼 인덱싱이 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-50&quot;&gt;2. 슬라이싱하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t1 = (1, 2, 'a', 'b')
&amp;gt;&amp;gt;&amp;gt; t1[1:]
(2, 'a', 'b')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-51&quot;&gt;3. 튜플 더하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t2 = (3, 4)
&amp;gt;&amp;gt;&amp;gt; t1 + t2
(1, 2, 'a', 'b', 3, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-52&quot;&gt;4. 튜플 곱하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t2 * 3
(3, 4, 3, 4, 3, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-53&quot;&gt;딕셔너리 자료형&lt;/h2&gt;

&lt;p&gt;파이썬에서는 자료형을 딕셔너리 라고 하며, Key와 Value값으로 한쌍을 이루는 자료형이다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예컨대, Key가 “baseball”이라면 Value는 “야구”가 될 것이다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-54&quot;&gt;딕셔너리는 어떻게 만들까?&lt;/h2&gt;

&lt;p&gt;Key에는 변하지 않는 값을 사용하고, Value에는 변하는 값과 변하지 않는 값 모두 사용 가능하다!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;딕셔너리 dic의 정보&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;key&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;value&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;pey&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;phone&lt;/td&gt;
      &lt;td&gt;0118888888&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;birth&lt;/td&gt;
      &lt;td&gt;1111&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;다음의 예는 Key로 정수값 1, Value로 ‘hi’라는 문자열을 사용한 예이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = {1: 'hi'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다음의 예처럼 Value에 리스트를 넣을 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = {'a': [1,2,3]}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-55&quot;&gt;딕셔너리 쌍 추가, 삭제하기&lt;/h2&gt;

&lt;p&gt;추가되는 순서는 원칙이 없다!&lt;/p&gt;

&lt;p&gt;중요한 것은 “무엇이 추가되었는가”이다!&lt;/p&gt;

&lt;h4 id=&quot;section-56&quot;&gt;1. 딕셔너리 쌍 추가하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = {1: 'a'}
&amp;gt;&amp;gt;&amp;gt; a[2] = 'b'
&amp;gt;&amp;gt;&amp;gt; a
{2: 'b', 1: 'a'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;{1: ‘a’}라는 딕셔너리에 a[2] = ‘b’와 같이 입력하면 딕셔너리 a에 Key와 Value가 각각 2와 ‘b’인 2: ‘b’라는 딕셔너리 쌍이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-57&quot;&gt;2. 딕셔너리 요소 삭제하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; del a[1]
&amp;gt;&amp;gt;&amp;gt; a
{'name': 'pey', 3: [1, 2, 3], 2: 'b'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;del 함수를 사용해서 del a[key]처럼 입력하면 지정한 key에 해당하는 {key: value}쌍이 삭제된다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-58&quot;&gt;딕셔너리를 사용하는 방법&lt;/h2&gt;

&lt;p&gt;예를 들어, 4명의 사람이 있다고 가정하고 각자의 특기를 표현 할 수 있는 좋은 방법에 대해서 생각해봤을때 리스트나 문자열로는 표현하기가 상당히 까다롭지만 딕셔너리를 사용하면 표현하기가 쉽다!!&lt;/p&gt;

&lt;h3 id=&quot;key--value-&quot;&gt;딕셔너리에서 Key 사용해 Value 얻기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; grade = {'pey': 10, 'julliet': 99}
&amp;gt;&amp;gt;&amp;gt; grade['pey']
10
&amp;gt;&amp;gt;&amp;gt; grade['julliet']
99
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예에서, ‘pey’라는 Key의 Value를 얻기 위해 grade[‘pey’]를 사용한 것처럼 어떤 Key의 어떤 Value를 얻기 위해서는 “딕셔너리 변수[Key]”를 사용한다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-59&quot;&gt;딕셔너리를 만들 때 주의사항&lt;/h3&gt;

&lt;p&gt;딕셔너리에서 Key는 고유한 값이므로 중복되는 Key값을 설정해놓으면 하나를 제외한 나머지 것들이 모두 무시된다 ( 꼭 어떤것이 무시될지는 알수없다! )&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중복되는 Key를 사용하지 말아야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = {1: 'a', 1: 'b'}
&amp;gt;&amp;gt;&amp;gt; a
{1: 'b'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Key를 통해서 Value를 얻는 딕셔너리의 특징상, 동일한 Key가 존재한다면 어떤 Key에 해당하는 Value를 불러야 할 지 알 수 없기 때문이다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-60&quot;&gt;딕셔너리 관련 함수들&lt;/h2&gt;

&lt;h3 id=&quot;key--keys&quot;&gt;Key 리스트 만들기(keys)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = {'name': 'pey', 'phone': '0118384384', 'birth': '1111'}
&amp;gt;&amp;gt;&amp;gt; a.keys()
dict_keys(['name', 'phone', 'birth'])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;a.keys()는 딕셔너리 a의 Key만을 모아서 dict_keys라는 객체를 리턴한다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**dict_keys 객체는 리스트를 사용하는 것과는 차이가 없지만, 리스트 고유의 함수인 append, insert, pop, remove, sort등의 함수를 수행할 수는 없다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for k in a.keys():
... 	print(k)
...
phone
birth
name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;dict_keys 객체를 리스트로 변환하려면 다음과 같이 하면 된다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(a.keys())
['phone', 'birth', 'name']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;value--value&quot;&gt;Value 리스트 만들기(value)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a.values()
dict_values(['pey', '0102392392', '1111'])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;key를 얻는 것과 마찬가지 방법으로 Value만 얻고 싶다면 a.value()처럼 value함수를 사용하면 된다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;key-value--items&quot;&gt;Key, Value 쌍 얻기(items)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a.items()
dict_items([('name', 'pey'), ('phone', '01024242424'), ('birth', '1111')])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;item 함수는 key와 value의 쌍을 튜플로 묶은 값을 dict_items 객체로 돌려준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;key-value---clear&quot;&gt;Key: Value 쌍 모두 지우기(clear)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a.clear()
&amp;gt;&amp;gt;&amp;gt; a
{}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;clear() 함수는 딕셔너리 안의 모든 요소를 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;key-valueget&quot;&gt;Key로 Value얻기(get)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = {'name': 'pey', 'phone':'0102222222', 'birth': '1111'}
&amp;gt;&amp;gt;&amp;gt; a.get('name')
'pey'
&amp;gt;&amp;gt;&amp;gt; a.get('phone')
'01022222222'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;get(x) 함수는 x라는 key에 대응되는 value를 돌려준다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;key----in&quot;&gt;해당 Key가 딕셔너리 안에 있는지 조사하기(in)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = {'name':'pey', 'phone':'0102222222', 'birth':'1111'}
&amp;gt;&amp;gt;&amp;gt; 'name' in a
True
&amp;gt;&amp;gt;&amp;gt; 'email' in a
False
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;‘name’이라는 문자열은 a 딕셔너리의 key 중 하나이다. 따라서 ‘name’ in a를 호출하면 참(True)을 리턴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-61&quot;&gt;집합 자료형&lt;/h2&gt;

&lt;h3 id=&quot;section-62&quot;&gt;집합 자료형은 어떻게 만들까?&lt;/h3&gt;

&lt;p&gt;집합(set)은 파이썬 2.3부터 지원되기 시작한 자료형으로, 집합에 관련된 것들을 쉽게 처리하기 위해 만들어진 자료형이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;집합 자료형은 다음과 같이 set 키워드를 이용해 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1,2,3])
&amp;gt;&amp;gt;&amp;gt; s1
{1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-63&quot;&gt;집합 자료형의 특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;중복을 허용하지 않는다.&lt;/li&gt;
  &lt;li&gt;순서가 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있지만 set 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만약 set 자료형에 저장된 값을 인덱싱으로 접근하려면 다음과 같이 리스트나 튜플로 변환한 후 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1,2,3])
&amp;gt;&amp;gt;&amp;gt; l1 = list(s1)
&amp;gt;&amp;gt;&amp;gt; l1
[1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; l1[0]
1
&amp;gt;&amp;gt;&amp;gt; t1 = tuple(s1)
&amp;gt;&amp;gt;&amp;gt; t1
(1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; t1[0]
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-64&quot;&gt;집합 자료형 활용하는 방법&lt;/h3&gt;

&lt;h4 id=&quot;section-65&quot;&gt;교집합, 합집합, 차집합 구하기&lt;/h4&gt;

&lt;p&gt;set 자료형이 정말 유용하게 사용되는 경우는 다음과 같이 교집합, 합집합, 차집합을 구할 때이다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3, 4, 5, 6])
&amp;gt;&amp;gt;&amp;gt; s2 = set([4, 5, 6, 7, 8, 9])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-66&quot;&gt;1. 교집합&lt;/h3&gt;

&lt;p&gt;s1과 s2의 교집합&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 &amp;amp; s2
{4, 5, 6}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-67&quot;&gt;2. 합집합&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 | s2
{1, 2, 3, 4, 5, 6, 7, 8, 9}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;4,5,6처럼 중복해서 포함된 값은 한개씩만 표현된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-68&quot;&gt;3. 차집합&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 - s2
{1, 2, 3}
&amp;gt;&amp;gt;&amp;gt; s2 - s1
{8, 9, 7}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-69&quot;&gt;집합 자료형 관련 함수들&lt;/h3&gt;

&lt;h4 id=&quot;add&quot;&gt;값 1개 추가하기(add)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s1.add(4)
&amp;gt;&amp;gt;&amp;gt; s1
{1, 2, 3, 4}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이미 만들어진 set 자료형에 값을 추가할 수 있다. 1개의 값만 추가(add)할 경우에는 위와 같이 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;update&quot;&gt;값 여러 개 추가하기(update)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s1.update([4, 5, 6])
&amp;gt;&amp;gt;&amp;gt; s1
{1, 2 ,3, 4, 5, 6}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;remove-1&quot;&gt;특정 값 제거하기(remove)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s1.remove(2)
&amp;gt;&amp;gt;&amp;gt; s1
{1, 3}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-70&quot;&gt;자료형의 참과 거짓&lt;/h2&gt;

&lt;p&gt;자료형에도 참과 거짓이 있다. 이는 매우 중요한 특징이며 실제로도 자주 쓰인다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4]
&amp;gt;&amp;gt;&amp;gt; while a:
... 	a.pop()
... 
4
3
2
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 a = [1,2,3,4]라는 리스트를 하나 만들었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while 조건문:
	수행할 문장
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;조건문이 참인 동안 조건문 안에 있는 문장을 반복해서 수행한다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 예를 보면 a가 참인 경우에 a.pop()을 계속 실행하라는 의미이다. a.pop()이라는 함수는 리스트 a의 마지막 요소를 끄집어내는 함수이므로 a가 참인 동안(리스트 내에 요소가 존재하는 한)마지막 요소를 계속해서 끄집어낼 것이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; if [ ]:
...	 	print(&quot;True&quot;)
... else:
... 	print(&quot;False&quot;)
...
False
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 에제를 보면 쉽게 이해 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; if [1, 2, 3]:
... 	print(&quot;True&quot;)
... else:
... 	print(&quot;False&quot;)
...
True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 코드를 해석하면 이와 같다고 할 수 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;만약 [1,2,3]이 참이면, “True”라는 문자열을 출력하고, 그렇지 않다면 “False”라는 문자열을 출력해라!”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 코드의 [1,2,3]은 요소값이 있는 리스트이기 때문에 참이다!&lt;/p&gt;

&lt;h2 id=&quot;section-71&quot;&gt;자료형의 값을 저장하는 공간, 변수&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = &quot;python&quot;
&amp;gt;&amp;gt;&amp;gt; c = [1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;변수를 만들 때는 위의 예처럼 =(assignment)기호를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;변수명 = 변수에 저장할 값&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-72&quot;&gt;변수란?&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 3 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;만약 위의 코드처럼 a = 3이라고 한다면 3이라는 값을 가지는 정수 자료형(객체)이 자동으로 메모리에 생성된다. a는 변수의 이름이며, 3이라는 정수형 객체가 저장된 메모리 위치를 가리키게 된다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;a–&amp;gt;3&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 3 
&amp;gt;&amp;gt;&amp;gt; b = 3
&amp;gt;&amp;gt;&amp;gt; a is b
True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;a가 3을 가리키고 b도 3을 가리킨다. 즉 a = 3 을 입력하는 순간, 3이라는 정수형 객체가 생성되고 변수 a는 3이라는 객체의 메모리 주소를 가리킨다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-73&quot;&gt;변수를 만드는 여러가지 방법&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a, b = ('python', 'life')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 예문처럼 튜플로 a,b에 값을 대입 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; (a, b) = 'python', 'life'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;튜플은 괄호를 생략해도 된다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-74&quot;&gt;메모리에 생성된 변수 없애기!!&lt;/h2&gt;

&lt;p&gt;a=3을 입력하면 3이라는 정수형 객체가 메모리에 생성된다고 했다. 그렇다면 이 값을 메모리에서 없앨 수 있을까? 3이라는 객체를 가리키는 변수들의 개수를 레퍼런스 카운트라고 하였는데, 이 레퍼런스 카운트가 0이 되는 순간 3이라는 객체는 자동으로 사라진다. 즉, 3이라는 객체를 가리키고 있는 것이 하나도 없을 때 3이라는 객체는 메모리에서 사라지게 된다! 이것을 어려운 말로 가비지 콜렉션(쓰레기 수집)이라고도 한다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 특정한 객체를 가리키는 변수를 없애는 것이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 3
&amp;gt;&amp;gt;&amp;gt; b = 3 
&amp;gt;&amp;gt;&amp;gt; del(a)
&amp;gt;&amp;gt;&amp;gt; del(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;변수 a와 b가 3이라는 객체를 가리켰다가 del이라는 파이썬 내장 함수에 의해서 사라진다. 따라서 레퍼런스 카운트가 0이 되어 정수형 객체 3도 메모리에서 사라지게 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(* 사용한 변수를 del 명령어를 이용하여 일일이 삭제할 필요는 없다. 파이썬이 이 모든 것을 자동으로 해준다)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** 리스트를 변수에 넣고 복사하고자 할 때&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]
&amp;gt;&amp;gt;&amp;gt; b = a
&amp;gt;&amp;gt;&amp;gt; a[1] = 4
&amp;gt;&amp;gt;&amp;gt; a
[1, 4, 3]
&amp;gt;&amp;gt;&amp;gt; b
[1, 4, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;b라는 변수에 a가 가리키는 리스트를 대입하였다. 그런 다음 a 리스트의 a[1]을 4라는 값으로 바꾸면 a 리스트만 바뀌는 것이 아니라 b 리스트도 똑같이 바뀐다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;그렇다면 b변수를 생성할 때 a와 같은 값을 가지도록 복사해 넣으면서 a가 가리키는 리스트와는 다른 리스트를 가리키게 하는 방법은 없을까?&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;두가지 방법이 있다.&lt;/p&gt;

            &lt;p&gt;#### 1. [:]의 이용&lt;/p&gt;

            &lt;p&gt;```&lt;/p&gt;
            &lt;blockquote&gt;
              &lt;blockquote&gt;
                &lt;blockquote&gt;
                  &lt;p&gt;from copy import copy
b = copy(a)
  ```&lt;/p&gt;
                &lt;/blockquote&gt;
              &lt;/blockquote&gt;
            &lt;/blockquote&gt;

            &lt;p&gt;#### 2. copy 모듈 이용&lt;/p&gt;

            &lt;p&gt;```&lt;/p&gt;
            &lt;blockquote&gt;
              &lt;blockquote&gt;
                &lt;blockquote&gt;
                  &lt;p&gt;b is a
  False
  ```&lt;/p&gt;
                &lt;/blockquote&gt;
              &lt;/blockquote&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump1.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump1.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Jump to Python - 파이썬이란 무엇인가?</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;파이썬이란?&lt;/h1&gt;

&lt;p&gt;파이썬(Python)은 1990년 암스테르담의 귀도 반 로섬이 개발한 인터프리터 언어이다. 귀도는 파이썬이라는 이름을 자신이 좋아하는 코미디 쇼인 “몬티 파이썬의 날아다니는 서커스”에서 따왔다고 한다. 파이썬의 사전적인 의미는 고대신화에 나오는 파르나소스 산의 동굴에 살던 큰 뱀을 뜻하며, 아폴로 신이 델파이에서 파이썬을 퇴치했다는 이야기가 전해진다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;파이썬의 특징&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;파이썬은 인간다운 언어이다&lt;/h3&gt;

&lt;p&gt;프로그래밍이란 인간이 생각하는 것을 컴퓨터에 지시하는 행위라고 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬은 사람이 생각하는 방식을 그대로 표현할 수 있는 언어이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음의 소스코드는&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if 4 in [1,2,3,4]: print(&quot;4가 있습니다&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;“만약 4가 1,2,3,4중에 있으면 “4 가 있습니다”를 출력한다.”로 해석하여 읽을 수 있다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;파이썬은 간결하다&lt;/h2&gt;

&lt;p&gt;귀도는 파이썬을 의도적으로 간결하게 만들었다. 만약 펄(Perl)과 같은 프로그래밍 언어가 100가지 방법으로 하나의 일을 처리할 수 있다면 파이썬은 가장 좋은 방법 1가지만 이용하는 것을 선호한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# simple.py
languages = ['python', 'perl', 'c', 'java']

for lang in languages:
    if lang in ['python', 'perl']:
        print(&quot;%6s need interpreter&quot; % lang)
    elif lang in ['c', 'java']:
        print(&quot;%6s need compiler&quot; % lang)
    else:
        print(&quot;should not reach here&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드는 프로그래밍 언어를 판별하여 그에 맞는 문장을 출력하는 파이썬 프로그램 코드이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬 프로그램은 줄을 맞추지 않으면 실행이 되지 않는다.&lt;/li&gt;
  &lt;li&gt;줄을 맞추어 코드를 작성하는 행위는 가독성에 크게 도움이 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;파이썬은 개발 속도가 빠르다&lt;/h2&gt;

&lt;p&gt;“Life is too short, You need python”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인생은 너무 짧으니 파이썬이 필요해!!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;파이썬으로 무엇을 할 수 있을까?&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;파이썬으로 할 수 있는 일&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-7&quot;&gt;시스템 유틸리티 제작&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;gui-&quot;&gt;GUI 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;cc-&quot;&gt;C/C++와의 결합&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-8&quot;&gt;웹프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-9&quot;&gt;수치 연산 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-10&quot;&gt;데이터 베이스 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-11&quot;&gt;데이터 분석, 사물 인터넷&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-12&quot;&gt;파이썬으로 할 수 없는일&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-13&quot;&gt;시스템과 밀접한 프로그래밍 영역&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-14&quot;&gt;모바일 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;파이썬 기초 실습&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;대화형 인터프리터는 파이썬 쉘(Python shell)이라고도 한다. 3개의 꺾은 괄호(»&amp;gt;)는 프롬프트(prompt)라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-16&quot;&gt;파이썬 기초 문법 따라하기&lt;/h2&gt;

&lt;h4 id=&quot;section-17&quot;&gt;사칙 연산&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;1 더하기(+)2는 3이라는 값을 출력해보자!. 보통 계산기 사용하듯 더하기 기호만 넣어주면 된다!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 1 + 2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;나눗셈(/)과 곱셈(*) 역시 예상한 대로 결과값을 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 3 / 2.4
1.25
&amp;gt;&amp;gt;&amp;gt; 3 * 9
27
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;우리가 일반적으로 알고 있는 ÷ 기호나 × 기호가 아닌 것에 주의!!&lt;/p&gt;

&lt;h4 id=&quot;section-18&quot;&gt;변수에 숫자 대입하고 계산하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = 2
&amp;gt;&amp;gt;&amp;gt; a + b
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;a에 1을, b에 2를 대입한 다음 a와 b를 더하면 3이라는 결과값을 보여준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;파이썬은 대소문자를 구분한다. print를 PRINT로 쓰면 정의되지 않았다는 에러 메세지가 나온다&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;if&quot;&gt;조건문 if&lt;/h4&gt;

&lt;p&gt;다음은 조건문 if를 이용한 예제이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 3 
&amp;gt;&amp;gt;&amp;gt; if a &amp;gt; 1:
... 	print(&quot;a is greater than 1&quot;)
...
a is greater than 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;**print문의 앞의’…‘은 아직 문장이 끝나지 않았음을 의미한다!&lt;/p&gt;

&lt;h4 id=&quot;for&quot;&gt;반복문 for&lt;/h4&gt;

&lt;p&gt;다음은 for를 이용해서 [1, 2, 3]안의 값들을 하나씩 출력해 주는 것을 보여주는 예이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for a in [1,2,3]:
... 	print(a)
... 
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for문을 이용하면 실행해야 할 문장을 여러 번 반복해서 실행시킬 수 있다. 위의 예는 대괄호([]) 사이에 있는 값들을 하나씩 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;while&quot;&gt;반복문 while&lt;/h4&gt;

&lt;p&gt;다음은 while을 이용하는 예제이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; i = 0
&amp;gt;&amp;gt;&amp;gt; while i &amp;lt; 3:
... 	i=i+1
... 	print(i)
...
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-19&quot;&gt;함수&lt;/h4&gt;

&lt;p&gt;함수는 다음과 같은 형태이다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def sum(a, b):
... 	return a+b
...
&amp;gt;&amp;gt;&amp;gt; print(sum(3,4))
7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;파이썬에서 &lt;strong&gt;def&lt;/strong&gt;는 함수를 만들 때 사용하는 예약어이다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sum(a,b)에서 a,b는 입력값이고, a+b는 결과값이다! 즉, 3, 4가 입력으로 들어오면 3+4를 수행하고 그 결과값인 7을 돌려준다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>코딩을 지탱하는 기술</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;코딩을 지탱하는 기술&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;프로그래밍 학습에 중요한 포인트 3가지&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;비교를 통한 학습&lt;/li&gt;
  &lt;li&gt;역사를 통한 학습&lt;/li&gt;
  &lt;li&gt;만드는 것을 통한 학습&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;규칙은 언어마다 다르다&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C언어에서는 0이 참이지만, ruby에서는 0이 거짓이다. 자바에서는 0이 단순한 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;잘못된 고정관념을 버려야 한다.&lt;/h4&gt;

&lt;p&gt;특정언어에 국한된 지식을 습득할 것이 아니라 모든 언어에 통용 될 수 있는 이해력을 기를 필요가 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;프로그래머의 삼대 미덕&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;나태함, 조바심, 자만심&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;프로그래밍 언어는 사람을 편하게 하기 위해서 만들어졌다.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;언어는 도구일 뿐이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가상소프트웨어의 선결과제 = 빠른 실행 속도&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C++ 은 빠른 실행 속도를 자랑하지만 높은 언어사양을 요구한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;프로그래밍 언어에 대한 이해력을 확인하기 위해서는 아웃풋(결과물)을 확인해야한다.&lt;/h4&gt;

&lt;p&gt;에러메세지가 발생하면 당황하거나 무서워하지말아야 한다. 내가 만든 것을 언어 처리계가 열심히 읽어서 여기를 모르겠다고 대답해주고 있는 것이다 - 언어 처리계와 제대로된 커뮤니케이션을 하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아직도 스택 머신(FORTH)은 살아있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Python이나 Ruby, Java로 프로그램을 짜면 그 프로그램은 내부적으로 FORTH와 같은 프로그램으로 변환(컴파일)되어 동작하고 있는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;언어마다 차이가 생긴 것은…&lt;/h3&gt;

&lt;p&gt;표현 방법이 틀릴뿐. 구문트리는 동일하다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘어떤 문자열을 쓰면 어떤 구문 트리가 생기는가’ = 이것이 규칙이자 문법이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재 대부분의 프로그래밍 언어들은 다가가기 쉬운 언어 작성법을 목표로 하고 있다. 하지만 기존의 문법과 마찰되지 않도록하면서 새로운 문법을 추가하는 것은 굉장히 어려운 일이다!&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;if&quot;&gt;if문&lt;/h3&gt;

&lt;p&gt;if-else 구문의 이점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다’ 이것을 간단하고 읽기 쉬운 형태로 볼 수 있게 해준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;else가 반드시 필요한 것은 아니다. 하지만 가독성 측면에서 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;p&gt;###반복문&lt;/p&gt;

&lt;h4 id=&quot;for---while--&quot;&gt;for문으로 가능한 것은 while문으로도 가능하긴 하다.&lt;/h4&gt;

&lt;p&gt;while문 에서는 분산되어 있던 반복 조건문들이 for문에서는 한곳에 모여있기 때문에 루프문 작성자의 의도를 쉽게 파악 할 수 있다.&lt;/p&gt;

&lt;p&gt;foreach구문은 ‘어떤 대상의 요소 전부에 어떤 처리를 한다’는 코드를 쉽게 쓰기 위해 만들어졌다.&lt;/p&gt;

&lt;h5 id=&quot;python-for-foreach---c--for----&quot;&gt;Python의 for문은 foreach 구문이다. 역으로, C 언어의 for 문에 대응하는 구문은 없다!&lt;/h5&gt;

&lt;h5 id=&quot;for---------&quot;&gt;for문에서도 조건식으로 제어하고 있지만, 주요 사용 목적은 횟수를 의식한 제어다!&lt;/h5&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for문은 정해진 범위 내에서 루프&lt;/li&gt;
  &lt;li&gt;while문은 범위가 없이 루프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;바꿔 말하자면, for문은 반복수를 알 때 사용한다. while문은 반복수를 모를 때 사용한다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;함수&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;코드가 함수로 나누어져 있는 것은 큰 조직이 부서로 나눠져 있는 것과 같다!!!&lt;/h4&gt;

&lt;p&gt;함수를 만드는 것은 작은 부품을 조립해서 큰 부품을 만드는 것과 같다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예를 들어 무선 조정 자동차 속에는 모터가 있고 모터 속에는 코일이나 정류자가 들어있다!! = 함수의 개념이다&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;무선 조정 자동차가 느려지면 알칼리 전지가 약해졌다고 생각 할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;근처 편의점에 가서 전지를 구해야한다 = 함수의 이해와 같다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;함수도 동일하다. 수십 행 수백 행의 코드가 함수로 정리되어 제공되고 있어서 그 함수를 호출해서 사용이 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;프로그램을 만드는 것과 물리적인 것을 만드는 것의 차이 ( 비용의 차이 )&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예를 들어 아파트 100세대에 급수기를 설치해야 한다면 100개의 급수기가 필요하다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램은 100개의 특정 데이터가 있으면 함수만 100회 호출하면 된다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한계가 없다&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1: 110의 점프 명령의 점프 목적지를 3으로 바꾼다&lt;/li&gt;
  &lt;li&gt;2: 함수를 호출한다 ( 100으로 점프 )&lt;/li&gt;
  &lt;li&gt;3: 다음 명령.&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;51: 110의 점프 명령의 점프 목적지를 53으로 바꾼다.&lt;/li&gt;
  &lt;li&gt;52: 함수 호출 ( 100으로 점프 )&lt;/li&gt;
  &lt;li&gt;53: 다음 명령.&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;100: 함수 처리&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;110: 돌아간다 ( 0으로 점프 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;이렇게 해서 함수가 탄생했다&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;함수의 이름&lt;/h3&gt;

&lt;p&gt;메모리상에서의 위치&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;함수를 사용한 처리에 이름을 붙이는 행위는 ‘처리가 시작되는 메모리상의 위치’를 수치로 표현하는 대신, 알기 쉬운 문자열로 표현하는 행위다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수도 마찬가지다. ‘값이 기록된 메모리 위치’를 수치가 아닌 문자열로 표현하기 위해 만들어졌다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;stack--&quot;&gt;스택 ( Stack ) 영역&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;복수의 데이터 값을 저장해두는곳&lt;/li&gt;
  &lt;li&gt;마지막에 넣은 것을 가장 먼저 꺼내는 것에 적합&lt;/li&gt;
  &lt;li&gt;할당된 메모리 구조는 위에서부터 데이터 - 힙 - 스택 순으로 배치된다. (스택은 가장 아래부분)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;재귀 함수&lt;/h3&gt;

&lt;p&gt;재귀함수는 함수 X안에서 함수 X 자신을 호출 하는 것이다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내포 구조를 다루는데 적합하다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h4 id=&quot;section-12&quot;&gt;재귀함수의 구조를 이해하기위한 좋은예&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xs = [1,2,[3,4],5]
def total(xs):
    result = 0
    for x in xs:
        if is_integer(x):
            result += x
        else:
            result += total(x)
            
    return result 
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;x는 내포 리스트이기 때문에 total로 안에 든 값을 합산한다!&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;에러 처리&lt;/h3&gt;

&lt;p&gt;프로그램 실행 시 실패가 발생하는 경우가 많다. 실패 시에 어떻게 하는가(에러처리)는 매우 중요하다!!&lt;/p&gt;

&lt;p&gt;크게 방법은 두가지이다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;반환값을 사용하는 방법&lt;/li&gt;
  &lt;li&gt;예외를 사용하는 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-14&quot;&gt;반환값으로 실패를 전달하는 방법에 대해서…&lt;/h4&gt;

&lt;p&gt;이 방법은 C 언어를 비롯해서 많은 언어가 사용하고 있는 중이다.&lt;/p&gt;

&lt;p&gt;그러나&lt;/p&gt;

&lt;p&gt;2가지 문제점이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실패를 놓친다.&lt;/li&gt;
  &lt;li&gt;에러 처리 때문에 코드를 해석하기 어렵다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;때문에 점프로 에러를 처리하며 처리에는 goto를 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C 언어에는 예외기능이 없기 때문이다
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;에러가 발생했을 때 점프할 장소를 사전에 등록해두는 방법이 있다. 이방법이 발전해서 오늘날의 ‘예외 처리’가 된 것이다&lt;/p&gt;

&lt;h4 id=&quot;univac-i-&quot;&gt;UNIVAC I의 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;‘계산 시 오버플로우가 발생하면 xxx번지에 있는 명령을 실행한다’는 기능이 있었다. 이런 기능을 ‘인터럽트(interrupt)’라고 불렀다. (예로들면 키보드 입력 처리)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cobol-&quot;&gt;COBOL의 경우&lt;/h4&gt;

&lt;p&gt;1959년에 두가지 에러처리를 탑재하고 나타났다!&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;READ로 파일을 읽을 때 ‘AT END’라는 	구문으로 ‘더 이상 데이터가 없다’ 등의 		에러가 발생했을 때&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ADD등으로 수치 계산을 할 때 오버플로우가 발생했을 경우 ‘ON SIZE ERROR’ 구문으로 처리를 표현&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;pli-&quot;&gt;PL/I의 경우&lt;/h4&gt;

&lt;p&gt;1964년 FORTRAN, COBOL, ANGOL을 집성해서 설계되었다.&lt;/p&gt;

&lt;p&gt;새롭게 정의한 실패를 프로그래머가 발생 시킬 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;프로그래밍은 짝이 되는 처리가 중요하다&lt;/h3&gt;

&lt;p&gt;미술관을 예로들면, 입구에서 빌린 음성 안내기를 출구가 하나라면 제대로 회수 할 수 있지만, 출구가 여러개라면 회수가 어려워 진다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;여기서 출구란 ( return )&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이문제는 finally를 사용해서 짝을 맞춰 줄 수 있으며 해결 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;finally 블록은 처리가 try 블록에서 벗어날 때 반드시 실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Microsoft사에서 처음 도입했으며, 1995년에는 Java도 도입했다. 현재는 Python이나 Ruby에서도 동일한 구문을 지원하고 있다.&lt;/p&gt;

&lt;h4 id=&quot;c-finally---&quot;&gt;C++은 finally를 갖고 있지 않다.&lt;/h4&gt;

&lt;p&gt;함수를 벗어날때 함수의 지역 변수에 대해서 자동적으로 소멸자가 호출되어 finally의 역할을 대신한다.&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;어떤 경우에 예외를 던질까?&lt;/h3&gt;

&lt;p&gt;Python과 Ruby는 함수 호출 시점에서 예외를 던진다. 그러나, JavaScript는 인수에 ‘미정의를 의미하는 특수한 값’을 사용해서 처리를 계속한다.&lt;/p&gt;

&lt;h4 id=&quot;section-17&quot;&gt;예외는 어떤 경우에 사용해야하는가?&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;예외적 상황이란 무엇인지에 대한 정답은 없다&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;프로그래머도 사람인 이상, 실수를 피할 수는 없다.&lt;/p&gt;

&lt;p&gt;무언가가 이상하다면 빨리 문제를 발견하는 것이 중요하다. 학습이나 개발 단계에서는 틀리면 바로 틀린 것을 발견하는 것이 오히려 이점이 많다.&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;이름과 스코프&lt;/h3&gt;

&lt;p&gt;스코프란 변수나 함수의 이름이 유효한 ‘범위’를 말한다.&lt;/p&gt;

&lt;h4 id=&quot;section-19&quot;&gt;왜 이름이 필요한가?&lt;/h4&gt;

&lt;p&gt;지금은 있는 것이 당연하다고 느끼는 변수나 함수의 이름은 초기에는 메모리에 번호를 부여해서 해당 값을 찾는 방식이었으나, 이름으로 대상을 지정 할 수 있도록 꾸준히 발전해왔다.&lt;/p&gt;

&lt;h4 id=&quot;section-20&quot;&gt;이름의 충돌&lt;/h4&gt;

&lt;p&gt;초기 프로그래밍 언어에서는 대응표를 프로그램 전체에서 공유하고 있었다. 회사로 말하면 큰 화이트 보드가 있어서 모두가 메모를 하고 있는 상황과 같았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것은 같은 이름을 지닌 값이 있다면 데이터를 덮어써버려서 충돌을 일으키는 것이 문제였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-21&quot;&gt;충돌 피하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;긴 변수명을 사용하는 방법&lt;/li&gt;
  &lt;li&gt;스코프를 이용하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-22&quot;&gt;스코프란??&lt;/h4&gt;

&lt;p&gt;이름의 유효 범위다.&lt;/p&gt;

&lt;p&gt;이것은 동적 스코프와 정적 스코프로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;동적 스코프 : 함수 입구에 원래의 값을 기록해두고 함수 출구에서 리턴값을 원래의 값으로 되돌리고 내보내는 것이다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;문제점 : 동적 스코프의 문제점으로는 변수를 변경한 후에 다른 함수를 호출한 경우 호출된 함수에 영향을 미치게 되기 때문에 다루기 힘들다는 점이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정적 스코프 : 함수가 호출될 때마다 새로운 대응표를 만드는 것과 같다고 할 수 있다. 회사 전체가 공유하고 있는 커다란 화이트 보드에 작성하는 대신, 한명 한명이 자신의 책상에 메모 용지를 갖고 있는 것으로 비유 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-23&quot;&gt;하지만 동적 스코프로 만들어진 대응표는 소스 코드 전역에서 읽고 쓸 수 있다. 정적 스코프와의 가장 큰 차이점이다!&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;동적 스코프가 만약 참조한 경우에는 가까운 곳부터 순서대로 읽는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-24&quot;&gt;정적 스코프는 함수별로 대응표를 나눈다&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;특정 함수내에서의 이름변경이 함수 밖까지 영향을 주지 못한다. (유효 범위 분할이 가능)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;현재는 많은 언어가 정적 스코프를 도입중이다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-25&quot;&gt;그렇다면 정적 스코프는 완성체인가?&lt;/h3&gt;

&lt;p&gt;정적 스코프의 특징이 편리해 보일 수도 있지만 2가지의 문제점을 지니고 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;내포 함수의 문제점 : 내포된 것처럼 보이는 함수가 실제로는 내포되지 않은 것이다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Python 2.0 을 예로들면, 특정 함수의 지역 스코프에서 찾고자하는 이름을 발견하지 못할 경우, 전역 스코프를 보게 된다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;이는 소스 코드 상에서 가까이에 있는 정의가 사용되지 않는 예이다. 지금은 가까이에 있는 정의를 사용하도록 수정되었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;외부 스코프에 재귀속되는 문제&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;내포한 스코프의 외부 변수를 변경할 수 없다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수안에서 대입하면 그 함수의 지역 변수가 되는데, 해당 스코프에 이미 같은 이름의 변수가 있으면 해당 변수를 재귀속 시키고, 없으면 해당 스코프에서 새로운 지역 변수를 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;어느쪽이든 외부 스코프에 영향을 미치지 않게 되므로 이것은 외부 스코프에 있는 변수를 변경할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;section-26&quot;&gt;형&lt;/h2&gt;

&lt;p&gt;형이란 수치를 On과 Off로 표현하는 방법이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴퓨터 안에서는 On과 Off, 0과 1의 집합으로 모든 값이 표현된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-27&quot;&gt;자릿수의 발명&lt;/h4&gt;

&lt;p&gt;컴퓨터가 탄생하기 1000년 이상 전에 인류는 자릿수 기수법을 발명했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 자리에 0에서 9까지 10가지 기호를 사용해서 수를 표현하는 방법이다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-28&quot;&gt;7 세그먼트 디스플레이&lt;/h4&gt;

&lt;p&gt;계산기 등에서 수치를 표현하기 위해서 만들어졌다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;7 세그먼트 디스플레이를 사용하면 7개의 램프로 한 자릿수를 표현할 수 있어서, 3자릿수를 표현하기 위해 필요한 램프의 개수는 21개가 되고, 이는 기존의 것 보다 6개를 줄일 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-29&quot;&gt;주판&lt;/h4&gt;

&lt;p&gt;하지만 더 효율적인 방법이 나타났다.
바로 주판이다. 5개로 하나의 자리를 표현하는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;3 자릿수를 표현하려면 15개의 램프가 필요하다. 이것으로 6개를 더 줄일 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;램프 4개로 16가지를 표현할 수 있음에도 불구하고 10가지만 사용한다면 아까운 느낌이 든다. 좀 더 간격을 채워 넣을 방법이 없을까?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;1의 자리, 10의 자리, 100의 자리(10 x 10), 1000의 자리(10 x 10 x 10)로 자릿수를 맞추는 대신, 1의 자리, 2의 자리, 4의 자리(2 x 2), 8의 자리(2 x 2 x 2)로 맞추자는 발상이다! 이것이 바로 2진수다!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2진수를 사용하면 10개의 램프로 0부터 1,023까지 표현이 가능하다&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-30&quot;&gt;8진수&lt;/h4&gt;

&lt;p&gt;8가지 부호를 사용해서 자릿수를 맞추고 있어서 8진수라고 불린다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 묶음에 2 x 2 x 2로 8가지 패턴이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-31&quot;&gt;16진수&lt;/h4&gt;

&lt;p&gt;16가지 부호를 사용해서 자리를 맞추고 있기 때문에 16진수라고 불린다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8진수 수치의 앞자리에는 0이나 0o를 붙이고, 16진수 수치에는 0x를 붙이는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-32&quot;&gt;실수는 어떻게 표현할까?&lt;/h3&gt;

&lt;p&gt;1.5나 0.001 등 소수점이 있는 ‘실수’는 어떻게 표현할까?&lt;/p&gt;

&lt;p&gt;두가지 방법이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고정 소수점&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부동 소수점&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;고정 소수점 ( 소수점을 어디에 붙일지 정한다 )
        &lt;ul&gt;
          &lt;li&gt;예를 들면 ‘이 정수는 소수점을 4자리 이동시켜서 소수점 이하 4자리를 소수부’라고 정하면 1이 0.0001이 되고, 100이 0.0100, 즉, 0.01이 된다. 하지만 0.0001보다 작은 값을 표현 할 수가 없고, 각각의 값에 대해 ‘어디까지 소수부로 정했는지’를 사람이 기억해야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부동 소수점 ( 어디부터 소수부인지의 정보 자체를 값에 포함시킨다 )
        &lt;ul&gt;
          &lt;li&gt;소수점을 이동시키는 방법으로 이 방법을 사용하면 1,023 이후에 0이 30개 계속되는 큰 숫자를 표현 할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ieee-754--&quot;&gt;현재는 표준화 되어 IEEE 754가 적용되고 있다&lt;/h4&gt;

&lt;p&gt;IEEE 754에서는 ‘지수부’가 소수점 위치에 해당하고, ‘가수부’가 유효 숫자의 소수점 이하 부분에 해당한다.&lt;/p&gt;

&lt;h4 id=&quot;section-33&quot;&gt;문제점&lt;/h4&gt;

&lt;p&gt;대부분의 경우에는 별 문제가 없지만, ‘3 나누기 10’의 결과를 표현하려고 하면, 10 진수로는 0.3을 사용해 표현 할 수 있지만, 2 진수의 경우 무한 소수가 되어 버린다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;p&gt;컴퓨터는 비트열만으로 그것을 정수로 해석해야 할 지 부동 소수점으로 해석해야 할 지 알 수가 없다. 따라서, ‘이 값이 어떤 종류인지’ 정보가 별도로 필요한데 이것이 바로 ‘형’이다.&lt;/p&gt;

&lt;h4 id=&quot;fortran-&quot;&gt;초기 FORTRAN의 형&lt;/h4&gt;

&lt;p&gt;변수명에 안에 든 것이 무엇인지 표현하기 위한 규칙을 만들게 되었다. 초기 FORTRAN에서는 변수명 선두가 I ~ N 이면 정수, 그 이외이면 부동 소수점이 들어 있다는 규칙을 사용했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다른 한가지 방법은 언어 처리계에 ‘이 변수는 정수다’라고 알려서 사람이 아닌 컴퓨터가 기억해두는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-34&quot;&gt;정수끼리, 부동 소수점끼리의 연산&lt;/h4&gt;

&lt;p&gt;컴퓨터는 형 정보를 참고해서 무엇을 할 지 정한다. x와 y 둘 다 정수인 경우는 정수 덧셈을 하고, x와 y 둘 다 부동 소수점인 경우에는 부동 소수점 덧셈을 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;한쪽이 정수고 다른 한쪽이 부동 소수점이라면?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;초기 FORTRAN의 경우 에러 처리를 했다. 하지만 C언어에서는 부동 소수점으로 암묵적 변환을 시킨다.&lt;/p&gt;

&lt;p&gt;하지만 C언어의 경우, 이것은 프로그래머가 어떤 형인지 기억해두지 않으면, 특정 코드를 보고도 소수점 이하를 버리는지 아닌지를 알 수가 없는 단점이 있다.&lt;/p&gt;

&lt;p&gt;이러한 설계는 많은 언어가 오랜 시간동안 사용해 왔던 것이기 때문에 ‘원래 그런 것이다’라고 생각하는 프로그래머가 많겠지만 이것은 불변의 물리 법칙이 아닌, 사람이 만든 설계일 뿐이다.&lt;/p&gt;

&lt;h3 id=&quot;section-35&quot;&gt;형의 다양한 전개&lt;/h3&gt;

&lt;p&gt;원래는 값의 종류를 저장하기 위해 사용되었던 형은 다양하게 응용되고 있다.&lt;/p&gt;

&lt;h4 id=&quot;section-36&quot;&gt;사용자 정의형과 객체 지향&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;언어가 가지고 있는 기본적인 형을 조합해서 새로운 형을 만드는 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정수 등 ‘데이터’뿐만 아니라 함수 등 ‘데이터’를 처리하는 기능도 형으로 정리&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이런 형에 클래스(class)라는 이름을 붙였다. 이것이 제2의 객체 지향의 발명이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-37&quot;&gt;사양으로서 형&lt;/h3&gt;

&lt;h4 id=&quot;section-38&quot;&gt;공개와 비공개를 나누다&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;‘형은 사양이다’라는 개념이 등장했다. 구조체나 클래스를 구성하는 형을 전부 공개하지 않고 최소한만을 공개한다는 것이다. 외부와 작업하는 부분만을 형으로 공개하고, 상세 구현 방법은 숨긴다는 발상이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-39&quot;&gt;인터페이스로 발전&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;‘형은 사양이다’라는 개념은 더욱 진화해서 구체적인 구현 방법을 가지고 있지 않는 형이 탄생했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-40&quot;&gt;총칭형, 제네릭스, 템플릿&lt;/h3&gt;

&lt;p&gt;‘일부만 바꾸고 싶은데 전부 다시 정의해야 하는 것은 이상하다. 재사용하고 싶다’라는 필요가 생겨났고, ‘구성 요소의 형을 일부만 바꾸는 형’, 즉 총칭형이 탄생했다. ‘형이 인수를 가지고 형을 만드는 함수’가 탄생한 것이다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C++의 템플릿(template), Java(generic)등이 그러한 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-41&quot;&gt;동적 형결정&lt;/h4&gt;

&lt;p&gt;‘종류 정보’를 값과 함께 세트로 가지고 있는 것을 ‘동적 형결정’이라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-42&quot;&gt;어떻게 표현하고 있을까?&lt;/h4&gt;

&lt;p&gt;동적 형결정 언어에서 형 선언이 필요 없는 것은 메모리 상에서 동일한 형으로 취급되도록 설계되어 있기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 값은 정수든 부동 소수점이든 문자열이든 모두 PyObject 형으로 취급되도록 머리 부분이 모두 같은 형태로 되어 있다. 그리고 PyObject 형의 구조 안에는 값의 종류 정보를 저장할 수 있는 공간이 마련되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 방법으로 값의 종류를 관리하면 종래의 정적 형결정 언어에서는 할 수 없었던 유연한 처리가 가능해지지만, 동적 형결정 언어에서는 형 체크를 할 수 없기 때문에 일부 버그는 실행 전에 찾아낼 수가 없다.&lt;/p&gt;

&lt;h3 id=&quot;section-43&quot;&gt;형 추론&lt;/h3&gt;

&lt;p&gt;형 추론은 원래 OCaml이나 Haskell 등의 ML계 언어가 잘하는 분야였지만, 최근에는 Java VM 상에서 동작하는 언어인 Scala등 형 추론을 장점으로 부각시키는 언어가 늘고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재는 정적 형결정과 동적 형결정과 같이 정보 저장 장소나 사용하는 타이밍이 다른 것까지 포함해서 ‘형’이라 부른다. 이 때문에 형이 무엇인지 더욱 이해하기 어렵게 되었다. 어떤 정보가 어디에 있고 어떤 타이밍에 사용되는지의 관점에서 보아야 이해하기 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-44&quot;&gt;컨테이너와 문자열&lt;/h3&gt;

&lt;p&gt;무언가를 넣는 상자를 컨테이너라고 부른다고 하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;언어마다 다양한 컨테이너가 있다.&lt;/li&gt;
  &lt;li&gt;각각의 컨테이너에는 장단점이있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;컨테이너에 넣은 데이터는 메모리에 저장된다. 메모리에는 정해진 크기의 상자가 정렬되어 있으며, 각 상자는 번호가 부여되어 있는 물품 보관함 같은 것이다&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너 종류에 따라서 메모리 저장 방법이 다르다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;메모리 : 정해진 크기의 상자가 정렬되어 있고 각 상자에 번호가 부여되어 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-45&quot;&gt;배열과 연결 리스트&lt;/h4&gt;

&lt;p&gt;두 종류의 컨테이너가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;배열&lt;/li&gt;
  &lt;li&gt;연결 리스트&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-46&quot;&gt;배열에 값을 삽입하는 경우&lt;/h4&gt;

&lt;p&gt;배열에서는 ‘값을 순서대로 넣는’방법으로 저장한다. 배열에 요소를 삽입 할 때는 삽입된 위치보다 뒤에 있는 요소를 전부 다른 위치로 옮겨야 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-47&quot;&gt;연결 리스트에 값을 삽입하는 경우&lt;/h4&gt;

&lt;p&gt;연결 리스트에서는 메모리에 순서대로 정렬해있을 필요가 없다. ‘다음 요소가 들어있는 위치’를 메모리 상에 넣어두기 때문이다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연결 리스트에 삽입 할 때는 상자 두개를 추가하고, 상자 하나만 변경하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-48&quot;&gt;장단점&lt;/h4&gt;

&lt;p&gt;배열에서는 삭제된 요소보다 뒤에 있는 것을 모두 움직여야 하기에 O(n)이 돼버리지만, 연결 리스트에서는 ‘다음 요소는 어딘지’의 정보를 바꾸기만 하면 되기에 O(1)이다.&lt;/p&gt;

&lt;p&gt;배열에서는 순서대로 나열하고 있기 때문에 금방 n번째 요소를 알 수 있지만, 연결 리스트에서는 각 요소를 자신이 원하는 곳에 넣을 수 있기 때문에 이 방법을 사용 할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;section-49&quot;&gt;언어에 따른 차이&lt;/h4&gt;

&lt;p&gt;Java나 Python, Ruby 등 대부분의 언어에서는 배열이 가장 기본적인 컨테이너로 제공되고 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-50&quot;&gt;사전, 해쉬, 연상 배열&lt;/h3&gt;

&lt;p&gt;‘값을 복수 개 넣는다’는 목적을 위해 배열과 연결 리스트 등 여러 가지 방법이 있었듯이, ‘문자열과 값의 대응을 넣는다’는 목적을 위해서 몇 가지 구현 방법이 있다. 자주 사용되는 것이 해쉬테이블과 트리다.&lt;/p&gt;

&lt;h4 id=&quot;section-51&quot;&gt;해쉬 테이블&lt;/h4&gt;

&lt;p&gt;문자열을 인수로 받아서 정수를 반환하는 ‘해쉬 함수’를 사용해서 문자열과 값의 대응 관계를 표현하는 방법이다.&lt;/p&gt;

&lt;h4 id=&quot;section-52&quot;&gt;트리&lt;/h4&gt;

&lt;p&gt;트리는 데이터의 구조체다. ‘왼쪽 자식’, ‘오른쪽 자식’에 두 개의 화살표가 연결된다. 습관적으로 아래를 향해서 뻗어나가기 때문에 나무라기 보단 나무 뿌리처럼 보일 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;section-53&quot;&gt;요소를 꺼내는 시간&lt;/h4&gt;

&lt;p&gt;배열에 키와 값을 넣고 어떤 키에 대응하는 값을 찾고자 한다고 하자. 어떤 키가 어디에 있는지 모르기 때문에 배열의 맨 처음부터 순서대로 읽어나간다. 첫 부분에서 찾을 수도 있고, 맨 마지막에서 찾을 수도 있다. 평균적으로 n/2회 체크가 필요하다. 즉, O(n)이 된다.&lt;/p&gt;

&lt;h4 id=&quot;section-54&quot;&gt;트리의 경우&lt;/h4&gt;

&lt;p&gt;트리의 경우 높이가 하나씩 증가하면 요소 수는 약 2배가 된다. 반대로 말하면, 데이터량이 2배가 될 때마다 필요한 비교 횟수가 1회 증가한다. 즉, 트리에서 꺼내는 처리의 오더는 O(log n)이다.&lt;/p&gt;

&lt;h4 id=&quot;section-55&quot;&gt;해쉬 테이블의 경우&lt;/h4&gt;

&lt;p&gt;키에 대응하는 값을 꺼내기 위해서는 ‘키를 해쉬 함수로 변환’, ‘배열에 해당 장소에 있는 값을 읽는’ 작업이 필요하다. 이 작업은 데이터량과 관계가 없다. 즉 O(1)이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해쉬 테이블의 오더가 가장 작다.&lt;/li&gt;
  &lt;li&gt;해쉬 테이블은 값을 넣기 위해 큰 배열을 사용하고 있기 때문에 메모리 소모량이 매우 크다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 절약 » 배열&lt;/li&gt;
  &lt;li&gt;계산 시간 » 해쉬 테이블&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-56&quot;&gt;만능 컨테이너란 없다&lt;/h3&gt;

&lt;p&gt;절대 정답은 존재하지 않는다. 자신의 상황에 맞게 적합한 균형을 찾는 게 중요하다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-57&quot;&gt;문자란?&lt;/h3&gt;

&lt;h4 id=&quot;section-58&quot;&gt;문자 집합과 문자 부호화 방식&lt;/h4&gt;

&lt;p&gt;부호화 방법을 공유하고 있지 않은 사람과는 작업을 할 수가 없다.&lt;/p&gt;

&lt;h4 id=&quot;section-59&quot;&gt;컴퓨터 이전 시대의 부호화&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;모스부호&lt;/li&gt;
  &lt;li&gt;보 코드&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모스부호 : 모스부호는 사람이 스위치를 눌러서 송신하고, 사람이 귀로 들어 수신한다는 규칙으로 만들어진 부호화 방법이었다. 이 방법은 1초 동안 송신할 수 있는 양과 수신할 수 있는 양에 한계가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;보 코드 : 하나의 문자를 On/Off 5개의 조합(5비트)으로 표현하는 것이다. 즉 SOS는 15비트로 표현 할 수 있었다. 모스부호의 절반으로 효율이 좋다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-60&quot;&gt;컴퓨터 시대의 부호화&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;EDSAC 문자 코드&lt;/li&gt;
  &lt;li&gt;ASCII와 EBCDIC 시대&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EDSAC : 텔렉스와 같이 한 문자에 5비트를 사용했고, 숫자, 문자, 시프트를 사용해서 출력했다. 보 코드와 같은 발상이다. 단지 어떤 문자를 어떤 비트열에 할당할지가 달랐다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ASCII : ASCII는 한 문자당 7비트를 사용하는 부호화 방식이다. 7비트로 128 종류의 문자를 표현 할 수 있기 때문에 시프트로 변환할 필요가 없어졌다. ASCII가 부호화하는 문자 세트에는 EDSAC보다 많은 기호와 제어 코드, 그리고 소문자 알파벳도 포함되어 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ASCII와 EBDCIC은 알파벳 대소문자나 기호를 부호화하는 기법&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;unicode--&quot;&gt;Unicode에 의한 통일&lt;/h4&gt;

&lt;p&gt;인터넷이 발전하고 다양한 나라에서 만들어낸 데이터가 교환되기 시작하면서 이 문제가 표면 위로 떠올랐다. 여러 나라가 정한 ‘규칙’을 이해하지 않으면 안 되는 상황이 되었다.&lt;/p&gt;

&lt;p&gt;전 세계의 문자를 부호화하는 방법을 만들자는 움직임이 시작됐고, 1984년에 국제 표준화 기구(ISO)가 작업을 시작하였다. 이렇게 해서 전 세계 문자를 포함한 문자 집합 Unicode가 탄생했다.&lt;/p&gt;

&lt;h3 id=&quot;section-61&quot;&gt;문자열이란?&lt;/h3&gt;

&lt;p&gt;문자열이란 문자가 정렬해있는 것이다. 하지만 문자에 따라선 문자열을 표현하는 방법은 제 각각이다.&lt;/p&gt;

&lt;h4 id=&quot;pascal-----c-&quot;&gt;길이 정보를 가지고 있는 Pascal 문자열, 가지고 있지 않은 C 문자열&lt;/h4&gt;

&lt;p&gt;C언어와 Pascal은 둘 다 ‘하나의 문자를 8비트’로 정의하고 있다. Pascal 문자열은 제일 앞 부분에 문자열 길이를 기록해둔다는 규칙을 채용하고 있다. 그러나 C언어 문자열은 ‘문자열이 시작되는 메모리 상의 위치’만을 가지고 있다. 길이 정보를 가지고 있지 않아서, 해당 위치에서 어디까지가 문자열인지 알 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NUL 문자로 문자열의 끝을 표현한다&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NUL 문자는 0에 대응하는 문자로, C언어 코드에서는 \0으로 표현한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Python은 Java와 같이 16비트 문자열인 ‘Unicode 문자열’과 Pascal과 같은 8비트 문자열 모두를 지원하는 언어다&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Python 2.7에서는 Unicode 문자열에 바이트열을 결합할 경우 바이트열이 ASCII로만 이루어진 경우에 한해 성공한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python 3.0에서는 Unicode 문자열에 바이트열을 결합하면 항상 실패한다. 명시적으로 Unicode 문자열로 변환하고 나서 결합한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ruby-19-&quot;&gt;Ruby 1.9의 도전&lt;/h4&gt;

&lt;p&gt;Ruby는 독자 노선을 가고 있었다. Ruby 1.9부터 문자열은 8비트로 하고 ‘부호화 방식 정보’를 추가로 보유하도록 했다. 이 방법은 Unicode 문자 집합에 포함되지 않는 문자를 손쉽게 쓸 수 있다는 점이 장점이다.&lt;/p&gt;

&lt;h2 id=&quot;section-62&quot;&gt;병행처리&lt;/h2&gt;

&lt;h3 id=&quot;section-63&quot;&gt;병행 처리란?&lt;/h3&gt;

&lt;p&gt;복수의 처리를 시간축 상에 오버랩에서 실행하는 것을 병행 처리라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-64&quot;&gt;잘게 분할해서 실행한다&lt;/h4&gt;

&lt;p&gt;사람의 눈으로 보면 프로그램이 계속 동작하고 있는 것처럼 보이지만, 실제로는 잘게 분할해서 실행되고 있는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;section-65&quot;&gt;처리를 변경하는 2가지 방법&lt;/h3&gt;

&lt;p&gt;‘언제 교대할 것인가?’를 정하는 방법은 크게 두가지로 나눌 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;협력적 멀티태스크&lt;/li&gt;
  &lt;li&gt;선점적 멀티태스크&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;협력적 멀티태스크 : ‘타이밍이 좋은 시점에서 교대하는’방법이다. 처리가 일단락되는 시점에 자발적으로 처리 교대를 하는 방법이다. 이 방법으로 구현된 멀티태스크(multi-task, 병행 처리)를 협력적 멀티태스크라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;선점적 멀티태스크 ( 일정 시간에 교대한다 ) : 개별 프로그램과 입장이 다른 프로그램(태스크 스케줄러)이 존재한다. 이 프로그램이 일정 시간마다 지금 실행되고 있는 처리를 강제적으로 중단시켜서 다른 프로그램이 실행될 수 있도록 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-66&quot;&gt;경합 상태 방지법&lt;/h3&gt;

&lt;h4 id=&quot;section-67&quot;&gt;경합 상태의 3가지 조건&lt;/h4&gt;

&lt;p&gt;평행해서 동작하고 있는 2가지 처리 간에 경합 상태가 발생하기 위해서는 다음 3가지 조건을 모두 만족해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;2가지 처리가 변수를 공유하고 있다&lt;/li&gt;
  &lt;li&gt;적어도 하나의 처리가 그 변수를 변경한다&lt;/li&gt;
  &lt;li&gt;한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 3가지 조건 중 하나라도 제거 할 수 있다면 병행 실행 시에도 안정된 프로그램을 만들 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;section-68&quot;&gt;공유하지 않는다 ( 프로세스와 액터 모델 )&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;처음부터 아무것도 공유하지 않으면 1.은 발생하지 않기 때문에 경합 상태를 신경 쓸 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-69&quot;&gt;프로세스에서는 메모리를 공유하지 않는다&lt;/h4&gt;

&lt;p&gt;UNIX에서는 실행 중의 프로그램을 ‘프로세스’라고 부른다. 서로 다른 프로세스는 메모리를 공유하지 않는다. 때문에 복수의 프로그램이 메모리 상에서 경합 상태를 일으킬 일은 없다. 데이터베이스 접속, 파일 읽고 쓰기 등 무엇인가를 공유했을때만 주의하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;section-70&quot;&gt;공유하지 않는 접근법은 성공했을까?&lt;/h4&gt;

&lt;p&gt;현재까지도 스레드를 사용해서 공유 메모리를 어떻게 다뤄야 할지 고심해가면서 프로그램이 만들어지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액터 모델 : ‘메모리를 공유하지 않는다’는 설계 방침에서의 또 다른 흐름이 바로 액터 모델이다. 1973년에 발표된 병행 처리를 위한 모델이다. ( 병행해서 동작하는 복수의 처리가 정보를 교환하는 방법으로, ‘메모리를 공유한다’가 아닌 ‘메시지를 보낸다’를 제안했다 )&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;const-val-immutable&quot;&gt;변경하지 않는다 - const, val, immutable&lt;/h4&gt;

&lt;p&gt;‘메모리를 공유해도 변경하지 않으면 문제가 없다’는 2.에 대한 대응책도 있다.&lt;/p&gt;

&lt;p&gt;이 방식을 강하게 어필하고 있는 언어로써, 모든 값이 변경 불가능한 Haskell 등을 들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-71&quot;&gt;끼어들지 않는다&lt;/h3&gt;

&lt;p&gt;경합 상태가 발생하는 조건 3.인 ‘한 쪽의 처리가 한 단락 마무리 되기 전에 다른 한 쪽의 처리가 끼어들 가능성이 있다’를 방지하기 위해서는 어떻게 하면 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;section-72&quot;&gt;협력적 스레드의 사용 - 파이버, 코루틴, 그린 스레드&lt;/h4&gt;

&lt;p&gt;파이버나 코루틴, 그린 스레드 등으로 불리는 기법을 사용하는것이 그 방법이다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;스레드가 선점성을 가지고 끼어드는 원인이 되기 때문에 협력적 스레드를 만들면 된다는 생각이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;협력적 멀티태스크이기 때문에 어떤 스레드가 CPU를 독점하면 다른 스레드의 처리가 멈춘다. 어디까지나 각 스레드가 협력적으로 최적의 순간을 맞춘다는 사실을 전제로 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-73&quot;&gt;끼어들면 곤란해지는 처리에 표식을 붙인다 - 락, 뮤텍스, 세마포어&lt;/h4&gt;

&lt;p&gt;‘지금 끼어들면 곤란해’라는 표식을 공유하는 방법이다. 예를 들어, 어떤 메모리 값이 0이 아니면 이것은 ‘다른 스레드가 끼어들면 곤란한 처리를 하고 있어’라고 정해 두는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;section-74&quot;&gt;락의 문제점과 해결책&lt;/h3&gt;

&lt;h4 id=&quot;section-75&quot;&gt;락의 문제점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;교착 상태가 발생한다&lt;/li&gt;
  &lt;li&gt;합성할 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-76&quot;&gt;트랜잭션 메모리&lt;/h4&gt;

&lt;p&gt;이 문제를 해결하려고 하는 것이 트랜잭션 메모리라는 접근법이다. 데이터베이스의 트랜잭션 기법을 메모리에 적용한 것이다. 개념은 ‘실험적으로 해보고, 실패하면 처음부터 다시 고쳐서 하고, 성공하면 변경을 공유한다’이다.&lt;/p&gt;

&lt;h3 id=&quot;section-77&quot;&gt;트랜잭션 메모리의 역사&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;하드웨어로 구현&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;1986년에 Symbolics라는 회사가 트랜잭션을 하드웨어로 구현하려는 아이디어를 제안했다. 상업적으로는 성공하지 못했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;소프트웨어로 구현&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;그 후 10년이 지난 1995년에 소프트웨어로 트랜잭션 메모리를 구현하려는 논문이 발표되었다. 그리고 10년 더 지난 후 2005년에 Microsoft가 Concurrent Haskell을 사용해서 소프트웨어적으로 트랜잭션 메모리를 실현하는 논문을 발표했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 전후로 여러 언어에 소프트웨어 트랜잭션 메모리 기능이 탑재되었다.&lt;/p&gt;

&lt;h3 id=&quot;section-78&quot;&gt;객체와 클래스&lt;/h3&gt;

&lt;h4 id=&quot;section-79&quot;&gt;객체 지향이란?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;C++ 설계자인 Bjarne Stroustrup의 경우&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;객체 지향 프로그래밍이란 사용자 정의형과 상속을 사용한 프로그래밍이다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;또한 상태를 가진 객체가 메세지를 주고 받아서 커뮤니케이션하는 프로그램이다!&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-80&quot;&gt;객체는 현실세계의 모형&lt;/h4&gt;

&lt;p&gt;현실 세계에 있는 ‘사물’의 ‘모형’을 컴퓨터 안에 만들려면 어떻게 하면 될까? 라는 의문을 해결하기 위해 ‘객체 지향’이라는 개념이 탄생했다.&lt;/p&gt;

&lt;h4 id=&quot;section-81&quot;&gt;클래스란?&lt;/h4&gt;

&lt;p&gt;C++에서는 ‘클래스는 사용자가 정의할 수 있는 형’이다.&lt;/p&gt;

&lt;p&gt;C++은 정적 형결정 언어이고 Ruby나 Python은 동적 형결정 언어다.&lt;/p&gt;

&lt;p&gt;단, Java는 예외다. ‘클래스라는 부품을 정의하고, 그것을 조립해나가는 것이 프로그래밍이다’라고 정의하고 있다. 따라서 Java에서는 클래스가 반드시 필요한 조건이다.&lt;/p&gt;

&lt;h3 id=&quot;section-82&quot;&gt;변수와 함수를 합쳐서 모형을 만드는 법&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;모듈(Module)&lt;/li&gt;
  &lt;li&gt;함수도 변수도 동일하게 해쉬에 넣는 방법&lt;/li&gt;
  &lt;li&gt;클로저(Closure)&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모듈 : 함수를 합쳐두기 위한 패키지와 변수를 합쳐두기 위한 해쉬를 연결하는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수도 변수도 동일하게 해쉬에 넣는 방법 : JavaScript등의 언어가 채용하고 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클로저 : 함수 실행 시의 이름 공간의 변수를 하나로 묶기 위해 사용하는 방법이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-83&quot;&gt;모듈, 패키지&lt;/h3&gt;

&lt;h4 id=&quot;section-84&quot;&gt;모듈, 패키지란 무엇인가?&lt;/h4&gt;

&lt;p&gt;‘관련성이 높은 함수나 변수의 묶음’이다.&lt;/p&gt;

&lt;p&gt;모듈은 ‘하나로 모으는 기법’이다.&lt;/p&gt;

&lt;p&gt;Python이나 Ruby는 ‘모듈’이라 하고, Java나 Perl에서는 ‘패키지’라는 이름으로 부른다&lt;/p&gt;

&lt;h4 id=&quot;perl---&quot;&gt;Perl 패키지로 객체를 만든다&lt;/h4&gt;

&lt;p&gt;Perl 패키지는 함수나 변수를 하나로 묶어서 그것에 이름을 붙일 수 있는 기능이다.&lt;/p&gt;

&lt;p&gt;하지만&lt;/p&gt;

&lt;p&gt;&lt;em&gt;모듈만으로는 부족하다&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-85&quot;&gt;인수로 개별 해쉬를 전달한다&lt;/h4&gt;

&lt;p&gt;Perl에는 사전을 만드는 기능이 언어 처리계 자체에 탑재되어 있다. Perl은 이것은 ‘해쉬’라고 부른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해쉬는 함수를 호출 할 때 해쉬를 인수로 전달한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-86&quot;&gt;초기화 처리도 패키지에 넣는다&lt;/h4&gt;

&lt;p&gt;새로운 카운터를 만들 때는 프로그래머가 직접 명시를 해줘야만 한다. 값을 어떻게 초기화할지를사람이 기억하지 않으면 안되는 것이다. 이것은 좋지 않은 설계다. 이런 경우는 ‘초기화 방법’을 함수로 만들어서 패키지에 넣으면 된다.&lt;/p&gt;

&lt;h4 id=&quot;section-87&quot;&gt;해쉬와 패키지를 연결한다&lt;/h4&gt;

&lt;p&gt;데이터 저장소와 해당 데이터에 대응하는 동작의 집합(모듈)을 연결시킴으로 하나의 묶음으로 정리된 이해하기 쉬운 코드를 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-88&quot;&gt;함수도 해쉬에 넣을 수 있다!&lt;/h3&gt;

&lt;h4 id=&quot;section-89&quot;&gt;퍼스트 클래스&lt;/h4&gt;

&lt;p&gt;JavaScript가 도입하고 있는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;‘변수에 대입한다’, ‘함수의 인수로 전달한다’, ‘함수의 반환값으로 전달한다’ 등이 가능한 값을 ‘퍼스트 클래스값’이라고 부른다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;차별 대상이 아닌 일급 시민을 의미한 표현이다. 최근의 언어 Java나 Perl, Python 등에서 문자열은 퍼스트 클래스 값이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;JavaScript에서는 함수도 퍼스트 클래스 값이다. 함수를 변수에 대입하거나 함수의 반환값으로 전달하는 것도 가능하다&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-90&quot;&gt;복수 개 카운터를 만든다&lt;/h4&gt;

&lt;p&gt;카운터를 손쉽게 복수 개 만들기 위해서 해쉬로 초기화하기 위한 함수를 만들면 아주 간단하게 만들 수 있다. 단순히 해쉬를 makeCounter 안으로 이동하기만 하면 된다.&lt;/p&gt;

&lt;p&gt;Perl 패키지와 동일하게 다음 이점들을 가지게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;복수 객체를 만들 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나의 묶음으로 보인다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;초기화 방법을 사람이 기억하지 않아도 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-91&quot;&gt;클로저&lt;/h3&gt;

&lt;h4 id=&quot;section-92&quot;&gt;클로저란?&lt;/h4&gt;

&lt;p&gt;이것은 객체적인 것을 만들기 위한 기술이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클로저라는 특수한 구문이 있는 것은 아니다. 함수를 함수 안에 정의하고, 내포할 수 있는 정적 스코프가 있어서 함수를 반환값으로 사용하거나 변수에 대입하여 사용한다는 개념이다. 즉, 간단한 내포 구조를 사용함으로 상태 정보를 가진 함수를 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-93&quot;&gt;왜 클로저라고 부를까?&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;왜 이것을 클로저라고 부를까? 그것은 자유 변수를 포함한 식을 ‘열린 식’이라고 부르고, 그 자유 변수의 바인딩을 조합함으로 해당 식을 닫고 있기 때문이다.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-94&quot;&gt;클래스&lt;/h3&gt;

&lt;p&gt;언어 설계자가 ‘이 언어에서는 이것을 클래스라고 부른다’고 정한 것으로, 다양한 정의가 존재한다.&lt;/p&gt;

&lt;h4 id=&quot;hoare--&quot;&gt;Hoare가 생각한 클래스&lt;/h4&gt;

&lt;p&gt;‘현실 세계의 사물(object)은 편의상 상호 배타적 종류(classes)로 분류될 수 있다’고 기술하고 있다. 그리고 ‘어떤 종류의 사물을 더욱 세분화된 종류(subclasses)로 분류할 수 있으면 편리하다’고 주장하고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;처음 시작은 ‘분류’였던 것이다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;현재 사용되고 있는 ‘클래스를 상속한다’, ‘클래스는 인스턴스다’라는 개념이 등장한것은 보다 나중의 이야기다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;c-&quot;&gt;C++ 클래스&lt;/h4&gt;

&lt;p&gt;클래스는 타입(type)이다. 이것이 C++을 이루는 아주 중요한 원리다. C++에서 class가 사용자 정의 타입을 의미한다면 왜 그것을 type이라고 부르지 않는가? 내가 class를 선택한 것은 계속 나오는 새로운 용어를 발명하는 것이 귀찮았기 때문이고, Simula의 class라면 아무도 당황하지 않을 것이라 판단했기 때문이다. - « C++로 배우는 프로그래밍의 원리와 설계 »&lt;/p&gt;

&lt;h4 id=&quot;section-95&quot;&gt;사양으로서 역할&lt;/h4&gt;

&lt;p&gt;C++에게 있어서 클래스(=형)란 사양을 표명한 것이기도 했다. 즉, 클래스는 ‘객체가 어떤 메소드를 갖고 있고, 어떤 메소드를 갖고 있지 않은가’라는 사양을 선언하는 역할도 했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;그 메세지를 받은 객체가 어떤 동작(무언가를 실행할지, 에러처리할지 아니면 무시할 것인지)을 할지는 수신 객체가 자유롭게 결정 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-96&quot;&gt;클래스의 3가지 역할&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;결합체를 만드는 생성기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 조작이 가능한지에 대한 사양&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드를 재사용하는 단위&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;객체 지향은 현실세계의 사물 모형을 만들기 위해 만들어졌고, 언어마다 구현 방법이나 ‘객체 지향’이 의미하느 바가 다르다!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-97&quot;&gt;상속을 통한 재사용&lt;/h3&gt;

&lt;h4 id=&quot;section-98&quot;&gt;상속이란?&lt;/h4&gt;

&lt;p&gt;어떤 클래스에서 선언된 것은 그것을 세분화한 ‘자식 클래스’에게도 자동으로 이어지는 게 좋다. 이것이 ‘상속’이다!!!&lt;/p&gt;

&lt;h4 id=&quot;section-99&quot;&gt;상속에 관한 다양한 접근법&lt;/h4&gt;

&lt;p&gt;상속은 크게 3가지 측면으로 접근할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;일반화/특수화&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공통 부분을 추출&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;차분 구현&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;일반화/특수화 : ‘부모 클래스로 일반적인 기능을 구현하고, 자식 클래스로 목적에 특화된 기능을 구현한다’는 접근이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공통 부분을 추출 : ‘복수 클래스의 공통 부분을 부모 클래스로서 추출하면 좋다’는 접근법이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;차분 구현 : ‘상속 후 변경된 부분만 구현하면 효율이 좋다’는 접근법이다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-100&quot;&gt;상속은 양날의 칼&lt;/h4&gt;

&lt;p&gt;‘상속을 많이 사용하면 코드가 복잡해진다. 제어를 추가해야 한다’는 의견이 나오고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상속을 반복하면, 코드 영향 범위가 넓어져서 이해하기 어렵게 된다. 이해하기 쉽게 하기 위해서는 상속 트리의 깊이를 낮추는 것이 중요하다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-101&quot;&gt;리스코프의 치환 원칙&lt;/h4&gt;

&lt;p&gt;CLU라는 언어의 설계자인 Liskov가 1987년에 제창한 것으로, 현재는 자식 클래스를 만들 때 주의해야 할 사항으로 자주 언급되는 것이 ‘리스코프의 치환 원칙’이다.&lt;/p&gt;

&lt;h3 id=&quot;section-102&quot;&gt;다중 상속&lt;/h3&gt;

&lt;h4 id=&quot;section-103&quot;&gt;하나의 사물을 복수로 분류&lt;/h4&gt;

&lt;p&gt;현실세계에서 하나의 사물이 복수의 분류에 해당하는 경우가 있기 때문에 그것을 모델화하는 프로그래밍 언어가 복수의 클래스를 상속할 수 있어야 한다. 이것이 다중 상속이다.&lt;/p&gt;

&lt;h4 id=&quot;section-104&quot;&gt;코드 재사용에 편리한 다중 상속&lt;/h4&gt;

&lt;p&gt;다중 상속은 코드 재사용 방법으로도 매우 좋은 도구다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다중 상속이 가능한 언어에서는 단순히 양쪽 클래스를 상속하기만 하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-105&quot;&gt;다중 상속의 문제점 - 거듭되는 충돌&lt;/h3&gt;

&lt;p&gt;다중 상속은 편리한 기능이다. 그런데 다중 상속은 어떻게 메소드의 이름을 해결하고 있는 걸까? 클래스에게 ‘x의 값은 무엇인가?’라고 물으면 어떻게 대답할까? 이름해결의 문제가 발생한다.&lt;/p&gt;

&lt;h4 id=&quot;section-106&quot;&gt;해결책 1: 다중 상속을 금지한다&lt;/h4&gt;

&lt;p&gt;Java는 클래스 다중 상속을 금지하기로 했다. 클래스 다중 상속을 인정하지 않으면 앞의 경우와 같은 문제가 발생하지 않는다. 다중 상속을 버림으로 문제를 해결했지만, 대신 다중 상속의 편리함 또한 버리게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위임 : 사용하고 싶은 코드를 가지고 있는 클래스 객체를 만들고, 필요에 따라 해당 클래스에 처리를 맡기는 방법이다. 상속을 사용해서 형이나 이름 공간까지 함께 계승하는 것이 문제의 원인이기 때문에, 단순히 객체를 보유하기만 하면 문제를 막을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인터페이스 : Java는 다중 상속을 금지하고 있다고 설명했지만, Java에도 다중 상속이 가능한 것이 있다. 바로 인터페이스 이다. 인터페이스는 ‘코드를 가지고 있지 않는 클래스’다. ‘인터페이스를 상속한 클래스는 반드시 xx라는 이름의 메소드를 가지고 있다’라는 ‘사양’만 가지고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-107&quot;&gt;해결책 2: 메소드 해결 순서를 고민한다&lt;/h4&gt;

&lt;p&gt;‘자신이 모른다면 앞에 쓰여있는 부모부터 순서대로 확인한다’는 규칙(깊이 우선 탐색)으로 해결될까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;깊이 우선 탐색의 문제점 : 어떤 클래스 Base를 복수의 클래스 derived1, derived2가 상속하고 있다고 하자. 그리고 이 두 클래스를 상속하는 Multi가 있다고 하자. 이 같은 형태의 다중 상속을 ‘마름모 상속’이라고 부른다. 메소드가 재정의(오버라이드)되는 경우가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C3 선형화로 순서를 정한다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;C3 선형화는 1996년에 제안된 알고리즘으로, 2가지 제약 조건을 만족하도록 클래스에 순서를 매겨서 정렬한다. 그 제약 조건은 다음과 같다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;부모 클래스는 자식 클래스보다 먼저 탐색되지 않는다.&lt;/li&gt;
          &lt;li&gt;어떤 클래스가 복수의 부모 클래스를 상속하고 있으면 먼저 만들어진 것이 우선된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-108&quot;&gt;해결책 3: 처리를 섞는다&lt;/h4&gt;

&lt;p&gt;어떤 클래스는 선조 클래스까지 도달하는 경로가 여러 개 있는 것이 문제다. 그렇다면 재사용하고 싶은 기능만을 모은 작은 클래스를 만들어서 해당 기능을 추가하고 싶은 클래스에 섞어 넣으면 된다. 이런 설계 방침이나 섞어 넣는 것, 그리고 섞기 위한 작은 클래스를 믹스-인(Mix-in)이라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-109&quot;&gt;해결책 4: 트레이트&lt;/h4&gt;

&lt;p&gt;클래스가 ‘인스턴스를 만들기 위한 것’으로 사용될 때는 재사용 단위로 너무 크다. 그러면 재사용 단위라는 역할에 특화된 보다 작은 구조(트레이트 = 메소드 묶음)를 만드는 것이 좋다. 이것이 트레이트 개념이다.&lt;/p&gt;

</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/base.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/base.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Flask Heroku(배포)</title>
        <description>&lt;h2 id=&quot;flasky&quot;&gt;flasky&lt;/h2&gt;

&lt;h3 id=&quot;deploy-&quot;&gt;deploy 과정&lt;/h3&gt;

&lt;p&gt;태스크를 애플리케이션이 설치될 때나 업그레이드될 때 수동으로 실행하면 에러에 취약하고 시간 소모적인 작업이 된다. 따라서 필요한 모든 태스크를 실행하는 커맨드를 manage.py에 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) 17-1&lt;/em&gt; manage.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def deploy():
	&quot;&quot;&quot;Run deployment tasks.&quot;&quot;&quot;
	from flask.ext.migrate import upgrade
	from app.models import Role, User
	
	# migrate database to latest revision
	upgrade()
	
	# create user roles
	Role.insert_roles()
	
	# create self-follows for all users
	User.add_self_follows()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 커맨드에 의해 실행될 함수는 이전에 모두 생성되었으며 일괄적으로 함께 호출된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;업데이트 함수를 설계함으로써 설치나 업그레이드가 실행될 때마다 deploy 커맨드를 실행하는 것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;제품화 과정 중의 에러에 대한 로그&lt;/h3&gt;

&lt;p&gt;디버거는 개발 중에 애플리케이션 문제점들을 디버그하기 위한 훌륭한 툴이지만 제품화 배포에서는 사용할 수 없다. 제품화에서 발생한 에러는 숨겨져 있으며 사용자들은 단지 코드 500 에러 페이지만을 받게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 에러의 스택 트레이스를 완전히 잃어 버리지는 않는다. 플라스크가 그 에러를 로그 파일(log file)에 작성하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시작하는 동안에 플라스크는 Python의 logging.Logger 클래스의 인스턴스를 생성하고 그것을 애플리케이션 인스턴스의 app.logger로 붙인다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이 로거는 디버그 모드에서는 콘솔에 작성하지만 제품화 모드에서는 기본적으로 이것을 설정하는 핸들러가 없다. 따라서 핸들러에 로그가 추가되어야 저장이 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-2&lt;/em&gt; config.py : 애플리케이션 에러에 대해 이메일 전송&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ProductionConfig(Config):
	# ...
	@classmethod
	def init_app(cls, app):
		Config.init_app(app)
		
		# email errors to the administrators
		import logging
		from logging.handlers import SMTPHandler
		credentials = None
		secure = None
		if getattr(cls, 'MAIL_USERNAME', None) is not None:
			credentials = (cls.MAIL_USERNAME, cls.MAIL_PASSWORD)
			if getattr(cls, 'MAIL_USE_TLS', None):
				secure = ()
	mail_handler = SMTPHandler(
		mailhost=(cls.MAIL_SERVER, cls.MAIL_PORT),
		fromaddr=cls.FLASKY_MAIL_SENDER,
		toaddrs=[cls.FLASKY_ADMIN],
		subject=cls.FLASKY_MAIL_SUBJECT_PREFIX + ' Application Error',
		credentials=credentials,
		secure=secure)
	mail_handler.setLevel(logging.ERROR)
	app.logger.addHandler(mail_handler)
		
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이러한 변경 사항은 제품화 모드에서 실행하는 동안 발생하는 에러를 FLASKY_ADMIN에 세팅에 설정되어 있는 관리자 리스트의 이메일로 전송하도록 로깅 핸들러를 설정한다.&lt;/p&gt;

&lt;h4 id=&quot;createapp---initapp------&quot;&gt;모든 설정 인스턴스가 &lt;code class=&quot;highlighter-rouge&quot;&gt;create_app()&lt;/code&gt;에 의해 호출되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;init_app()&lt;/code&gt; 정적 메소드를 갖고 있다는 것을 기억하자!!!&lt;/h4&gt;

&lt;p&gt;ProductionConfig 클래스를 위한 이 메소드의 구현에서 애플리케이션 로거는 이메일 로거로 로그 에러를 설정하도록 되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이메일 로거의 로그 레벨은 logging.ERROR로 설정된다. 따라서 단지 심각한 문제만 이메일로 전송된다. 덜 심각한 레벨로 로깅된 메세지는 파일, syslog 혹은 적절한 로깅 핸들러를 추가하여 지원하는 다른 메소드를 사용하여 로그된다. 이러한 메시지를 위해 사용되는 로깅 메소드는 호스팅 플랫폼에 상당히 의존적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;클라우드 배포&lt;/h2&gt;

&lt;p&gt;가장 최근의 트렌드는 “클라우드”로 호스팅하는 것이다. 이 기술은 애플리케이션 개발자들을 애플리케이션이 실행하게 될 하드웨어와 소프트웨어 플랫폼에 따라 설치와 유지 보수를 해야 하는 기존의 태스크로부터 해방시켜 준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤로쿠(Heroku)는 가장 유명한 PaaS 프로바이더이며 파이썬을 지원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;헤로쿠 플랫폼&lt;/h2&gt;

&lt;p&gt;헤로쿠는 2007년부터 비즈니스를 시작했다. 헤로쿠 플랫폼은 유연성이 뛰어나며 다양한 프로그래밍 언어를 지원한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션을 헤로쿠에 배포하기 위해서는 개발자가 Git을 사용하여 애플리케이션을 헤로쿠의 Git 서버에 푸시한다. 서버에서는 git push 커맨드가 자동으로 설치, 설정, 배포를 트리거한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;애플리케이션의 준비&lt;/h3&gt;

&lt;p&gt;헤로쿠에서 작업하기 위해서는 애플리케이션이 Git 저장소에 호스트되어야 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;헤로쿠 계정의 생성&lt;/h4&gt;

&lt;h4 id=&quot;section-5&quot;&gt;헤로쿠 툴벨트의 설치&lt;/h4&gt;

&lt;p&gt;헤로쿠 애플리케이션을 관리하는 가장 간편한 방법은 헤로쿠 툴벨트(Toolbelt) 커맨드 라인 유틸리티를 이용하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;툴벨트는 두 개의 헤로쿠 애플리케이션으로 구성되어 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;heroku : 헤로쿠 클라이언트이며, 애플리케이션을 생성하고 관리하는 데 사용된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;foreman : 컴퓨터에 테스트할 목적으로 헤로쿠 환경을 시뮬레이션하는 툴이다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;헤로쿠 클라이언트 유틸리티는 서비스에 연결하기 전에 헤로쿠 계정 자격증을 갖고 있어야 한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) heroku login command&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku login 
Enter your Heroku credentials.
Email: &amp;lt;your-email-address&amp;gt;
Password (typing will be hidden): &amp;lt;your-password&amp;gt;
Uploading ssh public key .../id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다음 단계는 헤로쿠 클라이언트를 사용하여 애플리케이션을 생성하는 것이다.&lt;/p&gt;

&lt;p&gt;이 작업을 하기 위해, 먼저 애플리케이션이 Git 소스 컨트롤에 있는지 확인한 후에 최상위 디렉토리에서 다음의 커맨드를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku create &amp;lt;appname&amp;gt;
Creating &amp;lt;appname&amp;gt;...done, stack is cedar
http://&amp;lt;appname&amp;gt;.herokuapp.com/ | git@heroku.com:&amp;lt;appname&amp;gt;.git
Git remote heroku addred
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;헤로쿠 애플리케이션 이름은 반드시 고유의 이름이어야 하므로 다른 애플리케이션에서 사용하지 않은 이름을 찾아야 한다. create 커맨트의 결과에서 볼 수 있는 것처럼 한 번 배포된 애플리케이션은 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://&amp;lt;appname&amp;gt;.herokuapp.com&lt;/code&gt;에서 사용 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;커스텀 도메인 이름 역시 애플리케이션에 붙일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;git--&quot;&gt;애플리케이션 생성의 부분으로 헤로쿠는 Git 서버를 할당한다&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git@heroku.com:&amp;lt;appname&amp;gt;.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;create 커맨드는 이 서버를 로컬 Git 저장소에 heroku라는 이름을 가진 git remote인 것처럼 추가한다.&lt;/p&gt;

&lt;h4 id=&quot;provisioning&quot;&gt;데이터베이스의 프로비저닝(provisioning)&lt;/h4&gt;

&lt;p&gt;헤로쿠는 Postgre 데이터베이스를 애드온으로 지원한다. 약 10,000개 정도의 행을 갖는 작은 데이터베이스를 무료로 애플리케이션에 추가할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku addons:add heroku-postgresql:dev
Adding heroku-postgresql:dev on &amp;lt;appname&amp;gt;... done, v3 (free)
Attached as HEROKU_POSTGRESQL_BROWN_URL
Database has been created and is available
 ! This database is empty. If upgrading, you can transfer
 ! data from another database with pgbackups:restore.
Use 'heroku addons:docs heroku-postgresql:dev' to view documentation.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HEROKU_POSTGRESQL_BROWN_URL&lt;/code&gt; 레퍼런스는 데이터베이스 URL을 갖고 있는 환경 변수의 이름이다. 이 작업을 하려고 할 때 브라운(brown)과는 다른 컬러를 얻을 수 있다. 헤로쿠는 애플리케이션당 다중 데이터베이스를 지원하며 각각은 URL에서 다른 컬러로 보인다. 데이터베이스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt; 환경 변수에 자신의 URL을 포함시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음 커맨드는 브라운 컬러의 데이터베이스에 대한 처리를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku pg:promote HEROKU_POSTGRESQL_BROWN_URL
Promoting HEROKU_POSTGRESQL_BROWN_URL to DATABASE_URL... done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt; 환경 변수의 포맷은 정확하게 SQLAlchemy에서 필요한 것과 동일하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정의해 둔 것이 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt;의 값을 사용하는 config.py 스크립트를 기억하자. Postgre 데이터베이스에 대한 연결은 이제 자동으로 진행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;로깅 설정&lt;/h4&gt;

&lt;p&gt;로깅 설정은 &lt;code class=&quot;highlighter-rouge&quot;&gt;init_app()&lt;/code&gt; 정적 메소드에 있는 ProductionConfig 클래스에 추가되지만 이러한 타입의 로깅은 헤로쿠에만 적용되기 때문에 새로운 설정이 플랫폼에 따라 생성될 수 있다. 다른 타입의 제품 플랫폼을 위한 기본 설정으로 ProductionConfig는 남겨둔다. HerokuConfig 클래스는 다음 예와 같다&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) 17-3. config.py : 헤로쿠 설정&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HerokuConfig(ProductionConfig):
	@classmethod
	def init_app(cls, app):
		ProductionConfig.init_app(app)
		
		# log to stderr
		import logging
		from logging import StreamHandler
		file_handler = StreamHandler()
		file_handler.setLevel(logging.WARNING)
		app.logger.addHandler(file_handler)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;애플리케이션을 헤로쿠에 의해 실행하면, 사용해야 할 설정을 알아야 한다. manage.py에서 생성된 애플리케이션 인스턴스는 FLASK_CONFIG 환경 변수로 어떤 설정을 사용해야 할 지 알게되며, 따라서 이 변수는 헤로쿠 환경에 설정되어야 한다. 환경 변수는 헤로쿠 클라이언트의 config:set 커맨드를 사용하여 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku config:set FLASK_CONFIG=heroku
Setting config vars and restarting &amp;lt;appname&amp;gt;... done, v4
FLASK_CONFIG: heroku
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;이메일 설정&lt;/h4&gt;

&lt;p&gt;헤로쿠는 SMTP 서버를 제공하지 않으므로 외부 서버를 설정해 줘야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스크립트에 로그인 자격 내용을 직접 포함시키게 되면 보안 위험이 있을 수 있기 때문에 지메일 SMTP에 액세스하기 위한 사용자 이름과 패스워드는 다음과 같이 환경변수를 통해 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku config:set MAIL_USERNAME=&amp;lt;your-gmail-username&amp;gt;
$ heroku config:set MAIL_PASSWORD=&amp;lt;your-gmail-password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;제품 웹 서버의 실행&lt;/h4&gt;

&lt;p&gt;헤로쿠는 애플리케이션을 위한 호스트 목적의 웹 서버를 제공하지 않는다. 대신에 애플리케이션이 자신의 서버를 시작하고 환경 변수 PORT에 설정된 포트 번호에서 리스닝할 수 있도록 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;플라스크를 사용한 개발 웹 서버는 성능이 매우 좋지 않다. 제품 환경에서 실행되도록 설계된 것이 아니기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;플라스크 애플리케이션을 잘 동작시키는 제품화 준비를 마친 두 개의 웹 서버는 구니콘(Gunicorn)과 uWSGI다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구니콘은 다음과 같이 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(venv) $ pip install gunicorn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;구니콘에서 애플리케이션을 실행하려면 다음 커맨드를 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(venv) $ gunicorn manage:app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;구니콘은 포트 8000을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;필요 파일의 추가&lt;/h4&gt;

&lt;p&gt;헤로쿠는 최상위 폴더에 저장된 requirements.txt 파일에서 패키지 의존성을 로드한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;psycopg2&lt;/strong&gt; 패키지는 Postgre 데이터베이스와 구니콘 웹 서버 지원을 할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) 17-4. requirements.txt : 헤로쿠 필요 파일&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-r requirements/prod.txt
gunicorn==18.0
psycopg2==2.5.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;procfile-&quot;&gt;Procfile의 추가&lt;/h4&gt;

&lt;p&gt;헤로쿠는 애플리케이션을 시작하기 위해 사용하는 커맨드가 무엇인지 알고 있어야 한다. 이 커맨드는 &lt;strong&gt;Procfile&lt;/strong&gt;이라고 하는 특정 파일에 작성되어 있다. 이 파일은 애플리케이션 최상위 폴더에 추가되어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 이파일의 콘텐츠를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-5. Procfile : 헤로쿠 Procfile&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;web: gunicorn manage:app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Procfile의 포맷은 매우 간단하다. 각 라인에는 태스크 이름이 있고, 그 다음에는 콜론, 그 다음에는 태스크를 실행하는 명령어가 온다.&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;포맨을 이용한 테스트&lt;/h2&gt;

&lt;p&gt;헤로쿠 툴벨트는 &lt;strong&gt;포맨(Foreman)&lt;/strong&gt;이라는 두 번째 유틸리티를 포함하고 있다. 이 유틸리티는 테스트 목적으로 Procfile을 통해 애플리케이션을 로컬로 실행하는 데 사용된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포맨은 애플리케이션의 최상위 디렉토리에 있는 &lt;strong&gt;.env&lt;/strong&gt;라는 이름의 파일에서 환경변수들을 찾는다. 예를들어, &lt;strong&gt;.env&lt;/strong&gt; 파일은 다음과 같은 변수들을 포함하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FLASK_CONFIG=heroku
MAIL_USERNAME=&amp;lt;your-username&amp;gt;
MAIL_PASSWORD=&amp;lt;your-password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;.env 파일은 패스워드와 다른 민감한 계정 정보를 포함하고 있기 때문에 Git 저장소에는 절대 추가해서는 안된다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;포맨의 주요한 두 개의 옵션은 foreman run 과 foreman start다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;run 커맨드는 애플리케이션 환경에서 커맨드를 실행할 때 사용되고, deploy 커맨드는 애플리케이션에서 데이터베이스를 생성할 때 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;start 커맨드는 Procfile이 필요하며 그 안에 있는 모든 태스크를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(venv) $ foreman start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;flask-sslify---http-&quot;&gt;Flask-SSLify를 이용한 보안 HTTP의 활성화&lt;/h2&gt;

&lt;p&gt;헤로쿠는 헤로쿠 내의 SSL 인증을 사용하는 설정 없이도 모든 애플리케이션이 &lt;strong&gt;http://&lt;/strong&gt;와 &lt;strong&gt;https://&lt;/strong&gt; 모두에서 가능한 &lt;strong&gt;herokuapp.com&lt;/strong&gt; 도메인을 액세스하도록 해 준다. 이때 필요한 유일한 작업은 애플리케이션이 &lt;strong&gt;http://&lt;/strong&gt; 인터페이스로 전송하는 리퀘스트를 가로채는 것과 그것을 &lt;strong&gt;https://&lt;/strong&gt;로 리다이렉트하는 것이다. 그리고 이것은 Flask-SSLify 확장이 하는 작업이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 확장은 requirements.txt 파일에 추가되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-6. &lt;code class=&quot;highlighter-rouge&quot;&gt;app/__init__.py&lt;/code&gt; : 모든 리퀘스트를 보안 HTTP로 리다이렉트&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def create_app(config_name):
	# ...
	if not app.debug and not app.testing and not app.config['SSL_DISABLE']:
		from flask.ext.sslify import SSLify
		sslify = SSLify(app)
	# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;ex) 17-7. config.py : SSL의 사용 설정&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Config:
	# ...
	SSL_DISABLE = True
	
class HerokuConfig(ProductionConfig):
	# ...
	SSL_DISABLE = bool(os.environ.get('SSL_DISABLE'))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;환경변수가 비어 있는 문자열 대신에 다른 것으로 설정되면, 불린으로의 변경은 True를 리턴하며 SSL은 비활성화 된다. 환경변수가 존재하지 않거나 비어 있는 문자열로 설정되면, 불린으로의 변경은 False가 된다. 포맨을 사용할 때 SSL이 활성화되는 것을 막기 위해서는 &lt;strong&gt;.env&lt;/strong&gt; 파일에 SSL_DISABLE=1을 추가해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;헤로쿠를 사용할 때 클라이언트는 호스트한 애플리케이션을 직접 연결하지 않으며 &lt;strong&gt;리버스 프록시 서버(reverse proxy server)&lt;/strong&gt;에 연결한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리버스 프록시 서버는 애플리케이션에 리퀘스트를 리다이렉트한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프록시 서버는 클라이언트로부터 받은 원래의 리퀘스트를 커스텀 HTTP 헤더를 통해 리다이렉트된 웹 서버에 전송하도록 작성된 정보를 넘긴다. 따라서 사용자가 이러한 정보를 바탕으로 SSL을 통해 애플리케이션과 통신할지를 결정할 수 있다.&lt;/p&gt;

&lt;p&gt;Werkzeug는 WSGI &lt;strong&gt;미들웨어&lt;/strong&gt;를 제공하는데, 이 미들웨어는 프록시 서버로부터의 커스텀 헤더를 체크하고 그에 맞는 리퀘스트 오브젝트를 업데이트한다. 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;request.is_secure&lt;/code&gt;는 클라이언트가 리버스 프록시 서버에게 전송하는 리퀘스트의 보안성을 반영하며 프록시 서버가 애플리케이션에 전송하는 리퀘스트는 반영하지 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 애플리케이션에 ProxyFix 미들웨어를 추가하는 방법을 보여준다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-8. config.py : 프록시 서버의 지원&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HerokuConfig(ProductionConfig):
	# ...
	@classmethod
	def init_app(cls, app):
		# ...
		
		# handler proxy server headers
		from werkzeug.contrib.fixers import ProxyFix
		app.wsgi_app = ProxyFix(app.wsgi_app)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-push--&quot;&gt;Git push를 이용한 배포&lt;/h2&gt;

&lt;p&gt;모든 변경 사항이 로컬 Git 저장소에 커밋된 것을 확인한 후에 git push master를 사용하여 애플리케이션을 heroku 리모트에 업로드한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이제 애플리케이션이 배포되고 실행된다. 그러나 이 과정이 정상적으로 진행된것 같지는 않다. 그 이유는 deploy 커맨드를 아직 실행하지 않았기 때문이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku run python manage.py deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 베이스 테이블이 생성되고 설정된 후에, 애플리케이션은 깔끔하게 시작하기 위해 재시작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;애플리케이션은 이제 배포되었고 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;https://&amp;lt;appname&amp;gt;.herokuapp.com&lt;/code&gt;&lt;/strong&gt;에서 액세스가 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;로그 검토&lt;/h2&gt;

&lt;p&gt;애플리케이션에서 생성한 로그 출력은 헤로쿠에서 캡쳐 할 수 있다. 로그 내용을 보기 위해서는 logs 커맨드를 사용한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku logs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;테스트를 하는 동안 로그 파일의 가장 최신 내용을 보는 것이 편리하며 다음과 같이 작업한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku logs -t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-12&quot;&gt;배포와 업그레이드&lt;/h2&gt;

&lt;p&gt;헤로쿠 애플리케이션은 반복되어야 하는 동일한 프로세스를 업그레이드해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku maintenance:on
$ git push heroku master
$ heroku run python manage.py deploy
$ heroku restart
$ heroku maintenance:off
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;maintanence 옵션은 업그레이드가 진행되는 동안 애플리케이션을 오프라인에서 사용하게 하며 사이트가 재개될 것이라는 정보를 사용자에게 알려주는 정적 페이지를 보여주게 된다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/flask/2017/11/27/flask.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/flask/2017/11/27/flask.html</guid>
        
        <category>Flasky</category>
        
        
        <category>Flask</category>
        
      </item>
    
  </channel>
</rss>
