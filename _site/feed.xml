<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yoonkh blog</title>
    <description>back-end Developer
</description>
    <link>http://yoonkh.github.io/</link>
    <atom:link href="http://yoonkh.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 29 Nov 2017 18:03:08 +0900</pubDate>
    <lastBuildDate>Wed, 29 Nov 2017 18:03:08 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Jump to Python</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;파이썬이란?&lt;/h1&gt;

&lt;p&gt;파이썬(Python)은 1990년 암스테르담의 귀도 반 로섬이 개발한 인터프리터 언어이다. 귀도는 파이썬이라는 이름을 자신이 좋아하는 코미디 쇼인 “몬티 파이썬의 날아다니는 서커스”에서 따왔다고 한다. 파이썬의 사전적인 의미는 고대신화에 나오는 파르나소스 산의 동굴에 살던 큰 뱀을 뜻하며, 아폴로 신이 델파이에서 파이썬을 퇴치했다는 이야기가 전해진다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;파이썬의 특징&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;파이썬은 인간다운 언어이다&lt;/h3&gt;

&lt;p&gt;프로그래밍이란 인간이 생각하는 것을 컴퓨터에 지시하는 행위라고 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬은 사람이 생각하는 방식을 그대로 표현할 수 있는 언어이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음의 소스코드는&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if 4 in [1,2,3,4]: print(&quot;4가 있습니다&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;“만약 4가 1,2,3,4중에 있으면 “4 가 있습니다”를 출력한다.”로 해석하여 읽을 수 있다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;파이썬은 간결하다&lt;/h2&gt;

&lt;p&gt;귀도는 파이썬을 의도적으로 간결하게 만들었다. 만약 펄(Perl)과 같은 프로그래밍 언어가 100가지 방법으로 하나의 일을 처리할 수 있다면 파이썬은 가장 좋은 방법 1가지만 이용하는 것을 선호한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# simple.py
languages = ['python', 'perl', 'c', 'java']

for lang in languages:
    if lang in ['python', 'perl']:
        print(&quot;%6s need interpreter&quot; % lang)
    elif lang in ['c', 'java']:
        print(&quot;%6s need compiler&quot; % lang)
    else:
        print(&quot;should not reach here&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드는 프로그래밍 언어를 판별하여 그에 맞는 문장을 출력하는 파이썬 프로그램 코드이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬 프로그램은 줄을 맞추지 않으면 실행이 되지 않는다.&lt;/li&gt;
  &lt;li&gt;줄을 맞추어 코드를 작성하는 행위는 가독성에 크게 도움이 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;파이썬은 개발 속도가 빠르다&lt;/h2&gt;

&lt;p&gt;“Life is too short, You need python”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인생은 너무 짧으니 파이썬이 필요해!!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;파이썬으로 무엇을 할 수 있을까?&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;파이썬으로 할 수 있는 일&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-7&quot;&gt;시스템 유틸리티 제작&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;gui-&quot;&gt;GUI 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;cc-&quot;&gt;C/C++와의 결합&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-8&quot;&gt;웹프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-9&quot;&gt;수치 연산 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-10&quot;&gt;데이터 베이스 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-11&quot;&gt;데이터 분석, 사물 인터넷&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-12&quot;&gt;파이썬으로 할 수 없는일&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-13&quot;&gt;시스템과 밀접한 프로그래밍 영역&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;section-14&quot;&gt;모바일 프로그래밍&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;파이썬 기초 실습&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;대화형 인터프리터는 파이썬 쉘(Python shell)이라고도 한다. 3개의 꺾은 괄호(»&amp;gt;)는 프롬프트(prompt)라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-16&quot;&gt;파이썬 기초 문법 따라하기&lt;/h2&gt;

&lt;h4 id=&quot;section-17&quot;&gt;사칙 연산&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;1 더하기(+)2는 3이라는 값을 출력해보자!. 보통 계산기 사용하듯 더하기 기호만 넣어주면 된다!&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 1 + 2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;나눗셈(/)과 곱셈(*) 역시 예상한 대로 결과값을 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 3 / 2.4
1.25
&amp;gt;&amp;gt;&amp;gt; 3 * 9
27
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;우리가 일반적으로 알고 있는 ÷ 기호나 × 기호가 아닌 것에 주의!!&lt;/p&gt;

&lt;h4 id=&quot;section-18&quot;&gt;변수에 숫자 대입하고 계산하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = 2
&amp;gt;&amp;gt;&amp;gt; a + b
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;a에 1을, b에 2를 대입한 다음 a와 b를 더하면 3이라는 결과값을 보여준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;파이썬은 대소문자를 구분한다. print를 PRINT로 쓰면 정의되지 않았다는 에러 메세지가 나온다&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;if&quot;&gt;조건문 if&lt;/h4&gt;

&lt;p&gt;다음은 조건문 if를 이용한 예제이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 3 
&amp;gt;&amp;gt;&amp;gt; if a &amp;gt; 1:
... 	print(&quot;a is greater than 1&quot;)
...
a is greater than 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;**print문의 앞의’…‘은 아직 문장이 끝나지 않았음을 의미한다!&lt;/p&gt;

&lt;h4 id=&quot;for&quot;&gt;반복문 for&lt;/h4&gt;

&lt;p&gt;다음은 for를 이용해서 [1, 2, 3]안의 값들을 하나씩 출력해 주는 것을 보여주는 예이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for a in [1,2,3]:
... 	print(a)
... 
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for문을 이용하면 실행해야 할 문장을 여러 번 반복해서 실행시킬 수 있다. 위의 예는 대괄호([]) 사이에 있는 값들을 하나씩 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;while&quot;&gt;반복문 while&lt;/h4&gt;

&lt;p&gt;다음은 while을 이용하는 예제이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; i = 0
&amp;gt;&amp;gt;&amp;gt; while i &amp;lt; 3:
... 	i=i+1
... 	print(i)
...
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-19&quot;&gt;함수&lt;/h4&gt;

&lt;p&gt;함수는 다음과 같은 형태이다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def sum(a, b):
... 	return a+b
...
&amp;gt;&amp;gt;&amp;gt; print(sum(3,4))
7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;파이썬에서 &lt;strong&gt;def&lt;/strong&gt;는 함수를 만들 때 사용하는 예약어이다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sum(a,b)에서 a,b는 입력값이고, a+b는 결과값이다! 즉, 3, 4가 입력으로 들어오면 3+4를 수행하고 그 결과값인 7을 돌려준다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-20&quot;&gt;숫자형&lt;/h2&gt;

&lt;p&gt;숫자형(Number)이란 숫자 형태로 이루어진 자료형이다!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;사용 예&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;정수&lt;/td&gt;
      &lt;td&gt;123, -345, 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;실수&lt;/td&gt;
      &lt;td&gt;123.45, -1234.5, 3.4e10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8진수&lt;/td&gt;
      &lt;td&gt;0o34, 0o25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16진수&lt;/td&gt;
      &lt;td&gt;0x2A, 0xFF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-21&quot;&gt;숫자형은 어떻게 만들고 사용할까?&lt;/h3&gt;

&lt;h4 id=&quot;section-22&quot;&gt;정수형&lt;/h4&gt;

&lt;p&gt;정수형(integer)란 말 그대로 정수를 뜻하는 자료형을 말한다. 다음은 양의 정수와 음의 정수, 숫자0을 변수 a에 대입하는 예이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 123
&amp;gt;&amp;gt;&amp;gt; a = -178
&amp;gt;&amp;gt;&amp;gt; a = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-23&quot;&gt;실수형&lt;/h4&gt;

&lt;p&gt;파이썬에서 실수형(Floating-point)은 소수점이 포함된 숫자를 말한다. 다음 예는 실수를 변수 a에 대입하는 예이다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 1.2
&amp;gt;&amp;gt;&amp;gt; a = -3.45
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 방식은 우리가 일반적으로 볼 수 있는 실수형의 소수점 표현 방식이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 4.24E10
&amp;gt;&amp;gt;&amp;gt; a = 4.24e-10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위의 방식은 “컴퓨터식 지수 표현 방식”으로 파이썬에서는 4.24e10 또는 4.24E10처럼 표현한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-24&quot;&gt;8진수와 16진수&lt;/h4&gt;

</description>
        <pubDate>Wed, 29 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/python/2017/11/29/jump.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/python/2017/11/29/jump.html</guid>
        
        <category>Python</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Flask Heroku(배포)</title>
        <description>&lt;h2 id=&quot;flasky&quot;&gt;flasky&lt;/h2&gt;

&lt;h3 id=&quot;deploy-&quot;&gt;deploy 과정&lt;/h3&gt;

&lt;p&gt;태스크를 애플리케이션이 설치될 때나 업그레이드될 때 수동으로 실행하면 에러에 취약하고 시간 소모적인 작업이 된다. 따라서 필요한 모든 태스크를 실행하는 커맨드를 manage.py에 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) 17-1&lt;/em&gt; manage.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def deploy():
	&quot;&quot;&quot;Run deployment tasks.&quot;&quot;&quot;
	from flask.ext.migrate import upgrade
	from app.models import Role, User
	
	# migrate database to latest revision
	upgrade()
	
	# create user roles
	Role.insert_roles()
	
	# create self-follows for all users
	User.add_self_follows()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 커맨드에 의해 실행될 함수는 이전에 모두 생성되었으며 일괄적으로 함께 호출된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;업데이트 함수를 설계함으로써 설치나 업그레이드가 실행될 때마다 deploy 커맨드를 실행하는 것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;제품화 과정 중의 에러에 대한 로그&lt;/h3&gt;

&lt;p&gt;디버거는 개발 중에 애플리케이션 문제점들을 디버그하기 위한 훌륭한 툴이지만 제품화 배포에서는 사용할 수 없다. 제품화에서 발생한 에러는 숨겨져 있으며 사용자들은 단지 코드 500 에러 페이지만을 받게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 에러의 스택 트레이스를 완전히 잃어 버리지는 않는다. 플라스크가 그 에러를 로그 파일(log file)에 작성하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시작하는 동안에 플라스크는 Python의 logging.Logger 클래스의 인스턴스를 생성하고 그것을 애플리케이션 인스턴스의 app.logger로 붙인다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이 로거는 디버그 모드에서는 콘솔에 작성하지만 제품화 모드에서는 기본적으로 이것을 설정하는 핸들러가 없다. 따라서 핸들러에 로그가 추가되어야 저장이 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-2&lt;/em&gt; config.py : 애플리케이션 에러에 대해 이메일 전송&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ProductionConfig(Config):
	# ...
	@classmethod
	def init_app(cls, app):
		Config.init_app(app)
		
		# email errors to the administrators
		import logging
		from logging.handlers import SMTPHandler
		credentials = None
		secure = None
		if getattr(cls, 'MAIL_USERNAME', None) is not None:
			credentials = (cls.MAIL_USERNAME, cls.MAIL_PASSWORD)
			if getattr(cls, 'MAIL_USE_TLS', None):
				secure = ()
	mail_handler = SMTPHandler(
		mailhost=(cls.MAIL_SERVER, cls.MAIL_PORT),
		fromaddr=cls.FLASKY_MAIL_SENDER,
		toaddrs=[cls.FLASKY_ADMIN],
		subject=cls.FLASKY_MAIL_SUBJECT_PREFIX + ' Application Error',
		credentials=credentials,
		secure=secure)
	mail_handler.setLevel(logging.ERROR)
	app.logger.addHandler(mail_handler)
		
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이러한 변경 사항은 제품화 모드에서 실행하는 동안 발생하는 에러를 FLASKY_ADMIN에 세팅에 설정되어 있는 관리자 리스트의 이메일로 전송하도록 로깅 핸들러를 설정한다.&lt;/p&gt;

&lt;h4 id=&quot;createapp---initapp------&quot;&gt;모든 설정 인스턴스가 &lt;code class=&quot;highlighter-rouge&quot;&gt;create_app()&lt;/code&gt;에 의해 호출되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;init_app()&lt;/code&gt; 정적 메소드를 갖고 있다는 것을 기억하자!!!&lt;/h4&gt;

&lt;p&gt;ProductionConfig 클래스를 위한 이 메소드의 구현에서 애플리케이션 로거는 이메일 로거로 로그 에러를 설정하도록 되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이메일 로거의 로그 레벨은 logging.ERROR로 설정된다. 따라서 단지 심각한 문제만 이메일로 전송된다. 덜 심각한 레벨로 로깅된 메세지는 파일, syslog 혹은 적절한 로깅 핸들러를 추가하여 지원하는 다른 메소드를 사용하여 로그된다. 이러한 메시지를 위해 사용되는 로깅 메소드는 호스팅 플랫폼에 상당히 의존적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;클라우드 배포&lt;/h2&gt;

&lt;p&gt;가장 최근의 트렌드는 “클라우드”로 호스팅하는 것이다. 이 기술은 애플리케이션 개발자들을 애플리케이션이 실행하게 될 하드웨어와 소프트웨어 플랫폼에 따라 설치와 유지 보수를 해야 하는 기존의 태스크로부터 해방시켜 준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤로쿠(Heroku)는 가장 유명한 PaaS 프로바이더이며 파이썬을 지원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;헤로쿠 플랫폼&lt;/h2&gt;

&lt;p&gt;헤로쿠는 2007년부터 비즈니스를 시작했다. 헤로쿠 플랫폼은 유연성이 뛰어나며 다양한 프로그래밍 언어를 지원한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션을 헤로쿠에 배포하기 위해서는 개발자가 Git을 사용하여 애플리케이션을 헤로쿠의 Git 서버에 푸시한다. 서버에서는 git push 커맨드가 자동으로 설치, 설정, 배포를 트리거한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;애플리케이션의 준비&lt;/h3&gt;

&lt;p&gt;헤로쿠에서 작업하기 위해서는 애플리케이션이 Git 저장소에 호스트되어야 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;헤로쿠 계정의 생성&lt;/h4&gt;

&lt;h4 id=&quot;section-5&quot;&gt;헤로쿠 툴벨트의 설치&lt;/h4&gt;

&lt;p&gt;헤로쿠 애플리케이션을 관리하는 가장 간편한 방법은 헤로쿠 툴벨트(Toolbelt) 커맨드 라인 유틸리티를 이용하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;툴벨트는 두 개의 헤로쿠 애플리케이션으로 구성되어 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;heroku : 헤로쿠 클라이언트이며, 애플리케이션을 생성하고 관리하는 데 사용된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;foreman : 컴퓨터에 테스트할 목적으로 헤로쿠 환경을 시뮬레이션하는 툴이다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;헤로쿠 클라이언트 유틸리티는 서비스에 연결하기 전에 헤로쿠 계정 자격증을 갖고 있어야 한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) heroku login command&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku login 
Enter your Heroku credentials.
Email: &amp;lt;your-email-address&amp;gt;
Password (typing will be hidden): &amp;lt;your-password&amp;gt;
Uploading ssh public key .../id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다음 단계는 헤로쿠 클라이언트를 사용하여 애플리케이션을 생성하는 것이다.&lt;/p&gt;

&lt;p&gt;이 작업을 하기 위해, 먼저 애플리케이션이 Git 소스 컨트롤에 있는지 확인한 후에 최상위 디렉토리에서 다음의 커맨드를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku create &amp;lt;appname&amp;gt;
Creating &amp;lt;appname&amp;gt;...done, stack is cedar
http://&amp;lt;appname&amp;gt;.herokuapp.com/ | git@heroku.com:&amp;lt;appname&amp;gt;.git
Git remote heroku addred
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;헤로쿠 애플리케이션 이름은 반드시 고유의 이름이어야 하므로 다른 애플리케이션에서 사용하지 않은 이름을 찾아야 한다. create 커맨트의 결과에서 볼 수 있는 것처럼 한 번 배포된 애플리케이션은 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://&amp;lt;appname&amp;gt;.herokuapp.com&lt;/code&gt;에서 사용 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;커스텀 도메인 이름 역시 애플리케이션에 붙일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;git--&quot;&gt;애플리케이션 생성의 부분으로 헤로쿠는 Git 서버를 할당한다&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git@heroku.com:&amp;lt;appname&amp;gt;.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;create 커맨드는 이 서버를 로컬 Git 저장소에 heroku라는 이름을 가진 git remote인 것처럼 추가한다.&lt;/p&gt;

&lt;h4 id=&quot;provisioning&quot;&gt;데이터베이스의 프로비저닝(provisioning)&lt;/h4&gt;

&lt;p&gt;헤로쿠는 Postgre 데이터베이스를 애드온으로 지원한다. 약 10,000개 정도의 행을 갖는 작은 데이터베이스를 무료로 애플리케이션에 추가할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku addons:add heroku-postgresql:dev
Adding heroku-postgresql:dev on &amp;lt;appname&amp;gt;... done, v3 (free)
Attached as HEROKU_POSTGRESQL_BROWN_URL
Database has been created and is available
 ! This database is empty. If upgrading, you can transfer
 ! data from another database with pgbackups:restore.
Use 'heroku addons:docs heroku-postgresql:dev' to view documentation.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HEROKU_POSTGRESQL_BROWN_URL&lt;/code&gt; 레퍼런스는 데이터베이스 URL을 갖고 있는 환경 변수의 이름이다. 이 작업을 하려고 할 때 브라운(brown)과는 다른 컬러를 얻을 수 있다. 헤로쿠는 애플리케이션당 다중 데이터베이스를 지원하며 각각은 URL에서 다른 컬러로 보인다. 데이터베이스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt; 환경 변수에 자신의 URL을 포함시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음 커맨드는 브라운 컬러의 데이터베이스에 대한 처리를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku pg:promote HEROKU_POSTGRESQL_BROWN_URL
Promoting HEROKU_POSTGRESQL_BROWN_URL to DATABASE_URL... done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt; 환경 변수의 포맷은 정확하게 SQLAlchemy에서 필요한 것과 동일하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정의해 둔 것이 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt;의 값을 사용하는 config.py 스크립트를 기억하자. Postgre 데이터베이스에 대한 연결은 이제 자동으로 진행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;로깅 설정&lt;/h4&gt;

&lt;p&gt;로깅 설정은 &lt;code class=&quot;highlighter-rouge&quot;&gt;init_app()&lt;/code&gt; 정적 메소드에 있는 ProductionConfig 클래스에 추가되지만 이러한 타입의 로깅은 헤로쿠에만 적용되기 때문에 새로운 설정이 플랫폼에 따라 생성될 수 있다. 다른 타입의 제품 플랫폼을 위한 기본 설정으로 ProductionConfig는 남겨둔다. HerokuConfig 클래스는 다음 예와 같다&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) 17-3. config.py : 헤로쿠 설정&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HerokuConfig(ProductionConfig):
	@classmethod
	def init_app(cls, app):
		ProductionConfig.init_app(app)
		
		# log to stderr
		import logging
		from logging import StreamHandler
		file_handler = StreamHandler()
		file_handler.setLevel(logging.WARNING)
		app.logger.addHandler(file_handler)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;애플리케이션을 헤로쿠에 의해 실행하면, 사용해야 할 설정을 알아야 한다. manage.py에서 생성된 애플리케이션 인스턴스는 FLASK_CONFIG 환경 변수로 어떤 설정을 사용해야 할 지 알게되며, 따라서 이 변수는 헤로쿠 환경에 설정되어야 한다. 환경 변수는 헤로쿠 클라이언트의 config:set 커맨드를 사용하여 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku config:set FLASK_CONFIG=heroku
Setting config vars and restarting &amp;lt;appname&amp;gt;... done, v4
FLASK_CONFIG: heroku
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;이메일 설정&lt;/h4&gt;

&lt;p&gt;헤로쿠는 SMTP 서버를 제공하지 않으므로 외부 서버를 설정해 줘야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스크립트에 로그인 자격 내용을 직접 포함시키게 되면 보안 위험이 있을 수 있기 때문에 지메일 SMTP에 액세스하기 위한 사용자 이름과 패스워드는 다음과 같이 환경변수를 통해 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku config:set MAIL_USERNAME=&amp;lt;your-gmail-username&amp;gt;
$ heroku config:set MAIL_PASSWORD=&amp;lt;your-gmail-password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;제품 웹 서버의 실행&lt;/h4&gt;

&lt;p&gt;헤로쿠는 애플리케이션을 위한 호스트 목적의 웹 서버를 제공하지 않는다. 대신에 애플리케이션이 자신의 서버를 시작하고 환경 변수 PORT에 설정된 포트 번호에서 리스닝할 수 있도록 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;플라스크를 사용한 개발 웹 서버는 성능이 매우 좋지 않다. 제품 환경에서 실행되도록 설계된 것이 아니기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;플라스크 애플리케이션을 잘 동작시키는 제품화 준비를 마친 두 개의 웹 서버는 구니콘(Gunicorn)과 uWSGI다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구니콘은 다음과 같이 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(venv) $ pip install gunicorn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;구니콘에서 애플리케이션을 실행하려면 다음 커맨드를 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(venv) $ gunicorn manage:app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;구니콘은 포트 8000을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;필요 파일의 추가&lt;/h4&gt;

&lt;p&gt;헤로쿠는 최상위 폴더에 저장된 requirements.txt 파일에서 패키지 의존성을 로드한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;psycopg2&lt;/strong&gt; 패키지는 Postgre 데이터베이스와 구니콘 웹 서버 지원을 할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex) 17-4. requirements.txt : 헤로쿠 필요 파일&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-r requirements/prod.txt
gunicorn==18.0
psycopg2==2.5.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;procfile-&quot;&gt;Procfile의 추가&lt;/h4&gt;

&lt;p&gt;헤로쿠는 애플리케이션을 시작하기 위해 사용하는 커맨드가 무엇인지 알고 있어야 한다. 이 커맨드는 &lt;strong&gt;Procfile&lt;/strong&gt;이라고 하는 특정 파일에 작성되어 있다. 이 파일은 애플리케이션 최상위 폴더에 추가되어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 이파일의 콘텐츠를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-5. Procfile : 헤로쿠 Procfile&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;web: gunicorn manage:app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Procfile의 포맷은 매우 간단하다. 각 라인에는 태스크 이름이 있고, 그 다음에는 콜론, 그 다음에는 태스크를 실행하는 명령어가 온다.&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;포맨을 이용한 테스트&lt;/h2&gt;

&lt;p&gt;헤로쿠 툴벨트는 &lt;strong&gt;포맨(Foreman)&lt;/strong&gt;이라는 두 번째 유틸리티를 포함하고 있다. 이 유틸리티는 테스트 목적으로 Procfile을 통해 애플리케이션을 로컬로 실행하는 데 사용된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포맨은 애플리케이션의 최상위 디렉토리에 있는 &lt;strong&gt;.env&lt;/strong&gt;라는 이름의 파일에서 환경변수들을 찾는다. 예를들어, &lt;strong&gt;.env&lt;/strong&gt; 파일은 다음과 같은 변수들을 포함하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FLASK_CONFIG=heroku
MAIL_USERNAME=&amp;lt;your-username&amp;gt;
MAIL_PASSWORD=&amp;lt;your-password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;.env 파일은 패스워드와 다른 민감한 계정 정보를 포함하고 있기 때문에 Git 저장소에는 절대 추가해서는 안된다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;포맨의 주요한 두 개의 옵션은 foreman run 과 foreman start다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;run 커맨드는 애플리케이션 환경에서 커맨드를 실행할 때 사용되고, deploy 커맨드는 애플리케이션에서 데이터베이스를 생성할 때 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;start 커맨드는 Procfile이 필요하며 그 안에 있는 모든 태스크를 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(venv) $ foreman start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;flask-sslify---http-&quot;&gt;Flask-SSLify를 이용한 보안 HTTP의 활성화&lt;/h2&gt;

&lt;p&gt;헤로쿠는 헤로쿠 내의 SSL 인증을 사용하는 설정 없이도 모든 애플리케이션이 &lt;strong&gt;http://&lt;/strong&gt;와 &lt;strong&gt;https://&lt;/strong&gt; 모두에서 가능한 &lt;strong&gt;herokuapp.com&lt;/strong&gt; 도메인을 액세스하도록 해 준다. 이때 필요한 유일한 작업은 애플리케이션이 &lt;strong&gt;http://&lt;/strong&gt; 인터페이스로 전송하는 리퀘스트를 가로채는 것과 그것을 &lt;strong&gt;https://&lt;/strong&gt;로 리다이렉트하는 것이다. 그리고 이것은 Flask-SSLify 확장이 하는 작업이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 확장은 requirements.txt 파일에 추가되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-6. &lt;code class=&quot;highlighter-rouge&quot;&gt;app/__init__.py&lt;/code&gt; : 모든 리퀘스트를 보안 HTTP로 리다이렉트&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def create_app(config_name):
	# ...
	if not app.debug and not app.testing and not app.config['SSL_DISABLE']:
		from flask.ext.sslify import SSLify
		sslify = SSLify(app)
	# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;ex) 17-7. config.py : SSL의 사용 설정&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Config:
	# ...
	SSL_DISABLE = True
	
class HerokuConfig(ProductionConfig):
	# ...
	SSL_DISABLE = bool(os.environ.get('SSL_DISABLE'))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;환경변수가 비어 있는 문자열 대신에 다른 것으로 설정되면, 불린으로의 변경은 True를 리턴하며 SSL은 비활성화 된다. 환경변수가 존재하지 않거나 비어 있는 문자열로 설정되면, 불린으로의 변경은 False가 된다. 포맨을 사용할 때 SSL이 활성화되는 것을 막기 위해서는 &lt;strong&gt;.env&lt;/strong&gt; 파일에 SSL_DISABLE=1을 추가해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;헤로쿠를 사용할 때 클라이언트는 호스트한 애플리케이션을 직접 연결하지 않으며 &lt;strong&gt;리버스 프록시 서버(reverse proxy server)&lt;/strong&gt;에 연결한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리버스 프록시 서버는 애플리케이션에 리퀘스트를 리다이렉트한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프록시 서버는 클라이언트로부터 받은 원래의 리퀘스트를 커스텀 HTTP 헤더를 통해 리다이렉트된 웹 서버에 전송하도록 작성된 정보를 넘긴다. 따라서 사용자가 이러한 정보를 바탕으로 SSL을 통해 애플리케이션과 통신할지를 결정할 수 있다.&lt;/p&gt;

&lt;p&gt;Werkzeug는 WSGI &lt;strong&gt;미들웨어&lt;/strong&gt;를 제공하는데, 이 미들웨어는 프록시 서버로부터의 커스텀 헤더를 체크하고 그에 맞는 리퀘스트 오브젝트를 업데이트한다. 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;request.is_secure&lt;/code&gt;는 클라이언트가 리버스 프록시 서버에게 전송하는 리퀘스트의 보안성을 반영하며 프록시 서버가 애플리케이션에 전송하는 리퀘스트는 반영하지 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다음은 애플리케이션에 ProxyFix 미들웨어를 추가하는 방법을 보여준다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ex) 17-8. config.py : 프록시 서버의 지원&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HerokuConfig(ProductionConfig):
	# ...
	@classmethod
	def init_app(cls, app):
		# ...
		
		# handler proxy server headers
		from werkzeug.contrib.fixers import ProxyFix
		app.wsgi_app = ProxyFix(app.wsgi_app)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-push--&quot;&gt;Git push를 이용한 배포&lt;/h2&gt;

&lt;p&gt;모든 변경 사항이 로컬 Git 저장소에 커밋된 것을 확인한 후에 git push master를 사용하여 애플리케이션을 heroku 리모트에 업로드한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이제 애플리케이션이 배포되고 실행된다. 그러나 이 과정이 정상적으로 진행된것 같지는 않다. 그 이유는 deploy 커맨드를 아직 실행하지 않았기 때문이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku run python manage.py deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 베이스 테이블이 생성되고 설정된 후에, 애플리케이션은 깔끔하게 시작하기 위해 재시작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;애플리케이션은 이제 배포되었고 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;https://&amp;lt;appname&amp;gt;.herokuapp.com&lt;/code&gt;&lt;/strong&gt;에서 액세스가 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;로그 검토&lt;/h2&gt;

&lt;p&gt;애플리케이션에서 생성한 로그 출력은 헤로쿠에서 캡쳐 할 수 있다. 로그 내용을 보기 위해서는 logs 커맨드를 사용한다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku logs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;테스트를 하는 동안 로그 파일의 가장 최신 내용을 보는 것이 편리하며 다음과 같이 작업한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku logs -t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-12&quot;&gt;배포와 업그레이드&lt;/h2&gt;

&lt;p&gt;헤로쿠 애플리케이션은 반복되어야 하는 동일한 프로세스를 업그레이드해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ heroku maintenance:on
$ git push heroku master
$ heroku run python manage.py deploy
$ heroku restart
$ heroku maintenance:off
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;maintanence 옵션은 업그레이드가 진행되는 동안 애플리케이션을 오프라인에서 사용하게 하며 사이트가 재개될 것이라는 정보를 사용자에게 알려주는 정적 페이지를 보여주게 된다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/flask/2017/11/27/flask.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/flask/2017/11/27/flask.html</guid>
        
        <category>Flasky</category>
        
        
        <category>Flask</category>
        
      </item>
    
      <item>
        <title>코딩을 지탱하는 기술</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;코딩을 지탱하는 기술&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;프로그래밍 학습에 중요한 포인트 3가지&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;비교를 통한 학습&lt;/li&gt;
  &lt;li&gt;역사를 통한 학습&lt;/li&gt;
  &lt;li&gt;만드는 것을 통한 학습&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;규칙은 언어마다 다르다&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C언어에서는 0이 참이지만, ruby에서는 0이 거짓이다. 자바에서는 0이 단순한 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;잘못된 고정관념을 버려야 한다.&lt;/h4&gt;

&lt;p&gt;특정언어에 국한된 지식을 습득할 것이 아니라 모든 언어에 통용 될 수 있는 이해력을 기를 필요가 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;프로그래머의 삼대 미덕&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;나태함, 조바심, 자만심&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;프로그래밍 언어는 사람을 편하게 하기 위해서 만들어졌다.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;언어는 도구일 뿐이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가상소프트웨어의 선결과제 = 빠른 실행 속도&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C++ 은 빠른 실행 속도를 자랑하지만 높은 언어사양을 요구한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;프로그래밍 언어에 대한 이해력을 확인하기 위해서는 아웃풋(결과물)을 확인해야한다.&lt;/h4&gt;

&lt;p&gt;에러메세지가 발생하면 당황하거나 무서워하지말아야 한다. 내가 만든 것을 언어 처리계가 열심히 읽어서 여기를 모르겠다고 대답해주고 있는 것이다 - 언어 처리계와 제대로된 커뮤니케이션을 하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아직도 스택 머신(FORTH)은 살아있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Python이나 Ruby, Java로 프로그램을 짜면 그 프로그램은 내부적으로 FORTH와 같은 프로그램으로 변환(컴파일)되어 동작하고 있는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;언어마다 차이가 생긴 것은…&lt;/h3&gt;

&lt;p&gt;표현 방법이 틀릴뿐. 구문트리는 동일하다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘어떤 문자열을 쓰면 어떤 구문 트리가 생기는가’ = 이것이 규칙이자 문법이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재 대부분의 프로그래밍 언어들은 다가가기 쉬운 언어 작성법을 목표로 하고 있다. 하지만 기존의 문법과 마찰되지 않도록하면서 새로운 문법을 추가하는 것은 굉장히 어려운 일이다!&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;if&quot;&gt;if문&lt;/h3&gt;

&lt;p&gt;if-else 구문의 이점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다’ 이것을 간단하고 읽기 쉬운 형태로 볼 수 있게 해준다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;else가 반드시 필요한 것은 아니다. 하지만 가독성 측면에서 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;p&gt;###반복문&lt;/p&gt;

&lt;h4 id=&quot;for---while--&quot;&gt;for문으로 가능한 것은 while문으로도 가능하긴 하다.&lt;/h4&gt;

&lt;p&gt;while문 에서는 분산되어 있던 반복 조건문들이 for문에서는 한곳에 모여있기 때문에 루프문 작성자의 의도를 쉽게 파악 할 수 있다.&lt;/p&gt;

&lt;p&gt;foreach구문은 ‘어떤 대상의 요소 전부에 어떤 처리를 한다’는 코드를 쉽게 쓰기 위해 만들어졌다.&lt;/p&gt;

&lt;h5 id=&quot;python-for-foreach---c--for----&quot;&gt;Python의 for문은 foreach 구문이다. 역으로, C 언어의 for 문에 대응하는 구문은 없다!&lt;/h5&gt;

&lt;h5 id=&quot;for---------&quot;&gt;for문에서도 조건식으로 제어하고 있지만, 주요 사용 목적은 횟수를 의식한 제어다!&lt;/h5&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for문은 정해진 범위 내에서 루프&lt;/li&gt;
  &lt;li&gt;while문은 범위가 없이 루프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;바꿔 말하자면, for문은 반복수를 알 때 사용한다. while문은 반복수를 모를 때 사용한다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;함수&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;코드가 함수로 나누어져 있는 것은 큰 조직이 부서로 나눠져 있는 것과 같다!!!&lt;/h4&gt;

&lt;p&gt;함수를 만드는 것은 작은 부품을 조립해서 큰 부품을 만드는 것과 같다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예를 들어 무선 조정 자동차 속에는 모터가 있고 모터 속에는 코일이나 정류자가 들어있다!! = 함수의 개념이다&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;무선 조정 자동차가 느려지면 알칼리 전지가 약해졌다고 생각 할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;근처 편의점에 가서 전지를 구해야한다 = 함수의 이해와 같다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;함수도 동일하다. 수십 행 수백 행의 코드가 함수로 정리되어 제공되고 있어서 그 함수를 호출해서 사용이 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;프로그램을 만드는 것과 물리적인 것을 만드는 것의 차이 ( 비용의 차이 )&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예를 들어 아파트 100세대에 급수기를 설치해야 한다면 100개의 급수기가 필요하다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램은 100개의 특정 데이터가 있으면 함수만 100회 호출하면 된다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한계가 없다&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1: 110의 점프 명령의 점프 목적지를 3으로 바꾼다&lt;/li&gt;
  &lt;li&gt;2: 함수를 호출한다 ( 100으로 점프 )&lt;/li&gt;
  &lt;li&gt;3: 다음 명령.&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;51: 110의 점프 명령의 점프 목적지를 53으로 바꾼다.&lt;/li&gt;
  &lt;li&gt;52: 함수 호출 ( 100으로 점프 )&lt;/li&gt;
  &lt;li&gt;53: 다음 명령.&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;100: 함수 처리&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;110: 돌아간다 ( 0으로 점프 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;이렇게 해서 함수가 탄생했다&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;함수의 이름&lt;/h3&gt;

&lt;p&gt;메모리상에서의 위치&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;함수를 사용한 처리에 이름을 붙이는 행위는 ‘처리가 시작되는 메모리상의 위치’를 수치로 표현하는 대신, 알기 쉬운 문자열로 표현하는 행위다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수도 마찬가지다. ‘값이 기록된 메모리 위치’를 수치가 아닌 문자열로 표현하기 위해 만들어졌다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;stack--&quot;&gt;스택 ( Stack ) 영역&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;복수의 데이터 값을 저장해두는곳&lt;/li&gt;
  &lt;li&gt;마지막에 넣은 것을 가장 먼저 꺼내는 것에 적합&lt;/li&gt;
  &lt;li&gt;할당된 메모리 구조는 위에서부터 데이터 - 힙 - 스택 순으로 배치된다. (스택은 가장 아래부분)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;재귀 함수&lt;/h3&gt;

&lt;p&gt;재귀함수는 함수 X안에서 함수 X 자신을 호출 하는 것이다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내포 구조를 다루는데 적합하다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h4 id=&quot;section-12&quot;&gt;재귀함수의 구조를 이해하기위한 좋은예&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;ex)&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xs = [1,2,[3,4],5]
def total(xs):
    result = 0
    for x in xs:
        if is_integer(x):
            result += x
        else:
            result += total(x)
            
    return result 
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;x는 내포 리스트이기 때문에 total로 안에 든 값을 합산한다!&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;에러 처리&lt;/h3&gt;

&lt;p&gt;프로그램 실행 시 실패가 발생하는 경우가 많다. 실패 시에 어떻게 하는가(에러처리)는 매우 중요하다!!&lt;/p&gt;

&lt;p&gt;크게 방법은 두가지이다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;반환값을 사용하는 방법&lt;/li&gt;
  &lt;li&gt;예외를 사용하는 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-14&quot;&gt;반환값으로 실패를 전달하는 방법에 대해서…&lt;/h4&gt;

&lt;p&gt;이 방법은 C 언어를 비롯해서 많은 언어가 사용하고 있는 중이다.&lt;/p&gt;

&lt;p&gt;그러나&lt;/p&gt;

&lt;p&gt;2가지 문제점이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실패를 놓친다.&lt;/li&gt;
  &lt;li&gt;에러 처리 때문에 코드를 해석하기 어렵다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;때문에 점프로 에러를 처리하며 처리에는 goto를 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C 언어에는 예외기능이 없기 때문이다
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;에러가 발생했을 때 점프할 장소를 사전에 등록해두는 방법이 있다. 이방법이 발전해서 오늘날의 ‘예외 처리’가 된 것이다&lt;/p&gt;

&lt;h4 id=&quot;univac-i-&quot;&gt;UNIVAC I의 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;‘계산 시 오버플로우가 발생하면 xxx번지에 있는 명령을 실행한다’는 기능이 있었다. 이런 기능을 ‘인터럽트(interrupt)’라고 불렀다. (예로들면 키보드 입력 처리)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cobol-&quot;&gt;COBOL의 경우&lt;/h4&gt;

&lt;p&gt;1959년에 두가지 에러처리를 탑재하고 나타났다!&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;READ로 파일을 읽을 때 ‘AT END’라는 	구문으로 ‘더 이상 데이터가 없다’ 등의 		에러가 발생했을 때&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ADD등으로 수치 계산을 할 때 오버플로우가 발생했을 경우 ‘ON SIZE ERROR’ 구문으로 처리를 표현&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;pli-&quot;&gt;PL/I의 경우&lt;/h4&gt;

&lt;p&gt;1964년 FORTRAN, COBOL, ANGOL을 집성해서 설계되었다.&lt;/p&gt;

&lt;p&gt;새롭게 정의한 실패를 프로그래머가 발생 시킬 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;프로그래밍은 짝이 되는 처리가 중요하다&lt;/h3&gt;

&lt;p&gt;미술관을 예로들면, 입구에서 빌린 음성 안내기를 출구가 하나라면 제대로 회수 할 수 있지만, 출구가 여러개라면 회수가 어려워 진다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;여기서 출구란 ( return )&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이문제는 finally를 사용해서 짝을 맞춰 줄 수 있으며 해결 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;finally 블록은 처리가 try 블록에서 벗어날 때 반드시 실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Microsoft사에서 처음 도입했으며, 1995년에는 Java도 도입했다. 현재는 Python이나 Ruby에서도 동일한 구문을 지원하고 있다.&lt;/p&gt;

&lt;h4 id=&quot;c-finally---&quot;&gt;C++은 finally를 갖고 있지 않다.&lt;/h4&gt;

&lt;p&gt;함수를 벗어날때 함수의 지역 변수에 대해서 자동적으로 소멸자가 호출되어 finally의 역할을 대신한다.&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;어떤 경우에 예외를 던질까?&lt;/h3&gt;

&lt;p&gt;Python과 Ruby는 함수 호출 시점에서 예외를 던진다. 그러나, JavaScript는 인수에 ‘미정의를 의미하는 특수한 값’을 사용해서 처리를 계속한다.&lt;/p&gt;

&lt;h4 id=&quot;section-17&quot;&gt;예외는 어떤 경우에 사용해야하는가?&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;예외적 상황이란 무엇인지에 대한 정답은 없다&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;프로그래머도 사람인 이상, 실수를 피할 수는 없다.&lt;/p&gt;

&lt;p&gt;무언가가 이상하다면 빨리 문제를 발견하는 것이 중요하다. 학습이나 개발 단계에서는 틀리면 바로 틀린 것을 발견하는 것이 오히려 이점이 많다.&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;이름과 스코프&lt;/h3&gt;

&lt;p&gt;스코프란 변수나 함수의 이름이 유효한 ‘범위’를 말한다.&lt;/p&gt;

&lt;h4 id=&quot;section-19&quot;&gt;왜 이름이 필요한가?&lt;/h4&gt;

&lt;p&gt;지금은 있는 것이 당연하다고 느끼는 변수나 함수의 이름은 초기에는 메모리에 번호를 부여해서 해당 값을 찾는 방식이었으나, 이름으로 대상을 지정 할 수 있도록 꾸준히 발전해왔다.&lt;/p&gt;

&lt;h4 id=&quot;section-20&quot;&gt;이름의 충돌&lt;/h4&gt;

&lt;p&gt;초기 프로그래밍 언어에서는 대응표를 프로그램 전체에서 공유하고 있었다. 회사로 말하면 큰 화이트 보드가 있어서 모두가 메모를 하고 있는 상황과 같았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것은 같은 이름을 지닌 값이 있다면 데이터를 덮어써버려서 충돌을 일으키는 것이 문제였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-21&quot;&gt;충돌 피하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;긴 변수명을 사용하는 방법&lt;/li&gt;
  &lt;li&gt;스코프를 이용하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-22&quot;&gt;스코프란??&lt;/h4&gt;

&lt;p&gt;이름의 유효 범위다.&lt;/p&gt;

&lt;p&gt;이것은 동적 스코프와 정적 스코프로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;동적 스코프 : 함수 입구에 원래의 값을 기록해두고 함수 출구에서 리턴값을 원래의 값으로 되돌리고 내보내는 것이다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;문제점 : 동적 스코프의 문제점으로는 변수를 변경한 후에 다른 함수를 호출한 경우 호출된 함수에 영향을 미치게 되기 때문에 다루기 힘들다는 점이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정적 스코프 : 함수가 호출될 때마다 새로운 대응표를 만드는 것과 같다고 할 수 있다. 회사 전체가 공유하고 있는 커다란 화이트 보드에 작성하는 대신, 한명 한명이 자신의 책상에 메모 용지를 갖고 있는 것으로 비유 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-23&quot;&gt;하지만 동적 스코프로 만들어진 대응표는 소스 코드 전역에서 읽고 쓸 수 있다. 정적 스코프와의 가장 큰 차이점이다!&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;동적 스코프가 만약 참조한 경우에는 가까운 곳부터 순서대로 읽는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-24&quot;&gt;정적 스코프는 함수별로 대응표를 나눈다&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;특정 함수내에서의 이름변경이 함수 밖까지 영향을 주지 못한다. (유효 범위 분할이 가능)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;현재는 많은 언어가 정적 스코프를 도입중이다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-25&quot;&gt;그렇다면 정적 스코프는 완성체인가?&lt;/h3&gt;

&lt;p&gt;정적 스코프의 특징이 편리해 보일 수도 있지만 2가지의 문제점을 지니고 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;내포 함수의 문제점 : 내포된 것처럼 보이는 함수가 실제로는 내포되지 않은 것이다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Python 2.0 을 예로들면, 특정 함수의 지역 스코프에서 찾고자하는 이름을 발견하지 못할 경우, 전역 스코프를 보게 된다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;이는 소스 코드 상에서 가까이에 있는 정의가 사용되지 않는 예이다. 지금은 가까이에 있는 정의를 사용하도록 수정되었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;외부 스코프에 재귀속되는 문제&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;내포한 스코프의 외부 변수를 변경할 수 없다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수안에서 대입하면 그 함수의 지역 변수가 되는데, 해당 스코프에 이미 같은 이름의 변수가 있으면 해당 변수를 재귀속 시키고, 없으면 해당 스코프에서 새로운 지역 변수를 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;어느쪽이든 외부 스코프에 영향을 미치지 않게 되므로 이것은 외부 스코프에 있는 변수를 변경할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;section-26&quot;&gt;형&lt;/h2&gt;

&lt;p&gt;형이란 수치를 On과 Off로 표현하는 방법이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴퓨터 안에서는 On과 Off, 0과 1의 집합으로 모든 값이 표현된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-27&quot;&gt;자릿수의 발명&lt;/h4&gt;

&lt;p&gt;컴퓨터가 탄생하기 1000년 이상 전에 인류는 자릿수 기수법을 발명했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 자리에 0에서 9까지 10가지 기호를 사용해서 수를 표현하는 방법이다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-28&quot;&gt;7 세그먼트 디스플레이&lt;/h4&gt;

&lt;p&gt;계산기 등에서 수치를 표현하기 위해서 만들어졌다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;7 세그먼트 디스플레이를 사용하면 7개의 램프로 한 자릿수를 표현할 수 있어서, 3자릿수를 표현하기 위해 필요한 램프의 개수는 21개가 되고, 이는 기존의 것 보다 6개를 줄일 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-29&quot;&gt;주판&lt;/h4&gt;

&lt;p&gt;하지만 더 효율적인 방법이 나타났다.
바로 주판이다. 5개로 하나의 자리를 표현하는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;3 자릿수를 표현하려면 15개의 램프가 필요하다. 이것으로 6개를 더 줄일 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;램프 4개로 16가지를 표현할 수 있음에도 불구하고 10가지만 사용한다면 아까운 느낌이 든다. 좀 더 간격을 채워 넣을 방법이 없을까?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;1의 자리, 10의 자리, 100의 자리(10 x 10), 1000의 자리(10 x 10 x 10)로 자릿수를 맞추는 대신, 1의 자리, 2의 자리, 4의 자리(2 x 2), 8의 자리(2 x 2 x 2)로 맞추자는 발상이다! 이것이 바로 2진수다!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2진수를 사용하면 10개의 램프로 0부터 1,023까지 표현이 가능하다&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-30&quot;&gt;8진수&lt;/h4&gt;

&lt;p&gt;8가지 부호를 사용해서 자릿수를 맞추고 있어서 8진수라고 불린다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 묶음에 2 x 2 x 2로 8가지 패턴이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-31&quot;&gt;16진수&lt;/h4&gt;

&lt;p&gt;16가지 부호를 사용해서 자리를 맞추고 있기 때문에 16진수라고 불린다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8진수 수치의 앞자리에는 0이나 0o를 붙이고, 16진수 수치에는 0x를 붙이는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-32&quot;&gt;실수는 어떻게 표현할까?&lt;/h3&gt;

&lt;p&gt;1.5나 0.001 등 소수점이 있는 ‘실수’는 어떻게 표현할까?&lt;/p&gt;

&lt;p&gt;두가지 방법이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고정 소수점&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부동 소수점&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;고정 소수점 ( 소수점을 어디에 붙일지 정한다 )
        &lt;ul&gt;
          &lt;li&gt;예를 들면 ‘이 정수는 소수점을 4자리 이동시켜서 소수점 이하 4자리를 소수부’라고 정하면 1이 0.0001이 되고, 100이 0.0100, 즉, 0.01이 된다. 하지만 0.0001보다 작은 값을 표현 할 수가 없고, 각각의 값에 대해 ‘어디까지 소수부로 정했는지’를 사람이 기억해야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부동 소수점 ( 어디부터 소수부인지의 정보 자체를 값에 포함시킨다 )
        &lt;ul&gt;
          &lt;li&gt;소수점을 이동시키는 방법으로 이 방법을 사용하면 1,023 이후에 0이 30개 계속되는 큰 숫자를 표현 할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ieee-754--&quot;&gt;현재는 표준화 되어 IEEE 754가 적용되고 있다&lt;/h4&gt;

&lt;p&gt;IEEE 754에서는 ‘지수부’가 소수점 위치에 해당하고, ‘가수부’가 유효 숫자의 소수점 이하 부분에 해당한다.&lt;/p&gt;

&lt;h4 id=&quot;section-33&quot;&gt;문제점&lt;/h4&gt;

&lt;p&gt;대부분의 경우에는 별 문제가 없지만, ‘3 나누기 10’의 결과를 표현하려고 하면, 10 진수로는 0.3을 사용해 표현 할 수 있지만, 2 진수의 경우 무한 소수가 되어 버린다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;p&gt;컴퓨터는 비트열만으로 그것을 정수로 해석해야 할 지 부동 소수점으로 해석해야 할 지 알 수가 없다. 따라서, ‘이 값이 어떤 종류인지’ 정보가 별도로 필요한데 이것이 바로 ‘형’이다.&lt;/p&gt;

&lt;h4 id=&quot;fortran-&quot;&gt;초기 FORTRAN의 형&lt;/h4&gt;

&lt;p&gt;변수명에 안에 든 것이 무엇인지 표현하기 위한 규칙을 만들게 되었다. 초기 FORTRAN에서는 변수명 선두가 I ~ N 이면 정수, 그 이외이면 부동 소수점이 들어 있다는 규칙을 사용했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다른 한가지 방법은 언어 처리계에 ‘이 변수는 정수다’라고 알려서 사람이 아닌 컴퓨터가 기억해두는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-34&quot;&gt;정수끼리, 부동 소수점끼리의 연산&lt;/h4&gt;

&lt;p&gt;컴퓨터는 형 정보를 참고해서 무엇을 할 지 정한다. x와 y 둘 다 정수인 경우는 정수 덧셈을 하고, x와 y 둘 다 부동 소수점인 경우에는 부동 소수점 덧셈을 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;한쪽이 정수고 다른 한쪽이 부동 소수점이라면?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;초기 FORTRAN의 경우 에러 처리를 했다. 하지만 C언어에서는 부동 소수점으로 암묵적 변환을 시킨다.&lt;/p&gt;

&lt;p&gt;하지만 C언어의 경우, 이것은 프로그래머가 어떤 형인지 기억해두지 않으면, 특정 코드를 보고도 소수점 이하를 버리는지 아닌지를 알 수가 없는 단점이 있다.&lt;/p&gt;

&lt;p&gt;이러한 설계는 많은 언어가 오랜 시간동안 사용해 왔던 것이기 때문에 ‘원래 그런 것이다’라고 생각하는 프로그래머가 많겠지만 이것은 불변의 물리 법칙이 아닌, 사람이 만든 설계일 뿐이다.&lt;/p&gt;

&lt;h3 id=&quot;section-35&quot;&gt;형의 다양한 전개&lt;/h3&gt;

&lt;p&gt;원래는 값의 종류를 저장하기 위해 사용되었던 형은 다양하게 응용되고 있다.&lt;/p&gt;

&lt;h4 id=&quot;section-36&quot;&gt;사용자 정의형과 객체 지향&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;언어가 가지고 있는 기본적인 형을 조합해서 새로운 형을 만드는 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정수 등 ‘데이터’뿐만 아니라 함수 등 ‘데이터’를 처리하는 기능도 형으로 정리&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이런 형에 클래스(class)라는 이름을 붙였다. 이것이 제2의 객체 지향의 발명이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-37&quot;&gt;사양으로서 형&lt;/h3&gt;

&lt;h4 id=&quot;section-38&quot;&gt;공개와 비공개를 나누다&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;‘형은 사양이다’라는 개념이 등장했다. 구조체나 클래스를 구성하는 형을 전부 공개하지 않고 최소한만을 공개한다는 것이다. 외부와 작업하는 부분만을 형으로 공개하고, 상세 구현 방법은 숨긴다는 발상이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-39&quot;&gt;인터페이스로 발전&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;‘형은 사양이다’라는 개념은 더욱 진화해서 구체적인 구현 방법을 가지고 있지 않는 형이 탄생했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-40&quot;&gt;총칭형, 제네릭스, 템플릿&lt;/h3&gt;

&lt;p&gt;‘일부만 바꾸고 싶은데 전부 다시 정의해야 하는 것은 이상하다. 재사용하고 싶다’라는 필요가 생겨났고, ‘구성 요소의 형을 일부만 바꾸는 형’, 즉 총칭형이 탄생했다. ‘형이 인수를 가지고 형을 만드는 함수’가 탄생한 것이다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C++의 템플릿(template), Java(generic)등이 그러한 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-41&quot;&gt;동적 형결정&lt;/h4&gt;

&lt;p&gt;‘종류 정보’를 값과 함께 세트로 가지고 있는 것을 ‘동적 형결정’이라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-42&quot;&gt;어떻게 표현하고 있을까?&lt;/h4&gt;

&lt;p&gt;동적 형결정 언어에서 형 선언이 필요 없는 것은 메모리 상에서 동일한 형으로 취급되도록 설계되어 있기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 값은 정수든 부동 소수점이든 문자열이든 모두 PyObject 형으로 취급되도록 머리 부분이 모두 같은 형태로 되어 있다. 그리고 PyObject 형의 구조 안에는 값의 종류 정보를 저장할 수 있는 공간이 마련되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 방법으로 값의 종류를 관리하면 종래의 정적 형결정 언어에서는 할 수 없었던 유연한 처리가 가능해지지만, 동적 형결정 언어에서는 형 체크를 할 수 없기 때문에 일부 버그는 실행 전에 찾아낼 수가 없다.&lt;/p&gt;

&lt;h3 id=&quot;section-43&quot;&gt;형 추론&lt;/h3&gt;

&lt;p&gt;형 추론은 원래 OCaml이나 Haskell 등의 ML계 언어가 잘하는 분야였지만, 최근에는 Java VM 상에서 동작하는 언어인 Scala등 형 추론을 장점으로 부각시키는 언어가 늘고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재는 정적 형결정과 동적 형결정과 같이 정보 저장 장소나 사용하는 타이밍이 다른 것까지 포함해서 ‘형’이라 부른다. 이 때문에 형이 무엇인지 더욱 이해하기 어렵게 되었다. 어떤 정보가 어디에 있고 어떤 타이밍에 사용되는지의 관점에서 보아야 이해하기 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-44&quot;&gt;컨테이너와 문자열&lt;/h3&gt;

&lt;p&gt;무언가를 넣는 상자를 컨테이너라고 부른다고 하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;언어마다 다양한 컨테이너가 있다.&lt;/li&gt;
  &lt;li&gt;각각의 컨테이너에는 장단점이있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;컨테이너에 넣은 데이터는 메모리에 저장된다. 메모리에는 정해진 크기의 상자가 정렬되어 있으며, 각 상자는 번호가 부여되어 있는 물품 보관함 같은 것이다&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너 종류에 따라서 메모리 저장 방법이 다르다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;메모리 : 정해진 크기의 상자가 정렬되어 있고 각 상자에 번호가 부여되어 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-45&quot;&gt;배열과 연결 리스트&lt;/h4&gt;

&lt;p&gt;두 종류의 컨테이너가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;배열&lt;/li&gt;
  &lt;li&gt;연결 리스트&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-46&quot;&gt;배열에 값을 삽입하는 경우&lt;/h4&gt;

&lt;p&gt;배열에서는 ‘값을 순서대로 넣는’방법으로 저장한다. 배열에 요소를 삽입 할 때는 삽입된 위치보다 뒤에 있는 요소를 전부 다른 위치로 옮겨야 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-47&quot;&gt;연결 리스트에 값을 삽입하는 경우&lt;/h4&gt;

&lt;p&gt;연결 리스트에서는 메모리에 순서대로 정렬해있을 필요가 없다. ‘다음 요소가 들어있는 위치’를 메모리 상에 넣어두기 때문이다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연결 리스트에 삽입 할 때는 상자 두개를 추가하고, 상자 하나만 변경하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-48&quot;&gt;장단점&lt;/h4&gt;

&lt;p&gt;배열에서는 삭제된 요소보다 뒤에 있는 것을 모두 움직여야 하기에 O(n)이 돼버리지만, 연결 리스트에서는 ‘다음 요소는 어딘지’의 정보를 바꾸기만 하면 되기에 O(1)이다.&lt;/p&gt;

&lt;p&gt;배열에서는 순서대로 나열하고 있기 때문에 금방 n번째 요소를 알 수 있지만, 연결 리스트에서는 각 요소를 자신이 원하는 곳에 넣을 수 있기 때문에 이 방법을 사용 할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;section-49&quot;&gt;언어에 따른 차이&lt;/h4&gt;

&lt;p&gt;Java나 Python, Ruby 등 대부분의 언어에서는 배열이 가장 기본적인 컨테이너로 제공되고 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-50&quot;&gt;사전, 해쉬, 연상 배열&lt;/h3&gt;

&lt;p&gt;‘값을 복수 개 넣는다’는 목적을 위해 배열과 연결 리스트 등 여러 가지 방법이 있었듯이, ‘문자열과 값의 대응을 넣는다’는 목적을 위해서 몇 가지 구현 방법이 있다. 자주 사용되는 것이 해쉬테이블과 트리다.&lt;/p&gt;

&lt;h4 id=&quot;section-51&quot;&gt;해쉬 테이블&lt;/h4&gt;

&lt;p&gt;문자열을 인수로 받아서 정수를 반환하는 ‘해쉬 함수’를 사용해서 문자열과 값의 대응 관계를 표현하는 방법이다.&lt;/p&gt;

&lt;h4 id=&quot;section-52&quot;&gt;트리&lt;/h4&gt;

&lt;p&gt;트리는 데이터의 구조체다. ‘왼쪽 자식’, ‘오른쪽 자식’에 두 개의 화살표가 연결된다. 습관적으로 아래를 향해서 뻗어나가기 때문에 나무라기 보단 나무 뿌리처럼 보일 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;section-53&quot;&gt;요소를 꺼내는 시간&lt;/h4&gt;

&lt;p&gt;배열에 키와 값을 넣고 어떤 키에 대응하는 값을 찾고자 한다고 하자. 어떤 키가 어디에 있는지 모르기 때문에 배열의 맨 처음부터 순서대로 읽어나간다. 첫 부분에서 찾을 수도 있고, 맨 마지막에서 찾을 수도 있다. 평균적으로 n/2회 체크가 필요하다. 즉, O(n)이 된다.&lt;/p&gt;

&lt;h4 id=&quot;section-54&quot;&gt;트리의 경우&lt;/h4&gt;

&lt;p&gt;트리의 경우 높이가 하나씩 증가하면 요소 수는 약 2배가 된다. 반대로 말하면, 데이터량이 2배가 될 때마다 필요한 비교 횟수가 1회 증가한다. 즉, 트리에서 꺼내는 처리의 오더는 O(log n)이다.&lt;/p&gt;

&lt;h4 id=&quot;section-55&quot;&gt;해쉬 테이블의 경우&lt;/h4&gt;

&lt;p&gt;키에 대응하는 값을 꺼내기 위해서는 ‘키를 해쉬 함수로 변환’, ‘배열에 해당 장소에 있는 값을 읽는’ 작업이 필요하다. 이 작업은 데이터량과 관계가 없다. 즉 O(1)이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해쉬 테이블의 오더가 가장 작다.&lt;/li&gt;
  &lt;li&gt;해쉬 테이블은 값을 넣기 위해 큰 배열을 사용하고 있기 때문에 메모리 소모량이 매우 크다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 절약 » 배열&lt;/li&gt;
  &lt;li&gt;계산 시간 » 해쉬 테이블&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-56&quot;&gt;만능 컨테이너란 없다&lt;/h3&gt;

&lt;p&gt;절대 정답은 존재하지 않는다. 자신의 상황에 맞게 적합한 균형을 찾는 게 중요하다.&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h3 id=&quot;section-57&quot;&gt;문자란?&lt;/h3&gt;

&lt;h4 id=&quot;section-58&quot;&gt;문자 집합과 문자 부호화 방식&lt;/h4&gt;

&lt;p&gt;부호화 방법을 공유하고 있지 않은 사람과는 작업을 할 수가 없다.&lt;/p&gt;

&lt;h4 id=&quot;section-59&quot;&gt;컴퓨터 이전 시대의 부호화&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;모스부호&lt;/li&gt;
  &lt;li&gt;보 코드&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모스부호 : 모스부호는 사람이 스위치를 눌러서 송신하고, 사람이 귀로 들어 수신한다는 규칙으로 만들어진 부호화 방법이었다. 이 방법은 1초 동안 송신할 수 있는 양과 수신할 수 있는 양에 한계가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;보 코드 : 하나의 문자를 On/Off 5개의 조합(5비트)으로 표현하는 것이다. 즉 SOS는 15비트로 표현 할 수 있었다. 모스부호의 절반으로 효율이 좋다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-60&quot;&gt;컴퓨터 시대의 부호화&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;EDSAC 문자 코드&lt;/li&gt;
  &lt;li&gt;ASCII와 EBCDIC 시대&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EDSAC : 텔렉스와 같이 한 문자에 5비트를 사용했고, 숫자, 문자, 시프트를 사용해서 출력했다. 보 코드와 같은 발상이다. 단지 어떤 문자를 어떤 비트열에 할당할지가 달랐다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ASCII : ASCII는 한 문자당 7비트를 사용하는 부호화 방식이다. 7비트로 128 종류의 문자를 표현 할 수 있기 때문에 시프트로 변환할 필요가 없어졌다. ASCII가 부호화하는 문자 세트에는 EDSAC보다 많은 기호와 제어 코드, 그리고 소문자 알파벳도 포함되어 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ASCII와 EBDCIC은 알파벳 대소문자나 기호를 부호화하는 기법&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;unicode--&quot;&gt;Unicode에 의한 통일&lt;/h4&gt;

&lt;p&gt;인터넷이 발전하고 다양한 나라에서 만들어낸 데이터가 교환되기 시작하면서 이 문제가 표면 위로 떠올랐다. 여러 나라가 정한 ‘규칙’을 이해하지 않으면 안 되는 상황이 되었다.&lt;/p&gt;

&lt;p&gt;전 세계의 문자를 부호화하는 방법을 만들자는 움직임이 시작됐고, 1984년에 국제 표준화 기구(ISO)가 작업을 시작하였다. 이렇게 해서 전 세계 문자를 포함한 문자 집합 Unicode가 탄생했다.&lt;/p&gt;

&lt;h3 id=&quot;section-61&quot;&gt;문자열이란?&lt;/h3&gt;

&lt;p&gt;문자열이란 문자가 정렬해있는 것이다. 하지만 문자에 따라선 문자열을 표현하는 방법은 제 각각이다.&lt;/p&gt;

&lt;h4 id=&quot;pascal-----c-&quot;&gt;길이 정보를 가지고 있는 Pascal 문자열, 가지고 있지 않은 C 문자열&lt;/h4&gt;

&lt;p&gt;C언어와 Pascal은 둘 다 ‘하나의 문자를 8비트’로 정의하고 있다. Pascal 문자열은 제일 앞 부분에 문자열 길이를 기록해둔다는 규칙을 채용하고 있다. 그러나 C언어 문자열은 ‘문자열이 시작되는 메모리 상의 위치’만을 가지고 있다. 길이 정보를 가지고 있지 않아서, 해당 위치에서 어디까지가 문자열인지 알 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NUL 문자로 문자열의 끝을 표현한다&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NUL 문자는 0에 대응하는 문자로, C언어 코드에서는 \0으로 표현한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Python은 Java와 같이 16비트 문자열인 ‘Unicode 문자열’과 Pascal과 같은 8비트 문자열 모두를 지원하는 언어다&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Python 2.7에서는 Unicode 문자열에 바이트열을 결합할 경우 바이트열이 ASCII로만 이루어진 경우에 한해 성공한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python 3.0에서는 Unicode 문자열에 바이트열을 결합하면 항상 실패한다. 명시적으로 Unicode 문자열로 변환하고 나서 결합한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ruby-19-&quot;&gt;Ruby 1.9의 도전&lt;/h4&gt;

&lt;p&gt;Ruby는 독자 노선을 가고 있었다. Ruby 1.9부터 문자열은 8비트로 하고 ‘부호화 방식 정보’를 추가로 보유하도록 했다. 이 방법은 Unicode 문자 집합에 포함되지 않는 문자를 손쉽게 쓸 수 있다는 점이 장점이다.&lt;/p&gt;

&lt;h2 id=&quot;section-62&quot;&gt;병행처리&lt;/h2&gt;

&lt;h3 id=&quot;section-63&quot;&gt;병행 처리란?&lt;/h3&gt;

&lt;p&gt;복수의 처리를 시간축 상에 오버랩에서 실행하는 것을 병행 처리라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-64&quot;&gt;잘게 분할해서 실행한다&lt;/h4&gt;

&lt;p&gt;사람의 눈으로 보면 프로그램이 계속 동작하고 있는 것처럼 보이지만, 실제로는 잘게 분할해서 실행되고 있는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;section-65&quot;&gt;처리를 변경하는 2가지 방법&lt;/h3&gt;

&lt;p&gt;‘언제 교대할 것인가?’를 정하는 방법은 크게 두가지로 나눌 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;협력적 멀티태스크&lt;/li&gt;
  &lt;li&gt;선점적 멀티태스크&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;협력적 멀티태스크 : ‘타이밍이 좋은 시점에서 교대하는’방법이다. 처리가 일단락되는 시점에 자발적으로 처리 교대를 하는 방법이다. 이 방법으로 구현된 멀티태스크(multi-task, 병행 처리)를 협력적 멀티태스크라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;선점적 멀티태스크 ( 일정 시간에 교대한다 ) : 개별 프로그램과 입장이 다른 프로그램(태스크 스케줄러)이 존재한다. 이 프로그램이 일정 시간마다 지금 실행되고 있는 처리를 강제적으로 중단시켜서 다른 프로그램이 실행될 수 있도록 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-66&quot;&gt;경합 상태 방지법&lt;/h3&gt;

&lt;h4 id=&quot;section-67&quot;&gt;경합 상태의 3가지 조건&lt;/h4&gt;

&lt;p&gt;평행해서 동작하고 있는 2가지 처리 간에 경합 상태가 발생하기 위해서는 다음 3가지 조건을 모두 만족해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;2가지 처리가 변수를 공유하고 있다&lt;/li&gt;
  &lt;li&gt;적어도 하나의 처리가 그 변수를 변경한다&lt;/li&gt;
  &lt;li&gt;한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 3가지 조건 중 하나라도 제거 할 수 있다면 병행 실행 시에도 안정된 프로그램을 만들 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;section-68&quot;&gt;공유하지 않는다 ( 프로세스와 액터 모델 )&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;처음부터 아무것도 공유하지 않으면 1.은 발생하지 않기 때문에 경합 상태를 신경 쓸 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-69&quot;&gt;프로세스에서는 메모리를 공유하지 않는다&lt;/h4&gt;

&lt;p&gt;UNIX에서는 실행 중의 프로그램을 ‘프로세스’라고 부른다. 서로 다른 프로세스는 메모리를 공유하지 않는다. 때문에 복수의 프로그램이 메모리 상에서 경합 상태를 일으킬 일은 없다. 데이터베이스 접속, 파일 읽고 쓰기 등 무엇인가를 공유했을때만 주의하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;section-70&quot;&gt;공유하지 않는 접근법은 성공했을까?&lt;/h4&gt;

&lt;p&gt;현재까지도 스레드를 사용해서 공유 메모리를 어떻게 다뤄야 할지 고심해가면서 프로그램이 만들어지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액터 모델 : ‘메모리를 공유하지 않는다’는 설계 방침에서의 또 다른 흐름이 바로 액터 모델이다. 1973년에 발표된 병행 처리를 위한 모델이다. ( 병행해서 동작하는 복수의 처리가 정보를 교환하는 방법으로, ‘메모리를 공유한다’가 아닌 ‘메시지를 보낸다’를 제안했다 )&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;const-val-immutable&quot;&gt;변경하지 않는다 - const, val, immutable&lt;/h4&gt;

&lt;p&gt;‘메모리를 공유해도 변경하지 않으면 문제가 없다’는 2.에 대한 대응책도 있다.&lt;/p&gt;

&lt;p&gt;이 방식을 강하게 어필하고 있는 언어로써, 모든 값이 변경 불가능한 Haskell 등을 들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-71&quot;&gt;끼어들지 않는다&lt;/h3&gt;

&lt;p&gt;경합 상태가 발생하는 조건 3.인 ‘한 쪽의 처리가 한 단락 마무리 되기 전에 다른 한 쪽의 처리가 끼어들 가능성이 있다’를 방지하기 위해서는 어떻게 하면 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;section-72&quot;&gt;협력적 스레드의 사용 - 파이버, 코루틴, 그린 스레드&lt;/h4&gt;

&lt;p&gt;파이버나 코루틴, 그린 스레드 등으로 불리는 기법을 사용하는것이 그 방법이다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;스레드가 선점성을 가지고 끼어드는 원인이 되기 때문에 협력적 스레드를 만들면 된다는 생각이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;협력적 멀티태스크이기 때문에 어떤 스레드가 CPU를 독점하면 다른 스레드의 처리가 멈춘다. 어디까지나 각 스레드가 협력적으로 최적의 순간을 맞춘다는 사실을 전제로 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-73&quot;&gt;끼어들면 곤란해지는 처리에 표식을 붙인다 - 락, 뮤텍스, 세마포어&lt;/h4&gt;

&lt;p&gt;‘지금 끼어들면 곤란해’라는 표식을 공유하는 방법이다. 예를 들어, 어떤 메모리 값이 0이 아니면 이것은 ‘다른 스레드가 끼어들면 곤란한 처리를 하고 있어’라고 정해 두는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;section-74&quot;&gt;락의 문제점과 해결책&lt;/h3&gt;

&lt;h4 id=&quot;section-75&quot;&gt;락의 문제점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;교착 상태가 발생한다&lt;/li&gt;
  &lt;li&gt;합성할 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-76&quot;&gt;트랜잭션 메모리&lt;/h4&gt;

&lt;p&gt;이 문제를 해결하려고 하는 것이 트랜잭션 메모리라는 접근법이다. 데이터베이스의 트랜잭션 기법을 메모리에 적용한 것이다. 개념은 ‘실험적으로 해보고, 실패하면 처음부터 다시 고쳐서 하고, 성공하면 변경을 공유한다’이다.&lt;/p&gt;

&lt;h3 id=&quot;section-77&quot;&gt;트랜잭션 메모리의 역사&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;하드웨어로 구현&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;1986년에 Symbolics라는 회사가 트랜잭션을 하드웨어로 구현하려는 아이디어를 제안했다. 상업적으로는 성공하지 못했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;소프트웨어로 구현&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;그 후 10년이 지난 1995년에 소프트웨어로 트랜잭션 메모리를 구현하려는 논문이 발표되었다. 그리고 10년 더 지난 후 2005년에 Microsoft가 Concurrent Haskell을 사용해서 소프트웨어적으로 트랜잭션 메모리를 실현하는 논문을 발표했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 전후로 여러 언어에 소프트웨어 트랜잭션 메모리 기능이 탑재되었다.&lt;/p&gt;

&lt;h3 id=&quot;section-78&quot;&gt;객체와 클래스&lt;/h3&gt;

&lt;h4 id=&quot;section-79&quot;&gt;객체 지향이란?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;C++ 설계자인 Bjarne Stroustrup의 경우&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;객체 지향 프로그래밍이란 사용자 정의형과 상속을 사용한 프로그래밍이다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;또한 상태를 가진 객체가 메세지를 주고 받아서 커뮤니케이션하는 프로그램이다!&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-80&quot;&gt;객체는 현실세계의 모형&lt;/h4&gt;

&lt;p&gt;현실 세계에 있는 ‘사물’의 ‘모형’을 컴퓨터 안에 만들려면 어떻게 하면 될까? 라는 의문을 해결하기 위해 ‘객체 지향’이라는 개념이 탄생했다.&lt;/p&gt;

&lt;h4 id=&quot;section-81&quot;&gt;클래스란?&lt;/h4&gt;

&lt;p&gt;C++에서는 ‘클래스는 사용자가 정의할 수 있는 형’이다.&lt;/p&gt;

&lt;p&gt;C++은 정적 형결정 언어이고 Ruby나 Python은 동적 형결정 언어다.&lt;/p&gt;

&lt;p&gt;단, Java는 예외다. ‘클래스라는 부품을 정의하고, 그것을 조립해나가는 것이 프로그래밍이다’라고 정의하고 있다. 따라서 Java에서는 클래스가 반드시 필요한 조건이다.&lt;/p&gt;

&lt;h3 id=&quot;section-82&quot;&gt;변수와 함수를 합쳐서 모형을 만드는 법&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;모듈(Module)&lt;/li&gt;
  &lt;li&gt;함수도 변수도 동일하게 해쉬에 넣는 방법&lt;/li&gt;
  &lt;li&gt;클로저(Closure)&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모듈 : 함수를 합쳐두기 위한 패키지와 변수를 합쳐두기 위한 해쉬를 연결하는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수도 변수도 동일하게 해쉬에 넣는 방법 : JavaScript등의 언어가 채용하고 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클로저 : 함수 실행 시의 이름 공간의 변수를 하나로 묶기 위해 사용하는 방법이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-83&quot;&gt;모듈, 패키지&lt;/h3&gt;

&lt;h4 id=&quot;section-84&quot;&gt;모듈, 패키지란 무엇인가?&lt;/h4&gt;

&lt;p&gt;‘관련성이 높은 함수나 변수의 묶음’이다.&lt;/p&gt;

&lt;p&gt;모듈은 ‘하나로 모으는 기법’이다.&lt;/p&gt;

&lt;p&gt;Python이나 Ruby는 ‘모듈’이라 하고, Java나 Perl에서는 ‘패키지’라는 이름으로 부른다&lt;/p&gt;

&lt;h4 id=&quot;perl---&quot;&gt;Perl 패키지로 객체를 만든다&lt;/h4&gt;

&lt;p&gt;Perl 패키지는 함수나 변수를 하나로 묶어서 그것에 이름을 붙일 수 있는 기능이다.&lt;/p&gt;

&lt;p&gt;하지만&lt;/p&gt;

&lt;p&gt;&lt;em&gt;모듈만으로는 부족하다&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-85&quot;&gt;인수로 개별 해쉬를 전달한다&lt;/h4&gt;

&lt;p&gt;Perl에는 사전을 만드는 기능이 언어 처리계 자체에 탑재되어 있다. Perl은 이것은 ‘해쉬’라고 부른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해쉬는 함수를 호출 할 때 해쉬를 인수로 전달한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-86&quot;&gt;초기화 처리도 패키지에 넣는다&lt;/h4&gt;

&lt;p&gt;새로운 카운터를 만들 때는 프로그래머가 직접 명시를 해줘야만 한다. 값을 어떻게 초기화할지를사람이 기억하지 않으면 안되는 것이다. 이것은 좋지 않은 설계다. 이런 경우는 ‘초기화 방법’을 함수로 만들어서 패키지에 넣으면 된다.&lt;/p&gt;

&lt;h4 id=&quot;section-87&quot;&gt;해쉬와 패키지를 연결한다&lt;/h4&gt;

&lt;p&gt;데이터 저장소와 해당 데이터에 대응하는 동작의 집합(모듈)을 연결시킴으로 하나의 묶음으로 정리된 이해하기 쉬운 코드를 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-88&quot;&gt;함수도 해쉬에 넣을 수 있다!&lt;/h3&gt;

&lt;h4 id=&quot;section-89&quot;&gt;퍼스트 클래스&lt;/h4&gt;

&lt;p&gt;JavaScript가 도입하고 있는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;‘변수에 대입한다’, ‘함수의 인수로 전달한다’, ‘함수의 반환값으로 전달한다’ 등이 가능한 값을 ‘퍼스트 클래스값’이라고 부른다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;차별 대상이 아닌 일급 시민을 의미한 표현이다. 최근의 언어 Java나 Perl, Python 등에서 문자열은 퍼스트 클래스 값이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;JavaScript에서는 함수도 퍼스트 클래스 값이다. 함수를 변수에 대입하거나 함수의 반환값으로 전달하는 것도 가능하다&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-90&quot;&gt;복수 개 카운터를 만든다&lt;/h4&gt;

&lt;p&gt;카운터를 손쉽게 복수 개 만들기 위해서 해쉬로 초기화하기 위한 함수를 만들면 아주 간단하게 만들 수 있다. 단순히 해쉬를 makeCounter 안으로 이동하기만 하면 된다.&lt;/p&gt;

&lt;p&gt;Perl 패키지와 동일하게 다음 이점들을 가지게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;복수 객체를 만들 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나의 묶음으로 보인다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;초기화 방법을 사람이 기억하지 않아도 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-91&quot;&gt;클로저&lt;/h3&gt;

&lt;h4 id=&quot;section-92&quot;&gt;클로저란?&lt;/h4&gt;

&lt;p&gt;이것은 객체적인 것을 만들기 위한 기술이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클로저라는 특수한 구문이 있는 것은 아니다. 함수를 함수 안에 정의하고, 내포할 수 있는 정적 스코프가 있어서 함수를 반환값으로 사용하거나 변수에 대입하여 사용한다는 개념이다. 즉, 간단한 내포 구조를 사용함으로 상태 정보를 가진 함수를 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-93&quot;&gt;왜 클로저라고 부를까?&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;왜 이것을 클로저라고 부를까? 그것은 자유 변수를 포함한 식을 ‘열린 식’이라고 부르고, 그 자유 변수의 바인딩을 조합함으로 해당 식을 닫고 있기 때문이다.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-94&quot;&gt;클래스&lt;/h3&gt;

&lt;p&gt;언어 설계자가 ‘이 언어에서는 이것을 클래스라고 부른다’고 정한 것으로, 다양한 정의가 존재한다.&lt;/p&gt;

&lt;h4 id=&quot;hoare--&quot;&gt;Hoare가 생각한 클래스&lt;/h4&gt;

&lt;p&gt;‘현실 세계의 사물(object)은 편의상 상호 배타적 종류(classes)로 분류될 수 있다’고 기술하고 있다. 그리고 ‘어떤 종류의 사물을 더욱 세분화된 종류(subclasses)로 분류할 수 있으면 편리하다’고 주장하고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;처음 시작은 ‘분류’였던 것이다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;현재 사용되고 있는 ‘클래스를 상속한다’, ‘클래스는 인스턴스다’라는 개념이 등장한것은 보다 나중의 이야기다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;c-&quot;&gt;C++ 클래스&lt;/h4&gt;

&lt;p&gt;클래스는 타입(type)이다. 이것이 C++을 이루는 아주 중요한 원리다. C++에서 class가 사용자 정의 타입을 의미한다면 왜 그것을 type이라고 부르지 않는가? 내가 class를 선택한 것은 계속 나오는 새로운 용어를 발명하는 것이 귀찮았기 때문이고, Simula의 class라면 아무도 당황하지 않을 것이라 판단했기 때문이다. - « C++로 배우는 프로그래밍의 원리와 설계 »&lt;/p&gt;

&lt;h4 id=&quot;section-95&quot;&gt;사양으로서 역할&lt;/h4&gt;

&lt;p&gt;C++에게 있어서 클래스(=형)란 사양을 표명한 것이기도 했다. 즉, 클래스는 ‘객체가 어떤 메소드를 갖고 있고, 어떤 메소드를 갖고 있지 않은가’라는 사양을 선언하는 역할도 했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;그 메세지를 받은 객체가 어떤 동작(무언가를 실행할지, 에러처리할지 아니면 무시할 것인지)을 할지는 수신 객체가 자유롭게 결정 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-96&quot;&gt;클래스의 3가지 역할&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;결합체를 만드는 생성기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 조작이 가능한지에 대한 사양&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드를 재사용하는 단위&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;객체 지향은 현실세계의 사물 모형을 만들기 위해 만들어졌고, 언어마다 구현 방법이나 ‘객체 지향’이 의미하느 바가 다르다!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-97&quot;&gt;상속을 통한 재사용&lt;/h3&gt;

&lt;h4 id=&quot;section-98&quot;&gt;상속이란?&lt;/h4&gt;

&lt;p&gt;어떤 클래스에서 선언된 것은 그것을 세분화한 ‘자식 클래스’에게도 자동으로 이어지는 게 좋다. 이것이 ‘상속’이다!!!&lt;/p&gt;

&lt;h4 id=&quot;section-99&quot;&gt;상속에 관한 다양한 접근법&lt;/h4&gt;

&lt;p&gt;상속은 크게 3가지 측면으로 접근할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;일반화/특수화&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공통 부분을 추출&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;차분 구현&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;일반화/특수화 : ‘부모 클래스로 일반적인 기능을 구현하고, 자식 클래스로 목적에 특화된 기능을 구현한다’는 접근이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공통 부분을 추출 : ‘복수 클래스의 공통 부분을 부모 클래스로서 추출하면 좋다’는 접근법이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;차분 구현 : ‘상속 후 변경된 부분만 구현하면 효율이 좋다’는 접근법이다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-100&quot;&gt;상속은 양날의 칼&lt;/h4&gt;

&lt;p&gt;‘상속을 많이 사용하면 코드가 복잡해진다. 제어를 추가해야 한다’는 의견이 나오고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상속을 반복하면, 코드 영향 범위가 넓어져서 이해하기 어렵게 된다. 이해하기 쉽게 하기 위해서는 상속 트리의 깊이를 낮추는 것이 중요하다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-101&quot;&gt;리스코프의 치환 원칙&lt;/h4&gt;

&lt;p&gt;CLU라는 언어의 설계자인 Liskov가 1987년에 제창한 것으로, 현재는 자식 클래스를 만들 때 주의해야 할 사항으로 자주 언급되는 것이 ‘리스코프의 치환 원칙’이다.&lt;/p&gt;

&lt;h3 id=&quot;section-102&quot;&gt;다중 상속&lt;/h3&gt;

&lt;h4 id=&quot;section-103&quot;&gt;하나의 사물을 복수로 분류&lt;/h4&gt;

&lt;p&gt;현실세계에서 하나의 사물이 복수의 분류에 해당하는 경우가 있기 때문에 그것을 모델화하는 프로그래밍 언어가 복수의 클래스를 상속할 수 있어야 한다. 이것이 다중 상속이다.&lt;/p&gt;

&lt;h4 id=&quot;section-104&quot;&gt;코드 재사용에 편리한 다중 상속&lt;/h4&gt;

&lt;p&gt;다중 상속은 코드 재사용 방법으로도 매우 좋은 도구다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다중 상속이 가능한 언어에서는 단순히 양쪽 클래스를 상속하기만 하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-105&quot;&gt;다중 상속의 문제점 - 거듭되는 충돌&lt;/h3&gt;

&lt;p&gt;다중 상속은 편리한 기능이다. 그런데 다중 상속은 어떻게 메소드의 이름을 해결하고 있는 걸까? 클래스에게 ‘x의 값은 무엇인가?’라고 물으면 어떻게 대답할까? 이름해결의 문제가 발생한다.&lt;/p&gt;

&lt;h4 id=&quot;section-106&quot;&gt;해결책 1: 다중 상속을 금지한다&lt;/h4&gt;

&lt;p&gt;Java는 클래스 다중 상속을 금지하기로 했다. 클래스 다중 상속을 인정하지 않으면 앞의 경우와 같은 문제가 발생하지 않는다. 다중 상속을 버림으로 문제를 해결했지만, 대신 다중 상속의 편리함 또한 버리게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위임 : 사용하고 싶은 코드를 가지고 있는 클래스 객체를 만들고, 필요에 따라 해당 클래스에 처리를 맡기는 방법이다. 상속을 사용해서 형이나 이름 공간까지 함께 계승하는 것이 문제의 원인이기 때문에, 단순히 객체를 보유하기만 하면 문제를 막을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인터페이스 : Java는 다중 상속을 금지하고 있다고 설명했지만, Java에도 다중 상속이 가능한 것이 있다. 바로 인터페이스 이다. 인터페이스는 ‘코드를 가지고 있지 않는 클래스’다. ‘인터페이스를 상속한 클래스는 반드시 xx라는 이름의 메소드를 가지고 있다’라는 ‘사양’만 가지고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-107&quot;&gt;해결책 2: 메소드 해결 순서를 고민한다&lt;/h4&gt;

&lt;p&gt;‘자신이 모른다면 앞에 쓰여있는 부모부터 순서대로 확인한다’는 규칙(깊이 우선 탐색)으로 해결될까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;깊이 우선 탐색의 문제점 : 어떤 클래스 Base를 복수의 클래스 derived1, derived2가 상속하고 있다고 하자. 그리고 이 두 클래스를 상속하는 Multi가 있다고 하자. 이 같은 형태의 다중 상속을 ‘마름모 상속’이라고 부른다. 메소드가 재정의(오버라이드)되는 경우가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C3 선형화로 순서를 정한다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;C3 선형화는 1996년에 제안된 알고리즘으로, 2가지 제약 조건을 만족하도록 클래스에 순서를 매겨서 정렬한다. 그 제약 조건은 다음과 같다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;부모 클래스는 자식 클래스보다 먼저 탐색되지 않는다.&lt;/li&gt;
          &lt;li&gt;어떤 클래스가 복수의 부모 클래스를 상속하고 있으면 먼저 만들어진 것이 우선된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-108&quot;&gt;해결책 3: 처리를 섞는다&lt;/h4&gt;

&lt;p&gt;어떤 클래스는 선조 클래스까지 도달하는 경로가 여러 개 있는 것이 문제다. 그렇다면 재사용하고 싶은 기능만을 모은 작은 클래스를 만들어서 해당 기능을 추가하고 싶은 클래스에 섞어 넣으면 된다. 이런 설계 방침이나 섞어 넣는 것, 그리고 섞기 위한 작은 클래스를 믹스-인(Mix-in)이라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;section-109&quot;&gt;해결책 4: 트레이트&lt;/h4&gt;

&lt;p&gt;클래스가 ‘인스턴스를 만들기 위한 것’으로 사용될 때는 재사용 단위로 너무 크다. 그러면 재사용 단위라는 역할에 특화된 보다 작은 구조(트레이트 = 메소드 묶음)를 만드는 것이 좋다. 이것이 트레이트 개념이다.&lt;/p&gt;

</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0900</pubDate>
        <link>http://yoonkh.github.io/code/2017/11/27/base.html</link>
        <guid isPermaLink="true">http://yoonkh.github.io/code/2017/11/27/base.html</guid>
        
        <category>언어</category>
        
        
        <category>Code</category>
        
      </item>
    
  </channel>
</rss>
